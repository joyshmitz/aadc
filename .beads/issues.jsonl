{"id":"bd-107","title":"Add color-coded verbose output","description":"# Color-Coded Verbose Output\n\n## CLI Interface\n\n```rust\n#[derive(Parser, Debug)]\npub struct Config {\n    /// Enable colored output (auto-detected if not specified)\n    #[arg(long)]\n    pub color: Option<bool>,\n\n    /// Verbose output with progress information\n    #[arg(long, short = 'v')]\n    pub verbose: bool,\n}\n```\n\n**Usage:**\n```bash\naadc -v diagram.txt           # Auto-detect color support\naadc -v --color diagram.txt   # Force colors on\nNO_COLOR=1 aadc -v diagram.txt # Respect NO_COLOR standard\n```\n\n## Implementation\n\n### Color Detection Logic\n\n```rust\nuse std::io::IsTerminal;\n\npub fn should_use_color(config: &Config) -> bool {\n    // Explicit flag takes precedence\n    if let Some(color) = config.color {\n        return color;\n    }\n\n    // Respect NO_COLOR environment variable (https://no-color.org/)\n    if std::env::var(\"NO_COLOR\").is_ok() {\n        return false;\n    }\n\n    // Check FORCE_COLOR for CI environments\n    if std::env::var(\"FORCE_COLOR\").is_ok() {\n        return true;\n    }\n\n    // Auto-detect: only use color if stderr is a terminal\n    std::io::stderr().is_terminal()\n}\n```\n\n### Color Definitions with rich_rust\n\n```rust\nuse rich_rust::{Style, Color};\n\npub struct VerboseColors {\n    pub header: Style,    // Bold cyan for section headers\n    pub block_id: Style,  // Yellow for block identifiers\n    pub success: Style,   // Green for success messages\n    pub warning: Style,   // Yellow for warnings\n    pub error: Style,     // Red for errors\n    pub dim: Style,       // Dim gray for secondary info\n    pub stat_label: Style, // Bold for statistic labels\n    pub stat_value: Style, // Cyan for statistic values\n}\n\nimpl VerboseColors {\n    pub fn new(use_color: bool) -> Self {\n        if use_color {\n            Self {\n                header: Style::new().bold().fg(Color::Cyan),\n                block_id: Style::new().fg(Color::Yellow),\n                success: Style::new().fg(Color::Green),\n                warning: Style::new().fg(Color::Yellow),\n                error: Style::new().bold().fg(Color::Red),\n                dim: Style::new().dim(),\n                stat_label: Style::new().bold(),\n                stat_value: Style::new().fg(Color::Cyan),\n            }\n        } else {\n            Self {\n                header: Style::new(),\n                block_id: Style::new(),\n                success: Style::new(),\n                warning: Style::new(),\n                error: Style::new(),\n                dim: Style::new(),\n                stat_label: Style::new(),\n                stat_value: Style::new(),\n            }\n        }\n    }\n}\n```\n\n### Verbose Output Formatting\n\n```rust\npub fn print_block_header(colors: &VerboseColors, block_num: usize, start: usize, end: usize, confidence: f64) {\n    test_log!(\"DEBUG\", \"Printing block header: block={}, lines={}-{}\", block_num, start, end);\n    eprintln!(\n        \"{}Block {}{}: lines {}-{} {}(confidence: {:.0}%){}\",\n        colors.header.render_str(\"\"),\n        colors.block_id.render(block_num),\n        colors.header.render_str(\"\"),\n        start,\n        end,\n        colors.dim.render_str(\"\"),\n        confidence * 100.0,\n        Style::reset()\n    );\n}\n\npub fn print_iteration_result(colors: &VerboseColors, iter: usize, revisions: usize) {\n    test_log!(\"DEBUG\", \"Iteration {}: {} revisions\", iter, revisions);\n    let status = if revisions > 0 {\n        format!(\"{}applied {} revision(s){}\",\n            colors.success.render_str(\"\"),\n            revisions,\n            Style::reset())\n    } else {\n        format!(\"{}no changes{}\", colors.dim.render_str(\"\"), Style::reset())\n    };\n    eprintln!(\"  Iteration {}: {}\", iter, status);\n}\n\npub fn print_convergence(colors: &VerboseColors, iters: usize) {\n    test_log!(\"DEBUG\", \"Converged after {} iterations\", iters);\n    eprintln!(\n        \"  {}Converged after {} iteration(s){}\",\n        colors.success.render_str(\"\"),\n        iters,\n        Style::reset()\n    );\n}\n\npub fn print_error(colors: &VerboseColors, msg: &str) {\n    test_log!(\"ERROR\", \"{}\", msg);\n    eprintln!(\"{}Error: {}{}\", colors.error.render_str(\"\"), msg, Style::reset());\n}\n```\n\n## Edge Cases\n\n1. **Piped output**: Disable colors when stderr is not a TTY\n2. **NO_COLOR env var**: Respect the standard (https://no-color.org/)\n3. **FORCE_COLOR env var**: Allow forcing colors in CI environments\n4. **TERM=dumb**: Disable colors for dumb terminals\n5. **Windows console**: Use Windows ANSI escape sequence support\n\n## Unit Tests\n\n```rust\n#[cfg(test)]\nmod color_tests {\n    use super::*;\n\n    #[test]\n    fn test_no_color_env_respected() {\n        test_log!(\"INFO\", \"Testing NO_COLOR environment variable\");\n        std::env::set_var(\"NO_COLOR\", \"1\");\n\n        let config = Config { color: None, verbose: true };\n        assert!(!should_use_color(&config));\n\n        std::env::remove_var(\"NO_COLOR\");\n        test_log!(\"PASS\", \"NO_COLOR respected âœ“\");\n    }\n\n    #[test]\n    fn test_explicit_color_flag() {\n        test_log!(\"INFO\", \"Testing explicit --color flag\");\n\n        let config_on = Config { color: Some(true), verbose: true };\n        assert!(should_use_color(&config_on));\n\n        let config_off = Config { color: Some(false), verbose: true };\n        assert!(!should_use_color(&config_off));\n\n        test_log!(\"PASS\", \"Explicit color flag works âœ“\");\n    }\n\n    #[test]\n    fn test_force_color_env() {\n        test_log!(\"INFO\", \"Testing FORCE_COLOR environment variable\");\n        std::env::set_var(\"FORCE_COLOR\", \"1\");\n\n        let config = Config { color: None, verbose: true };\n        // When NO_COLOR is not set and FORCE_COLOR is set, should use color\n        std::env::remove_var(\"NO_COLOR\");\n        assert!(should_use_color(&config));\n\n        std::env::remove_var(\"FORCE_COLOR\");\n        test_log!(\"PASS\", \"FORCE_COLOR respected âœ“\");\n    }\n\n    #[test]\n    fn test_color_style_rendering() {\n        test_log!(\"INFO\", \"Testing color style rendering\");\n        let colors = VerboseColors::new(true);\n\n        // With colors enabled, styles should produce ANSI codes\n        let styled = format!(\"{}test{}\", colors.success.render_str(\"\"), Style::reset());\n        assert!(styled.contains(\"\\x1b[\"));\n\n        let plain_colors = VerboseColors::new(false);\n        let plain = format!(\"{}test{}\", plain_colors.success.render_str(\"\"), Style::reset());\n        // Without colors, should be plain text (no ANSI codes in style part)\n\n        test_log!(\"PASS\", \"Color rendering works âœ“\");\n    }\n}\n```\n\n## E2E Tests\n\n```bash\n#!/bin/bash\n# tests/e2e_color_output.sh\n\nset -e\nsource \"$(dirname \"$0\")/e2e_runner.sh\"\n\ntest_no_color_respected() {\n    log_test_start \"no_color_respected\"\n\n    local tmpdir=$(mktemp -d)\n    setup_test_diagram \"$tmpdir\"\n\n    log_debug \"Running with NO_COLOR=1\"\n    local output=$(NO_COLOR=1 aadc -v \"$tmpdir/diagram.txt\" 2>&1)\n\n    # Should not contain ANSI escape codes\n    if echo \"$output\" | grep -q $'\\x1b\\['; then\n        log_fail \"Output contains ANSI codes despite NO_COLOR\"\n    else\n        log_pass \"NO_COLOR respected - no ANSI codes\"\n    fi\n}\n\ntest_force_color() {\n    log_test_start \"force_color\"\n\n    local tmpdir=$(mktemp -d)\n    setup_test_diagram \"$tmpdir\"\n\n    log_debug \"Running with FORCE_COLOR=1 and piped output\"\n    local output=$(FORCE_COLOR=1 aadc -v \"$tmpdir/diagram.txt\" 2>&1)\n\n    # Should contain ANSI escape codes even when piped\n    if echo \"$output\" | grep -q $'\\x1b\\['; then\n        log_pass \"FORCE_COLOR works - ANSI codes present\"\n    else\n        log_fail \"FORCE_COLOR not respected\"\n    fi\n}\n\nrun_tests test_no_color_respected test_force_color\n```\n\n## Documentation Updates\n\nREADME.md section:\n```markdown\n### Colored Output\n\nVerbose mode uses colors to improve readability:\n\n- **Green**: Success messages, corrections applied\n- **Yellow**: Block identifiers, warnings\n- **Red**: Errors\n- **Cyan**: Headers, statistics\n\nColor is automatically enabled when stderr is a terminal. Control it with:\n\n```bash\n# Disable colors\nNO_COLOR=1 aadc -v diagram.txt\n\n# Force colors (e.g., in CI logs)\nFORCE_COLOR=1 aadc -v diagram.txt\n\n# Explicit flag\naadc -v --color diagram.txt\n```\n```\n\n## Success Criteria\n\n- [ ] Verbose output uses ANSI colors when appropriate\n- [ ] Colors auto-detected based on TTY\n- [ ] NO_COLOR environment variable respected\n- [ ] FORCE_COLOR environment variable respected\n- [ ] --color flag overrides auto-detection\n- [ ] Colors disabled gracefully (no broken output)\n- [ ] rich_rust integration working\n- [ ] Unit tests pass\n- [ ] E2E tests validate color behavior","status":"in_progress","priority":3,"issue_type":"feature","created_at":"2026-01-21T02:01:13.989626553Z","created_by":"ubuntu","updated_at":"2026-01-21T19:00:04.849377037Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-107","depends_on_id":"bd-1ih","type":"blocks","created_at":"2026-01-21T02:01:36.808363018Z","created_by":"ubuntu"},{"issue_id":"bd-107","depends_on_id":"bd-3fp","type":"blocks","created_at":"2026-01-21T05:07:45.394869074Z","created_by":"ubuntu"}]}
{"id":"bd-13d","title":"Add --dry-run flag for safe preview","description":"## Purpose\nAdd a `--dry-run` flag that shows what changes would be made without actually modifying files. Essential for previewing changes before committing to them, especially in CI/CD pipelines.\n\n## CLI Interface\n\n```bash\n# Preview changes without modifying\naadc --dry-run file.txt\n# Shows: what would be changed, no file modification\n\n# Combine with diff for detailed view\naadc --dry-run --diff file.txt\n# Shows: unified diff of proposed changes\n\n# Combine with verbose for full details\naadc --dry-run -v file.txt\n# Shows: block detection info + proposed changes\n\n# Exit code reflects whether changes would be made\naadc --dry-run file.txt && echo \"No changes\" || echo \"Would change\"\n```\n\n## Implementation\n\n### Argument Definition (clap)\n```rust\n#[derive(Parser, Debug)]\npub struct Config {\n    // ... existing args ...\n    \n    /// Show what would be changed without modifying files\n    /// \n    /// Performs full analysis and correction but doesn't write\n    /// results. Useful for previewing changes or CI checks.\n    /// Exit code 0 = no changes, 1 = would change.\n    #[arg(long, short = 'n', conflicts_with = \"in_place\")]\n    pub dry_run: bool,\n}\n```\n\n### Dry Run Logic\n```rust\nfn process_file(path: &Path, config: &Config) -> anyhow::Result<ProcessResult> {\n    let original = fs::read_to_string(path)?;\n    let result = process_content(&original, config)?;\n    \n    let would_change = result.output != original;\n    \n    if config.dry_run {\n        // Don't write, just report\n        if would_change {\n            if config.verbose {\n                eprintln!(\"Would modify: {}\", path.display());\n                eprintln!(\"  {} block(s), {} revision(s)\", \n                    result.blocks_processed,\n                    result.revisions_applied\n                );\n            }\n            \n            // Optionally show diff\n            if config.diff {\n                print_diff(&original, &result.output, path);\n            }\n        } else {\n            if config.verbose {\n                eprintln!(\"No changes needed: {}\", path.display());\n            }\n        }\n    } else if config.in_place {\n        // Normal in-place mode\n        if would_change {\n            fs::write(path, &result.output)?;\n        }\n    } else {\n        // Stdout mode\n        print!(\"{}\", result.output);\n    }\n    \n    Ok(result.with_changed(would_change))\n}\n```\n\n### Exit Code Logic\n```rust\nfn main() -> anyhow::Result<()> {\n    let config = Config::parse();\n    let result = run(&config)?;\n    \n    // In dry-run mode, exit 0 if no changes, 1 if would change\n    if config.dry_run {\n        std::process::exit(if result.would_change { 1 } else { 0 });\n    }\n    \n    Ok(())\n}\n```\n\n## Use Cases\n\n### 1. Pre-commit Check\n```bash\n# In .pre-commit-config.yaml or git hook:\naadc --dry-run \"$file\" || {\n    echo \"Diagram alignment needed in $file\"\n    exit 1\n}\n```\n\n### 2. CI Pipeline Validation\n```yaml\n# GitHub Actions:\n- name: Check diagram alignment\n  run: |\n    find docs -name \"*.md\" -exec aadc --dry-run {} \\; || {\n      echo \"::error::Diagrams need alignment\"\n      exit 1\n    }\n```\n\n### 3. Preview Before Edit\n```bash\n# See what would change before committing\naadc --dry-run --diff README.md\n# Review the diff, then:\naadc -i README.md\n```\n\n### 4. Batch Validation\n```bash\n# Check multiple files\nfor f in docs/*.md; do\n    if ! aadc --dry-run \"$f\"; then\n        echo \"Would modify: $f\"\n    fi\ndone\n```\n\n## Output Modes\n\n### Default (minimal)\n```\n$ aadc --dry-run file.txt\n# No output if no changes\n# Exit code indicates status\n```\n\n### Verbose\n```\n$ aadc --dry-run -v file.txt\nWould modify: file.txt\n  2 block(s), 5 revision(s)\n```\n\n### With Diff\n```\n$ aadc --dry-run --diff file.txt\n--- file.txt\n+++ file.txt (proposed)\n@@ -3,3 +3,3 @@\n +----------+\n-| short|\n+| short    |\n +----------+\n```\n\n## Test Cases\n\n### Unit Tests\n```rust\n#[test]\nfn test_dry_run_no_file_modification() {\n    let temp = tempfile::tempdir().unwrap();\n    let file = temp.path().join(\"test.txt\");\n    let original = \"+---+\\n| a|\\n+---+\\n\";\n    fs::write(&file, original).unwrap();\n    \n    let config = Config {\n        file: Some(file.clone()),\n        dry_run: true,\n        ..Default::default()\n    };\n    \n    let result = process_file(&file, &config).unwrap();\n    \n    // File should be unchanged\n    assert_eq!(fs::read_to_string(&file).unwrap(), original);\n    // But result should indicate change would happen\n    assert!(result.would_change);\n}\n\n#[test]\nfn test_dry_run_exit_code_no_changes() {\n    let temp = tempfile::tempdir().unwrap();\n    let file = temp.path().join(\"test.txt\");\n    let aligned = \"+---+\\n| a |\\n+---+\\n\";\n    fs::write(&file, aligned).unwrap();\n    \n    let config = Config {\n        file: Some(file.clone()),\n        dry_run: true,\n        ..Default::default()\n    };\n    \n    let result = process_file(&file, &config).unwrap();\n    assert!(!result.would_change);\n}\n```\n\n### E2E Tests\n```bash\ntest_dry_run_no_modify() {\n    echo \"+---+\n| a|\n+---+\" > \"$TEMP/test.txt\"\n    \n    aadc --dry-run \"$TEMP/test.txt\"\n    \n    # File should be unchanged\n    [[ \"$(cat \"$TEMP/test.txt\")\" == *\"| a|\"* ]] || fail \"File was modified\"\n}\n\ntest_dry_run_exit_code_change() {\n    echo \"+---+\n| a|\n+---+\" > \"$TEMP/test.txt\"\n    \n    ! aadc --dry-run \"$TEMP/test.txt\"\n    # Exit code 1 = would change\n}\n\ntest_dry_run_exit_code_no_change() {\n    echo \"+---+\n| a |\n+---+\" > \"$TEMP/test.txt\"\n    \n    aadc --dry-run \"$TEMP/test.txt\"\n    # Exit code 0 = no changes\n}\n```\n\n## Error Handling\n\n### Conflicts\n```\n$ aadc --dry-run -i file.txt\nError: --dry-run and --in-place are mutually exclusive\n```\n\n### Missing File\n```\n$ aadc --dry-run nonexistent.txt\nError: File not found: nonexistent.txt\n```\n\n## Documentation Updates\n\n### README\nAdd to Command Reference:\n\n| Option | Short | Default | Description |\n|--------|-------|---------|-------------|\n| `--dry-run` | `-n` | false | Preview changes without modifying files |\n\n### FAQ Addition\n```\n**Q: How do I check if a file needs alignment without changing it?**\n\nA: Use `--dry-run`:\n\\`\\`\\`bash\naadc --dry-run file.txt && echo \"Already aligned\" || echo \"Needs alignment\"\n\\`\\`\\`\n```\n\n## Success Criteria\n- [ ] --dry-run prevents file modification\n- [ ] Exit code 0 when no changes needed\n- [ ] Exit code 1 when changes would be made\n- [ ] Works with --diff for detailed preview\n- [ ] Works with -v for summary\n- [ ] Conflicts with -i (mutual exclusion)\n- [ ] Unit tests pass\n- [ ] E2E tests pass\n- [ ] README updated\n\n## Dependencies\n- Requires: CORE: Iterative Correction Loop (bd-apa)\n- Belongs to: Feature Improvements Epic (bd-1ih)","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-21T02:00:52.226574455Z","created_by":"ubuntu","updated_at":"2026-01-21T08:49:16.956374937Z","closed_at":"2026-01-21T08:49:16.955939237Z","close_reason":"done","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-13d","depends_on_id":"bd-1ih","type":"blocks","created_at":"2026-01-21T02:01:35.965478997Z","created_by":"ubuntu"},{"issue_id":"bd-13d","depends_on_id":"bd-apa","type":"blocks","created_at":"2026-01-21T05:07:42.818387068Z","created_by":"ubuntu"}]}
{"id":"bd-13s","title":"Unit tests: Character detection functions (is_corner, is_horizontal_fill, is_vertical_border, is_junction, is_box_char, detect_vertical_border)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-21T01:45:52.925061629Z","created_by":"ubuntu","updated_at":"2026-01-21T02:57:12.913834599Z","closed_at":"2026-01-21T02:57:12.913694264Z","compaction_level":0,"original_size":0}
{"id":"bd-155","title":"E2E tests: Basic CLI functionality (stdin/stdout, file input, in-place editing, exit codes)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-21T01:46:03.392374725Z","created_by":"ubuntu","updated_at":"2026-01-21T02:28:17.508187222Z","closed_at":"2026-01-21T02:28:17.508145253Z","close_reason":"Created comprehensive E2E test script with 15 tests covering stdin/stdout, file input, in-place editing, exit codes, and error handling. Also fixed a critical index-out-of-bounds bug in Revision::score() that affected multi-block documents.","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-155","depends_on_id":"bd-p73","type":"blocks","created_at":"2026-01-21T01:46:31.398155393Z","created_by":"ubuntu"}]}
{"id":"bd-18a","title":"Testing Infrastructure Epic","status":"closed","priority":0,"issue_type":"epic","created_at":"2026-01-21T01:45:12.176565630Z","created_by":"ubuntu","updated_at":"2026-01-21T03:37:04.563236815Z","closed_at":"2026-01-21T03:37:04.562318626Z","compaction_level":0,"original_size":0}
{"id":"bd-195","title":"Update AGENTS.md and README.md with test commands and coverage badge","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-21T01:46:19.408271769Z","created_by":"ubuntu","updated_at":"2026-01-21T10:56:01.169158547Z","closed_at":"2026-01-21T10:56:01.169118662Z","close_reason":"done","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-195","depends_on_id":"bd-2sm","type":"blocks","created_at":"2026-01-21T05:07:48.249150467Z","created_by":"ubuntu"},{"issue_id":"bd-195","depends_on_id":"bd-flx","type":"blocks","created_at":"2026-01-21T01:46:42.648090442Z","created_by":"ubuntu"}]}
{"id":"bd-1am","title":"CORE: Box Character Recognition System","description":"# CORE: Box Character Recognition System\n\n## Purpose\n\nThe foundation of aadc's diagram detection is recognizing box-drawing characters. This system must distinguish diagram elements from regular text with high accuracy.\n\n## Character Categories\n\n### 1. Corner Characters (13 total)\n\n```\nASCII:   +\nLight:   â”Œ â” â”” â”˜\nDouble:  â•” â•— â•š â•\nRounded: â•­ â•® â•¯ â•°\n```\n\n**Implementation**: `is_corner(c: char) -> bool`\n**Location**: src/main.rs lines ~117-130\n\n### 2. Horizontal Fill Characters (12 total)\n\n```\nASCII:  - ~ =\nLight:  â”€ â•Œ â”„ â”ˆ\nHeavy:  â” â• â”… â”‰\nDouble: â•\n```\n\n**Implementation**: `is_horizontal_fill(c: char) -> bool`\n**Location**: src/main.rs lines ~132-145\n\n### 3. Vertical Border Characters (10 total)\n\n```\nASCII:  |\nLight:  â”‚ â•Ž â”† â”Š\nHeavy:  â”ƒ â• â”‡ â”‹\nDouble: â•‘\n```\n\n**Implementation**: `is_vertical_border(c: char) -> bool`\n**Location**: src/main.rs lines ~147-160\n\n### 4. Junction Characters (16 total)\n\n```\nT-junctions: â”¬ â”´ â”œ â”¤\nCrosses:     â”¼\nDouble:      â•¦ â•© â•  â•£ â•¬\nMixed:       â•¤ â•§ â•Ÿ â•¢ â•« â•ª\n```\n\n**Implementation**: `is_junction(c: char) -> bool`\n**Location**: src/main.rs lines ~162-175\n\n## Helper Functions\n\n### `is_box_char(c: char) -> bool`\nReturns true if character belongs to ANY box-drawing category.\nUsed for quick checks and counting.\n\n### `is_border_char(c: char) -> bool`\nReturns true for characters that can terminate a line border (vertical borders, corners, junctions).\n\n## Design Decisions\n\n### Why Match Statements Over HashSets?\n- Match compiles to efficient jump tables\n- No runtime allocation\n- Compiler can optimize for common cases\n- Character sets are static, no runtime changes\n\n### Why Include Rounded Corners?\n- Increasingly common in modern documentation\n- Same structural role as square corners\n- No downside to supporting them\n\n### Why Heavy/Double Variants?\n- Professional documentation uses varied styles\n- Some tools generate double-line boxes\n- Users shouldn't need to manually convert styles\n\n## Test Coverage\n\nEach category has dedicated tests:\n- `test_is_corner` - All 13 corners + negative cases\n- `test_is_horizontal_fill` - All 12 fills + negative cases\n- `test_is_vertical_border` - All 10 borders + negative cases\n- `test_is_junction` - All 16 junctions + negative cases\n\n## Future Considerations\n\n1. **Custom Character Sets**: Allow users to define additional box characters\n2. **Character Normalization**: Convert heavyâ†’light or doubleâ†’single if needed\n3. **Box Style Detection**: Identify which style a block uses for consistent border insertion\n\n## Related Beads\n\n- CORE: Line Classification Algorithm (uses these functions)\n- CORE: Block Detection Algorithm (uses these functions)\n- CORE: Suffix Border Detection (uses is_border_char)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-21T04:55:19.433607975Z","created_by":"ubuntu","updated_at":"2026-01-21T07:31:17.464283416Z","closed_at":"2026-01-21T07:31:17.462451025Z","close_reason":"Validated box character recognition functions + tests; no code changes needed","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1am","depends_on_id":"bd-30v","type":"blocks","created_at":"2026-01-21T05:07:30.909613272Z","created_by":"ubuntu"}]}
{"id":"bd-1c4","title":"Add --json flag for machine-readable output","description":"## Purpose\nAdd a `--json` flag for machine-readable output. Essential for integration with other tools, CI systems, and programmatic processing.\n\n## CLI Interface\n\n```bash\n# JSON output instead of corrected content\naadc --json file.txt\n\n# Combine with dry-run for analysis\naadc --json --dry-run file.txt\n\n# Pipe to jq for processing\naadc --json file.txt | jq '.blocks | length'\n```\n\n## Output Schema\n\n### Success Response\n```json\n{\n  \"version\": \"1.0\",\n  \"status\": \"success\",\n  \"file\": \"diagram.txt\",\n  \"input\": {\n    \"lines\": 15,\n    \"bytes\": 342\n  },\n  \"processing\": {\n    \"blocks_detected\": 2,\n    \"blocks_processed\": 2,\n    \"revisions_applied\": 5,\n    \"iterations\": 2,\n    \"converged\": true\n  },\n  \"blocks\": [\n    {\n      \"start_line\": 3,\n      \"end_line\": 7,\n      \"confidence\": 0.95,\n      \"revisions\": 3,\n      \"lines_modified\": [\"4\", \"5\", \"6\"]\n    },\n    {\n      \"start_line\": 11,\n      \"end_line\": 13,\n      \"confidence\": 0.87,\n      \"revisions\": 2,\n      \"lines_modified\": [\"12\"]\n    }\n  ],\n  \"output\": {\n    \"lines\": 15,\n    \"bytes\": 352,\n    \"changed\": true\n  },\n  \"content\": \"...corrected content...\" \n}\n```\n\n### Dry-run Response\n```json\n{\n  \"version\": \"1.0\",\n  \"status\": \"dry_run\",\n  \"file\": \"diagram.txt\",\n  \"would_change\": true,\n  \"processing\": { ... },\n  \"blocks\": [ ... ]\n  // No \"content\" field in dry-run mode\n}\n```\n\n### Error Response\n```json\n{\n  \"version\": \"1.0\",\n  \"status\": \"error\",\n  \"file\": \"diagram.txt\",\n  \"error\": {\n    \"code\": \"file_not_found\",\n    \"message\": \"File not found: diagram.txt\"\n  }\n}\n```\n\n## Implementation\n\n### Argument Definition (clap)\n```rust\n#[derive(Parser, Debug)]\npub struct Config {\n    // ... existing args ...\n    \n    /// Output results as JSON\n    /// \n    /// Outputs structured JSON instead of corrected content.\n    /// Useful for programmatic processing and CI integration.\n    #[arg(long)]\n    pub json: bool,\n}\n```\n\n### JSON Output Structures\n```rust\nuse serde::{Serialize, Deserialize};\n\n#[derive(Serialize)]\nstruct JsonOutput {\n    version: &'static str,\n    status: String,\n    file: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    input: Option<InputStats>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    processing: Option<ProcessingStats>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    blocks: Option<Vec<BlockInfo>>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    output: Option<OutputStats>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    content: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    error: Option<ErrorInfo>,\n}\n\n#[derive(Serialize)]\nstruct InputStats {\n    lines: usize,\n    bytes: usize,\n}\n\n#[derive(Serialize)]\nstruct ProcessingStats {\n    blocks_detected: usize,\n    blocks_processed: usize,\n    revisions_applied: usize,\n    iterations: usize,\n    converged: bool,\n}\n\n#[derive(Serialize)]\nstruct BlockInfo {\n    start_line: usize,\n    end_line: usize,\n    confidence: f64,\n    revisions: usize,\n    lines_modified: Vec<String>,\n}\n\n#[derive(Serialize)]\nstruct OutputStats {\n    lines: usize,\n    bytes: usize,\n    changed: bool,\n}\n\n#[derive(Serialize)]\nstruct ErrorInfo {\n    code: String,\n    message: String,\n}\n```\n\n### Output Function\n```rust\nfn output_json(result: &ProcessResult, config: &Config) -> anyhow::Result<()> {\n    let output = JsonOutput {\n        version: \"1.0\",\n        status: if result.error.is_some() { \n            \"error\".to_string() \n        } else if config.dry_run { \n            \"dry_run\".to_string() \n        } else { \n            \"success\".to_string() \n        },\n        file: config.file.as_ref().map(|p| p.display().to_string()),\n        input: Some(InputStats {\n            lines: result.input_lines,\n            bytes: result.input_bytes,\n        }),\n        processing: Some(ProcessingStats {\n            blocks_detected: result.blocks_detected,\n            blocks_processed: result.blocks_processed,\n            revisions_applied: result.revisions_applied,\n            iterations: result.iterations,\n            converged: result.converged,\n        }),\n        blocks: Some(result.blocks.iter().map(|b| BlockInfo {\n            start_line: b.start + 1,  // 1-indexed for users\n            end_line: b.end,\n            confidence: b.confidence,\n            revisions: b.revisions,\n            lines_modified: b.modified_lines.iter().map(|l| (l + 1).to_string()).collect(),\n        }).collect()),\n        output: if !config.dry_run {\n            Some(OutputStats {\n                lines: result.output.lines().count(),\n                bytes: result.output.len(),\n                changed: result.changed,\n            })\n        } else { None },\n        content: if !config.dry_run && !config.in_place {\n            Some(result.output.clone())\n        } else { None },\n        error: result.error.as_ref().map(|e| ErrorInfo {\n            code: e.code.clone(),\n            message: e.message.clone(),\n        }),\n    };\n    \n    println!(\"{}\", serde_json::to_string_pretty(&output)?);\n    Ok(())\n}\n```\n\n## Test Cases\n\n### Unit Tests\n```rust\n#[test]\nfn test_json_output_success() {\n    let result = process_with_json(\"+---+\\n| a|\\n+---+\\n\", &Config::default());\n    let json: serde_json::Value = serde_json::from_str(&result.stdout).unwrap();\n    \n    assert_eq!(json[\"status\"], \"success\");\n    assert_eq!(json[\"processing\"][\"blocks_processed\"], 1);\n    assert!(json[\"output\"][\"changed\"].as_bool().unwrap());\n}\n\n#[test]\nfn test_json_output_dry_run() {\n    let config = Config { dry_run: true, json: true, ..Default::default() };\n    let result = process_with_json(\"+---+\\n| a|\\n+---+\\n\", &config);\n    let json: serde_json::Value = serde_json::from_str(&result.stdout).unwrap();\n    \n    assert_eq!(json[\"status\"], \"dry_run\");\n    assert!(json[\"content\"].is_null());  // No content in dry-run\n}\n\n#[test]\nfn test_json_output_error() {\n    let config = Config { json: true, ..Default::default() };\n    let result = process_file_with_json(Path::new(\"nonexistent.txt\"), &config);\n    let json: serde_json::Value = serde_json::from_str(&result.stdout).unwrap();\n    \n    assert_eq!(json[\"status\"], \"error\");\n    assert_eq!(json[\"error\"][\"code\"], \"file_not_found\");\n}\n\n#[test]\nfn test_json_block_info() {\n    let input = \"text\\n+---+\\n| a|\\n+---+\\nmore\";\n    let result = process_with_json(input, &Config { json: true, ..Default::default() });\n    let json: serde_json::Value = serde_json::from_str(&result.stdout).unwrap();\n    \n    let block = &json[\"blocks\"][0];\n    assert_eq!(block[\"start_line\"], 2);  // 1-indexed\n    assert_eq!(block[\"end_line\"], 4);\n}\n```\n\n### E2E Tests\n```bash\ntest_json_output_valid() {\n    echo \"+---+\n| a|\n+---+\" > \"$TEMP/test.txt\"\n    \n    aadc --json \"$TEMP/test.txt\" > \"$TEMP/output.json\"\n    \n    # Validate JSON\n    jq . \"$TEMP/output.json\" > /dev/null || fail \"Invalid JSON\"\n    \n    # Check fields\n    [[ $(jq -r '.status' \"$TEMP/output.json\") == \"success\" ]] || fail \"Wrong status\"\n    [[ $(jq -r '.processing.blocks_processed' \"$TEMP/output.json\") == \"1\" ]] || fail \"Wrong block count\"\n}\n\ntest_json_with_jq() {\n    echo \"+---+\n| a|\n+---+\" > \"$TEMP/test.txt\"\n    \n    block_count=$(aadc --json \"$TEMP/test.txt\" | jq '.blocks | length')\n    \n    [[ \"$block_count\" == \"1\" ]] || fail \"Expected 1 block, got $block_count\"\n}\n\ntest_json_dry_run() {\n    echo \"+---+\n| a|\n+---+\" > \"$TEMP/test.txt\"\n    \n    status=$(aadc --json --dry-run \"$TEMP/test.txt\" | jq -r '.status')\n    \n    [[ \"$status\" == \"dry_run\" ]] || fail \"Expected dry_run status\"\n}\n```\n\n## Documentation Updates\n\n### README\n```markdown\n## JSON Output\n\nFor programmatic processing, use \\`--json\\`:\n\n\\`\\`\\`bash\naadc --json file.txt | jq '.blocks | length'\n\\`\\`\\`\n\nOutput includes processing stats, block information, and corrected content.\n```\n\n## Success Criteria\n- [ ] --json outputs valid JSON\n- [ ] Schema is stable and documented\n- [ ] Works with --dry-run\n- [ ] Works with multiple files\n- [ ] Errors are JSON-formatted\n- [ ] Unit tests pass\n- [ ] E2E tests pass\n- [ ] README documents schema\n\n## Dependencies\n- Requires: CORE: Iterative Correction Loop (bd-apa)\n- Requires: serde, serde_json crates\n- Belongs to: Feature Improvements Epic (bd-1ih)","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-21T02:00:56.472015991Z","created_by":"ubuntu","updated_at":"2026-01-21T09:21:58.786843058Z","closed_at":"2026-01-21T09:21:58.786795559Z","close_reason":"done","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1c4","depends_on_id":"bd-1ih","type":"blocks","created_at":"2026-01-21T02:01:36.530229016Z","created_by":"ubuntu"},{"issue_id":"bd-1c4","depends_on_id":"bd-apa","type":"blocks","created_at":"2026-01-21T05:07:43.542128483Z","created_by":"ubuntu"}]}
{"id":"bd-1g0","title":"E2E tests: Edge cases (empty input, no diagrams, already-aligned, malformed, single-line, tabs)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-21T01:46:07.137981976Z","created_by":"ubuntu","updated_at":"2026-01-21T03:01:11.531781091Z","closed_at":"2026-01-21T03:01:11.531021931Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1g0","depends_on_id":"bd-p73","type":"blocks","created_at":"2026-01-21T01:46:31.692065115Z","created_by":"ubuntu"}]}
{"id":"bd-1ih","title":"Feature Improvements Epic","description":"Epic containing all 15 feature improvement ideas from idea-wizard analysis. Covers: diff output, dry-run, backup, watch mode, config files, JSON output, pre-commit hooks, colors, line ranges, multi-file, recursive, exit codes, presets, stats, optimization.","status":"closed","priority":1,"issue_type":"epic","created_at":"2026-01-21T02:01:25.194828711Z","created_by":"ubuntu","updated_at":"2026-01-21T03:36:33.616292989Z","closed_at":"2026-01-21T03:36:33.615522268Z","compaction_level":0,"original_size":0}
{"id":"bd-1lr","title":"GitHub Actions: Release workflow (cross-platform builds, checksums, GitHub Release)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-21T01:46:17.636863235Z","created_by":"ubuntu","updated_at":"2026-01-21T08:36:57.696576353Z","closed_at":"2026-01-21T08:36:57.696533271Z","close_reason":"done","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1lr","depends_on_id":"bd-2sm","type":"blocks","created_at":"2026-01-21T05:07:47.898178449Z","created_by":"ubuntu"},{"issue_id":"bd-1lr","depends_on_id":"bd-flx","type":"blocks","created_at":"2026-01-21T01:46:42.497535255Z","created_by":"ubuntu"}]}
{"id":"bd-1on","title":"Add --watch flag for auto-correction","description":"# --watch Flag for Auto-Correction\n\n## CLI Interface\n\n```rust\n#[derive(Parser, Debug)]\npub struct Config {\n    /// Watch file for changes and auto-correct\n    #[arg(long, short = 'w', conflicts_with = \"in_place\")]\n    pub watch: bool,\n\n    /// Debounce interval in milliseconds (for --watch mode)\n    #[arg(long, default_value = \"500\", requires = \"watch\")]\n    pub debounce_ms: u64,\n}\n```\n\n**Usage:**\n```bash\naadc --watch diagram.txt           # Watch single file\naadc -w --debounce-ms 1000 file.md # Custom debounce\naadc --watch --verbose diagram.txt  # With progress output\n```\n\n## Implementation\n\n### Dependencies\nAdd to Cargo.toml:\n```toml\n[dependencies]\nnotify = { version = \"6.0\", default-features = false, features = [\"macos_kqueue\"] }\n```\n\n### Core Watch Logic\n\n```rust\nuse notify::{Watcher, RecommendedWatcher, RecursiveMode, Event, EventKind};\nuse std::sync::mpsc;\nuse std::time::{Duration, Instant};\n\npub fn watch_and_correct(config: &Config, path: &Path) -> Result<(), Error> {\n    test_log!(\"INFO\", \"Starting watch mode for: {:?}\", path);\n\n    let (tx, rx) = mpsc::channel();\n    let mut watcher = RecommendedWatcher::new(\n        move |res: Result<Event, _>| {\n            if let Ok(event) = res {\n                let _ = tx.send(event);\n            }\n        },\n        notify::Config::default()\n    )?;\n\n    watcher.watch(path, RecursiveMode::NonRecursive)?;\n    test_log!(\"DEBUG\", \"Watcher initialized, debounce={}ms\", config.debounce_ms);\n\n    eprintln!(\"Watching {} for changes (Ctrl+C to stop)...\", path.display());\n\n    let mut last_event = Instant::now();\n    let debounce = Duration::from_millis(config.debounce_ms);\n\n    loop {\n        match rx.recv_timeout(Duration::from_millis(100)) {\n            Ok(event) => {\n                if matches!(event.kind, EventKind::Modify(_)) {\n                    let now = Instant::now();\n                    if now.duration_since(last_event) >= debounce {\n                        test_log!(\"INFO\", \"File modified, running correction...\");\n                        last_event = now;\n\n                        match process_file(config, path) {\n                            Ok(stats) => {\n                                if stats.revisions_applied > 0 {\n                                    eprintln!(\"âœ“ Applied {} revision(s)\", stats.revisions_applied);\n                                } else {\n                                    eprintln!(\"âœ“ No changes needed\");\n                                }\n                            }\n                            Err(e) => {\n                                eprintln!(\"âœ— Error: {}\", e);\n                            }\n                        }\n                    }\n                }\n            }\n            Err(mpsc::RecvTimeoutError::Timeout) => continue,\n            Err(mpsc::RecvTimeoutError::Disconnected) => break,\n        }\n    }\n\n    Ok(())\n}\n```\n\n### Signal Handling for Clean Exit\n\n```rust\nuse ctrlc;\n\nfn setup_signal_handler() -> mpsc::Receiver<()> {\n    let (tx, rx) = mpsc::channel();\n    ctrlc::set_handler(move || {\n        let _ = tx.send(());\n    }).expect(\"Error setting Ctrl-C handler\");\n    rx\n}\n```\n\n## Edge Cases\n\n1. **File deleted while watching**: Handle gracefully, exit with message\n2. **Permission change**: Re-check permissions on each modification\n3. **Symlink changes**: Follow symlinks, detect if target changes\n4. **Editor temp files**: Some editors write to temp then rename - detect rename events\n5. **Rapid saves**: Debounce prevents excessive processing\n\n## Unit Tests\n\n```rust\n#[cfg(test)]\nmod watch_tests {\n    use super::*;\n    use std::fs;\n    use tempfile::TempDir;\n\n    #[test]\n    fn test_debounce_logic() {\n        test_log!(\"INFO\", \"Testing debounce timing\");\n        let debounce = Duration::from_millis(500);\n        let mut last = Instant::now() - Duration::from_secs(1);\n\n        // First event should trigger\n        assert!(Instant::now().duration_since(last) >= debounce);\n        test_log!(\"DEBUG\", \"First event passes debounce check\");\n\n        last = Instant::now();\n\n        // Immediate second event should not trigger\n        assert!(Instant::now().duration_since(last) < debounce);\n        test_log!(\"PASS\", \"Debounce logic works correctly âœ“\");\n    }\n\n    #[test]\n    fn test_watch_mode_config() {\n        test_log!(\"INFO\", \"Testing watch config parsing\");\n        let args = [\"aadc\", \"--watch\", \"--debounce-ms\", \"1000\", \"file.txt\"];\n        let config = Config::try_parse_from(&args).unwrap();\n\n        assert!(config.watch);\n        assert_eq!(config.debounce_ms, 1000);\n        test_log!(\"PASS\", \"Watch config parsed correctly âœ“\");\n    }\n\n    #[test]\n    fn test_watch_in_place_conflict() {\n        test_log!(\"INFO\", \"Testing --watch conflicts with --in-place\");\n        let args = [\"aadc\", \"--watch\", \"--in-place\", \"file.txt\"];\n        let result = Config::try_parse_from(&args);\n\n        assert!(result.is_err());\n        test_log!(\"PASS\", \"Conflict detected as expected âœ“\");\n    }\n}\n```\n\n## E2E Tests\n\n```bash\n#!/bin/bash\n# tests/e2e_watch_mode.sh\n# Test cleanup uses tempfile auto-removal via trap\n\nset -e\nsource \"$(dirname \"$0\")/e2e_runner.sh\"\n\ntest_watch_mode_basic() {\n    log_test_start \"watch_mode_basic\"\n\n    local tmpdir=$(mktemp -d)\n    # Cleanup on exit (tmpdir is in /tmp, safe to remove)\n    trap \"command rm -r $tmpdir\" EXIT\n\n    cat > \"$tmpdir/diagram.txt\" << 'EOF'\n+--------+\n| Hello|\n+--------+\nEOF\n\n    log_debug \"Starting aadc in watch mode (background)\"\n    timeout 5 aadc --watch \"$tmpdir/diagram.txt\" &\n    local pid=$!\n    sleep 1\n\n    log_debug \"Modifying file to trigger watch\"\n    cat > \"$tmpdir/diagram.txt\" << 'EOF'\n+--------+\n| Test|\n+--------+\nEOF\n    sleep 1\n\n    kill $pid 2>/dev/null || true\n\n    log_debug \"Checking output was corrected\"\n    grep -q \"| Test    |\" \"$tmpdir/diagram.txt\" && \\\n        log_pass \"Watch mode corrected file\" || \\\n        log_fail \"Watch mode did not correct file\"\n}\n\nrun_tests test_watch_mode_basic\n```\n\n## Documentation Updates\n\nREADME.md section:\n```markdown\n### Watch Mode\n\nAutomatically re-correct files when they change:\n\n```bash\n# Start watching a file\naadc --watch diagram.txt\n\n# With custom debounce (default 500ms)\naadc --watch --debounce-ms 1000 diagram.txt\n\n# Watch with verbose output\naadc -v --watch diagram.txt\n```\n\nWatch mode is ideal for iterative diagram editing workflows.\n```\n\n## Success Criteria\n\n- [ ] --watch flag starts filesystem watcher on target file\n- [ ] Modifications trigger correction automatically\n- [ ] Debounce prevents excessive processing on rapid saves\n- [ ] Ctrl+C cleanly stops watch mode\n- [ ] Status messages show correction results\n- [ ] Conflicts with --in-place (watch inherently modifies in-place)\n- [ ] Unit tests pass\n- [ ] E2E test validates full watch cycle","status":"in_progress","priority":3,"issue_type":"feature","created_at":"2026-01-21T02:00:53.972295869Z","created_by":"ubuntu","updated_at":"2026-01-21T20:37:20.976672724Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1on","depends_on_id":"bd-1ih","type":"blocks","created_at":"2026-01-21T02:01:36.254658872Z","created_by":"ubuntu"},{"issue_id":"bd-1on","depends_on_id":"bd-apa","type":"blocks","created_at":"2026-01-21T05:07:47.202374877Z","created_by":"ubuntu"},{"issue_id":"bd-1on","depends_on_id":"bd-nci","type":"blocks","created_at":"2026-01-21T02:01:44.529701582Z","created_by":"ubuntu"}]}
{"id":"bd-1oq","title":"CORE: Revision Generation System","description":"# CORE: Revision Generation System\n\n## Purpose\n\nGenerate candidate edits that would align right-hand borders. Each revision is a proposal that gets scored before application. This system embodies the 'monotone/insert-only' principle - we only ADD padding, never remove content.\n\n## Revision Enum\n\n```rust\nenum Revision {\n    PadBeforeSuffixBorder {\n        line_idx: usize,        // Which line to modify\n        spaces_to_add: usize,   // How many spaces to insert\n        target_column: usize,   // Desired final border position\n    },\n    AddSuffixBorder {\n        line_idx: usize,        // Which line to modify\n        border_char: char,      // What border char to add\n        target_column: usize,   // Where to place it\n    },\n}\n```\n\n**Location**: src/main.rs lines ~409-422\n\n## Two Revision Types\n\n### 1. PadBeforeSuffixBorder\n\n**When**: Line already has a right border but it's at the wrong column.\n\n```\nCurrent:    \"| short|\"        border at col 7\nTarget:     \"| short     |\"   border at col 12\nRevision:   PadBeforeSuffixBorder { line_idx, spaces_to_add: 5, target: 12 }\n```\n\n**How it works**:\n1. Extract everything before the last char (the border)\n2. Insert N spaces\n3. Append the border char back\n\n### 2. AddSuffixBorder\n\n**When**: Line has no right border but should (boxy line missing closing border).\n\n```\nCurrent:    \"| content without border\"\nTarget:     \"| content without border  |\"\nRevision:   AddSuffixBorder { line_idx, border_char: '|', target: 26 }\n```\n\n**How it works**:\n1. Calculate current visual width\n2. Pad with spaces to reach target column\n3. Append the border character\n\n## Generation Algorithm\n\n```rust\nfn generate_revisions(\n    analyzed: &[AnalyzedLine],\n    target_column: usize,\n) -> Vec<(Revision, f64)> {\n    let mut revisions = Vec::new();\n    \n    // Find most common border char for AddSuffixBorder\n    let common_border = find_most_common_border(analyzed);\n    \n    for (idx, line) in analyzed.iter().enumerate() {\n        match &line.suffix_border {\n            Some(border) if border.column < target_column => {\n                // Has border but needs padding\n                let spaces = target_column - border.column;\n                let score = score_pad_revision(spaces, &line.kind);\n                \n                revisions.push((\n                    Revision::PadBeforeSuffixBorder {\n                        line_idx: idx,\n                        spaces_to_add: spaces,\n                        target_column,\n                    },\n                    score,\n                ));\n            }\n            None if line.kind != LineKind::Blank && line.kind != LineKind::None => {\n                // Boxy line missing border\n                let score = score_add_revision(&line.kind);\n                \n                revisions.push((\n                    Revision::AddSuffixBorder {\n                        line_idx: idx,\n                        border_char: common_border,\n                        target_column,\n                    },\n                    score,\n                ));\n            }\n            _ => {\n                // Already aligned or not a diagram line\n            }\n        }\n    }\n    \n    revisions\n}\n```\n\n## Finding Most Common Border\n\nWhen adding borders, we use the most frequently occurring border character in the block:\n\n```rust\nfn find_most_common_border(analyzed: &[AnalyzedLine]) -> char {\n    let mut counts: HashMap<char, usize> = HashMap::new();\n    \n    for line in analyzed {\n        if let Some(border) = &line.suffix_border {\n            *counts.entry(border.char).or_default() += 1;\n        }\n    }\n    \n    counts.into_iter()\n        .max_by_key(|(_, count)| *count)\n        .map(|(ch, _)| ch)\n        .unwrap_or('|')  // Default to ASCII pipe\n}\n```\n\n**Rationale**: If a block uses Unicode boxes (â”‚), we should add â”‚, not |. Frequency analysis picks the dominant style.\n\n## Target Column Calculation\n\nThe target column is simply the rightmost border position:\n\n```rust\nfn find_target_column(analyzed: &[AnalyzedLine]) -> Option<usize> {\n    analyzed.iter()\n        .filter_map(|l| l.suffix_border.as_ref())\n        .map(|b| b.column)\n        .max()\n}\n```\n\n## Why Not Remove Characters?\n\n**Design Decision**: We NEVER remove characters, only add padding.\n\n**Rationale**:\n1. User content is sacred - we can't risk losing data\n2. Removal requires understanding WHAT to remove (complex)\n3. Adding spaces is always safe and reversible\n4. If a line is \"too long\", user should fix it manually\n\n**Example of what we DON'T do**:\n```\n# Would require removal (NOT SUPPORTED):\n\"| very long content that extends past border     |\"\n                                              â†‘ remove these?\n```\n\n## Revision Scoring\n\nSee CORE: Revision Scoring System bead for detailed scoring algorithm.\n\nQuick summary:\n- PadBeforeSuffixBorder: 0.3 to 1.0 based on spaces_to_add and line strength\n- AddSuffixBorder: 0.6 to 0.7 based on line strength\n\n## Edge Cases\n\n1. **Already Aligned**: No revision generated (border.column == target_column)\n2. **Beyond Target**: No revision generated (we don't shrink)\n3. **No Borders in Block**: target_column is None, no revisions\n4. **Mixed Box Styles**: Uses most common style for consistency\n\n## Performance\n\n- O(n) where n = lines in block\n- One pass for target column\n- One pass for revisions\n- HashMap for border frequency (small N, fast)\n\n## Test Coverage\n\n```rust\n#[test] fn test_generate_revisions_padding() { ... }\n#[test] fn test_generate_revisions_add_border() { ... }\n#[test] fn test_generate_revisions_already_aligned() { ... }\n#[test] fn test_find_target_column() { ... }\n#[test] fn test_find_most_common_border() { ... }\n```\n\n## Dependencies\n\n- Requires: CORE: Suffix Border Detection\n- Requires: CORE: Line Classification\n- Used by: CORE: Iterative Correction Loop\n- Followed by: CORE: Revision Scoring System","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-21T04:59:01.228960318Z","created_by":"ubuntu","updated_at":"2026-01-21T08:16:52.526447901Z","closed_at":"2026-01-21T08:16:52.526349255Z","close_reason":"done","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1oq","depends_on_id":"bd-2r3","type":"blocks","created_at":"2026-01-21T05:07:19.657415995Z","created_by":"ubuntu"},{"issue_id":"bd-1oq","depends_on_id":"bd-fdi","type":"blocks","created_at":"2026-01-21T05:07:19.305534153Z","created_by":"ubuntu"}]}
{"id":"bd-1q9","title":"CORE: Visual Width Calculation (Unicode/CJK)","description":"# CORE: Visual Width Calculation (Unicode/CJK)\n\n## Purpose\n\nCalculate the display width of text as it appears in a terminal, accounting for characters that occupy multiple columns. Critical for correct alignment when content contains CJK characters, emoji, or other wide glyphs.\n\n## The Problem\n\n```\nCharacter bytes vs display columns:\n- 'a' = 1 byte, 1 column\n- 'â”‚' = 3 bytes, 1 column (UTF-8 box drawing)\n- 'ä½ ' = 3 bytes, 2 columns (CJK)\n- 'ðŸš€' = 4 bytes, 2 columns (emoji)\n```\n\nIf we use byte length or char count, CJK text will be misaligned:\n\n```\nWRONG (char count):           CORRECT (visual width):\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ Hello    â”‚                  â”‚ Hello        â”‚\nâ”‚ ä½ å¥½ä¸–ç•Œ â”‚  â† 4 chars       â”‚ ä½ å¥½ä¸–ç•Œ     â”‚  â† 8 columns\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n## Implementation\n\n```rust\nfn visual_width(s: &str) -> usize {\n    s.chars().map(|c| {\n        if c.is_ascii() {\n            1\n        } else if is_box_char(c) {\n            1  // Box drawing chars are always 1 column\n        } else if c >= '\\u{1100}' {\n            2  // CJK and wide characters heuristic\n        } else {\n            1  // Default for other Unicode\n        }\n    }).sum()\n}\n```\n\n**Location**: src/main.rs lines ~206-224\n\n## Width Rules\n\n### 1 Column Characters\n- All ASCII (0x00-0x7F)\n- Box-drawing characters (U+2500-U+257F)\n- Most Latin, Greek, Cyrillic\n- Combining characters (though displayed over previous char)\n\n### 2 Column Characters\n- CJK Unified Ideographs (U+4E00-U+9FFF)\n- CJK Compatibility (U+3300-U+33FF)\n- Hangul Syllables (U+AC00-U+D7AF)\n- Full-width forms (U+FF00-U+FFEF)\n- Most emoji (U+1F300+)\n\n## Heuristic Threshold: U+1100\n\nThe implementation uses `c >= '\\u{1100}'` as a simple heuristic:\n\n**Why U+1100?**\n- First Hangul Jamo character\n- Marks beginning of East Asian character ranges\n- Captures: Hangul, CJK, full-width, emoji\n- Simple comparison, no lookup tables\n\n**Trade-offs:**\n- Slightly over-estimates some characters\n- Under-estimates some combining chars\n- Good enough for 99% of real-world diagrams\n- Avoids heavyweight unicode-width crate\n\n## Edge Cases\n\n1. **Tab Characters**: Handled separately by tab expansion (before visual_width is called)\n2. **Control Characters**: Treated as 0-width in display, but code treats as 1\n3. **Zero-Width Joiner**: Treated as 1 (imperfect but safe)\n4. **Variation Selectors**: Treated as 1 (imperfect but safe)\n\n## Performance\n\n- O(n) where n = number of characters\n- No allocations\n- Simple comparisons, no hash lookups\n- Hot path function - called for every line in every iteration\n\n## Alternative: unicode-width Crate\n\nWe could use the `unicode-width` crate for precise calculations:\n\n```rust\nuse unicode_width::UnicodeWidthStr;\nlet width = s.width();\n```\n\n**Pros:**\n- More accurate for edge cases\n- Handles variation selectors correctly\n- Based on Unicode standard tables\n\n**Cons:**\n- Additional dependency\n- Larger binary size\n- Slower (table lookups)\n\n**Decision**: Use heuristic for now. Add unicode-width only if users report alignment issues.\n\n## Test Coverage\n\n```rust\n#[test] fn test_visual_width_ascii() { ... }\n#[test] fn test_visual_width_unicode_box() { ... }\n#[test] fn test_visual_width_cjk() { ... }\n#[test] fn test_visual_width_mixed() { ... }\n```\n\n## Related Beads\n\n- Used by: CORE: Suffix Border Detection\n- Used by: CORE: Revision Application\n- Used by: CORE: Tab Expansion","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-21T04:56:11.372887755Z","created_by":"ubuntu","updated_at":"2026-01-21T07:33:11.360480179Z","closed_at":"2026-01-21T07:33:11.359650707Z","close_reason":"Validated visual_width heuristic + tests; no code changes needed","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1q9","depends_on_id":"bd-1am","type":"blocks","created_at":"2026-01-21T05:07:17.502437994Z","created_by":"ubuntu"}]}
{"id":"bd-1zp","title":"Add stdin passthrough optimization","description":"# Stdin Passthrough Optimization\n\n## CLI Interface\n\nNo explicit flag - this is an automatic optimization.\n\n```rust\n/// Threshold for quick passthrough: minimum percentage of lines\n/// that must contain box-drawing characters to process the input\nconst QUICK_SCAN_THRESHOLD: f64 = 0.01;  // At least 1% of lines\n\n/// Maximum lines to scan for quick detection\nconst QUICK_SCAN_LIMIT: usize = 1000;\n```\n\n**Behavior:**\n```bash\n# Fast: plain text passes through immediately\ncat essay.txt | aadc            # Detects no diagrams, passes through\n\n# Normal: files with diagrams processed normally\ncat diagram.txt | aadc          # Detects diagrams, processes\n\n# Debug the detection\ncat file.txt | aadc -v          # Shows \"Quick scan: no diagrams detected\"\n```\n\n## Implementation\n\n### Quick Scan Function\n\n```rust\n/// Characters that indicate box-drawing content\nconst BOX_CHARS: &[char] = &[\n    // ASCII box drawing\n    '+', '|', '-',\n    // Unicode box drawing\n    'â”€', 'â”', 'â”‚', 'â”ƒ', 'â”Œ', 'â”', 'â””', 'â”˜',\n    'â”œ', 'â”¤', 'â”¬', 'â”´', 'â”¼',\n    'â•”', 'â•—', 'â•š', 'â•', 'â•‘', 'â•',\n    'â•­', 'â•®', 'â•¯', 'â•°',\n];\n\n/// Quickly scan input to determine if it likely contains diagrams\npub fn quick_scan_for_diagrams(input: &str) -> QuickScanResult {\n    test_log!(\"INFO\", \"Starting quick scan for diagram detection\");\n\n    let start = std::time::Instant::now();\n    let mut lines_scanned = 0;\n    let mut lines_with_box_chars = 0;\n\n    for line in input.lines().take(QUICK_SCAN_LIMIT) {\n        lines_scanned += 1;\n        if line.chars().any(|c| BOX_CHARS.contains(&c)) {\n            lines_with_box_chars += 1;\n        }\n    }\n\n    let elapsed = start.elapsed();\n    let ratio = if lines_scanned > 0 {\n        lines_with_box_chars as f64 / lines_scanned as f64\n    } else {\n        0.0\n    };\n\n    let likely_has_diagrams = ratio >= QUICK_SCAN_THRESHOLD;\n\n    test_log!(\"DEBUG\", \"Quick scan: {}/{} lines have box chars ({:.1}%), threshold={:.1}%\",\n        lines_with_box_chars, lines_scanned, ratio * 100.0, QUICK_SCAN_THRESHOLD * 100.0);\n    test_log!(\"DEBUG\", \"Quick scan completed in {:?}\", elapsed);\n\n    QuickScanResult {\n        lines_scanned,\n        lines_with_box_chars,\n        ratio,\n        likely_has_diagrams,\n        scan_time: elapsed,\n    }\n}\n\n#[derive(Debug)]\npub struct QuickScanResult {\n    pub lines_scanned: usize,\n    pub lines_with_box_chars: usize,\n    pub ratio: f64,\n    pub likely_has_diagrams: bool,\n    pub scan_time: std::time::Duration,\n}\n```\n\n### Integration with Main Processing\n\n```rust\npub fn process_input(config: &Config, input: &str) -> Result<String, Error> {\n    // Skip quick scan if --all flag is set (process everything)\n    if !config.all {\n        let scan = quick_scan_for_diagrams(input);\n\n        if !scan.likely_has_diagrams {\n            test_log!(\"INFO\", \"Quick scan: no diagrams detected, passing through unchanged\");\n\n            if config.verbose {\n                eprintln!(\n                    \"Quick scan: no diagrams detected ({:.1}% box chars < {:.1}% threshold)\",\n                    scan.ratio * 100.0,\n                    QUICK_SCAN_THRESHOLD * 100.0\n                );\n                eprintln!(\"Passing through unchanged (use --all to force processing)\");\n            }\n\n            // Return input unchanged\n            return Ok(input.to_string());\n        }\n\n        test_log!(\"DEBUG\", \"Quick scan: diagrams likely present, proceeding with full processing\");\n    }\n\n    // Full processing\n    let (output, _stats) = process_with_stats(config, input);\n    Ok(output)\n}\n```\n\n### Optimized Line-by-Line Streaming (Future Enhancement)\n\n```rust\n/// For very large inputs, process line-by-line without loading entire file\npub fn process_streaming<R: BufRead, W: Write>(\n    config: &Config,\n    reader: R,\n    writer: &mut W,\n) -> Result<ProcessingStats, Error> {\n    test_log!(\"INFO\", \"Starting streaming processing\");\n\n    let mut buffer = Vec::new();\n    let mut in_potential_block = false;\n    let mut stats = ProcessingStats::new();\n\n    for line_result in reader.lines() {\n        let line = line_result?;\n        stats.total_lines += 1;\n\n        let has_box_chars = line.chars().any(|c| BOX_CHARS.contains(&c));\n\n        if has_box_chars {\n            // Accumulate potential block\n            in_potential_block = true;\n            buffer.push(line);\n        } else if in_potential_block {\n            // End of potential block - process it\n            if buffer.len() >= 2 {\n                let block_input = buffer.join(\"\\n\");\n                let (processed, block_stats) = process_with_stats(config, &block_input);\n                stats.merge(&block_stats);\n                writeln!(writer, \"{}\", processed)?;\n            } else {\n                // Too small, just output\n                for l in &buffer {\n                    writeln!(writer, \"{}\", l)?;\n                }\n            }\n            buffer.clear();\n            in_potential_block = false;\n            writeln!(writer, \"{}\", line)?;\n        } else {\n            // Plain line, output immediately\n            writeln!(writer, \"{}\", line)?;\n        }\n    }\n\n    // Flush remaining buffer\n    if !buffer.is_empty() {\n        let block_input = buffer.join(\"\\n\");\n        let (processed, block_stats) = process_with_stats(config, &block_input);\n        stats.merge(&block_stats);\n        writeln!(writer, \"{}\", processed)?;\n    }\n\n    test_log!(\"INFO\", \"Streaming processing complete: {:?}\", stats);\n    Ok(stats)\n}\n```\n\n## Edge Cases\n\n1. **Empty input**: Pass through immediately\n2. **Single line**: Quick scan still works\n3. **All box chars**: High ratio, definitely process\n4. **Unicode-only box chars**: Detect correctly\n5. **Very large input**: Use streaming mode\n6. **--all flag**: Skip quick scan entirely\n\n## Unit Tests\n\n```rust\n#[cfg(test)]\nmod passthrough_tests {\n    use super::*;\n\n    #[test]\n    fn test_quick_scan_plain_text() {\n        test_log!(\"INFO\", \"Testing quick scan on plain text\");\n\n        let input = \"Hello world\\nThis is plain text\\nNo diagrams here\";\n        let result = quick_scan_for_diagrams(input);\n\n        assert!(!result.likely_has_diagrams);\n        assert_eq!(result.lines_with_box_chars, 0);\n\n        test_log!(\"PASS\", \"Plain text detected correctly âœ“\");\n    }\n\n    #[test]\n    fn test_quick_scan_with_diagrams() {\n        test_log!(\"INFO\", \"Testing quick scan on diagram content\");\n\n        let input = r#\"\n+--------+\n| Hello  |\n+--------+\n\"#;\n        let result = quick_scan_for_diagrams(input);\n\n        assert!(result.likely_has_diagrams);\n        assert!(result.ratio > 0.5);\n\n        test_log!(\"PASS\", \"Diagram detected correctly âœ“\");\n    }\n\n    #[test]\n    fn test_quick_scan_mixed_content() {\n        test_log!(\"INFO\", \"Testing quick scan on mixed content\");\n\n        // 10% of lines have box chars\n        let mut lines = Vec::new();\n        for i in 0..100 {\n            if i % 10 == 0 {\n                lines.push(\"+---+\".to_string());\n            } else {\n                lines.push(\"Plain text line\".to_string());\n            }\n        }\n        let input = lines.join(\"\\n\");\n        let result = quick_scan_for_diagrams(&input);\n\n        // 10% > 1% threshold, should detect\n        assert!(result.likely_has_diagrams);\n\n        test_log!(\"PASS\", \"Mixed content handled correctly âœ“\");\n    }\n\n    #[test]\n    fn test_quick_scan_unicode_box_chars() {\n        test_log!(\"INFO\", \"Testing quick scan with Unicode box chars\");\n\n        let input = \"Some text\\nâ”Œâ”€â”€â”€â”€â”€â”€â”\\nâ”‚ Test â”‚\\nâ””â”€â”€â”€â”€â”€â”€â”˜\\nMore text\";\n        let result = quick_scan_for_diagrams(input);\n\n        assert!(result.likely_has_diagrams);\n\n        test_log!(\"PASS\", \"Unicode box chars detected âœ“\");\n    }\n\n    #[test]\n    fn test_passthrough_preserves_content() {\n        test_log!(\"INFO\", \"Testing passthrough preserves content exactly\");\n\n        let input = \"Line 1\\nLine 2\\nLine 3\\n\";\n        let config = Config::default();\n        let output = process_input(&config, input).unwrap();\n\n        assert_eq!(output.trim(), input.trim());\n\n        test_log!(\"PASS\", \"Content preserved exactly âœ“\");\n    }\n\n    #[test]\n    fn test_all_flag_skips_quick_scan() {\n        test_log!(\"INFO\", \"Testing --all skips quick scan\");\n\n        let input = \"Plain text only\";\n        let mut config = Config::default();\n        config.all = true;\n\n        // With --all, should attempt full processing even on plain text\n        let output = process_input(&config, input).unwrap();\n\n        // Output should still be the same (no diagrams to correct)\n        assert_eq!(output.trim(), input.trim());\n\n        test_log!(\"PASS\", \"--all skips quick scan âœ“\");\n    }\n}\n```\n\n## E2E Tests\n\n```bash\n#!/bin/bash\n# tests/e2e_passthrough.sh\n\nset -e\nsource \"$(dirname \"$0\")/e2e_runner.sh\"\n\ntest_plain_text_passthrough() {\n    log_test_start \"plain_text_passthrough\"\n\n    local tmpdir=$(mktemp -d)\n    cat > \"$tmpdir/essay.txt\" << 'EOF'\nThis is a plain text file.\nIt contains no ASCII diagrams.\nJust regular prose content.\nEOF\n\n    log_debug \"Processing plain text\"\n    local output=$(aadc \"$tmpdir/essay.txt\")\n\n    # Should be identical\n    diff -q <(cat \"$tmpdir/essay.txt\") <(echo \"$output\") && \\\n        log_pass \"Plain text passed through unchanged\" || \\\n        log_fail \"Plain text was modified\"\n}\n\ntest_passthrough_performance() {\n    log_test_start \"passthrough_performance\"\n\n    local tmpdir=$(mktemp -d)\n    # Generate large plain text file\n    for i in $(seq 1 10000); do\n        echo \"This is line number $i of plain text content\"\n    done > \"$tmpdir/large.txt\"\n\n    log_debug \"Processing large plain text file\"\n    local start=$(date +%s%N)\n    aadc \"$tmpdir/large.txt\" > /dev/null\n    local end=$(date +%s%N)\n\n    local elapsed_ms=$(( (end - start) / 1000000 ))\n    log_debug \"Elapsed: ${elapsed_ms}ms\"\n\n    # Should be very fast (< 100ms) due to quick scan\n    [[ $elapsed_ms -lt 100 ]] && \\\n        log_pass \"Passthrough was fast (${elapsed_ms}ms)\" || \\\n        log_fail \"Passthrough was slow (${elapsed_ms}ms)\"\n}\n\ntest_verbose_shows_passthrough_reason() {\n    log_test_start \"verbose_shows_passthrough_reason\"\n\n    local tmpdir=$(mktemp -d)\n    echo \"Plain text content\" > \"$tmpdir/plain.txt\"\n\n    log_debug \"Running verbose on plain text\"\n    local output=$(aadc -v \"$tmpdir/plain.txt\" 2>&1)\n\n    echo \"$output\" | grep -qi \"no diagrams detected\\|passing through\" && \\\n        log_pass \"Passthrough reason shown\" || \\\n        log_fail \"Passthrough reason not shown\"\n}\n\nrun_tests test_plain_text_passthrough test_passthrough_performance test_verbose_shows_passthrough_reason\n```\n\n## Documentation Updates\n\nREADME.md section:\n```markdown\n### Performance: Quick Passthrough\n\nFor pipeline efficiency, aadc performs a quick scan before full processing:\n\n- If less than 1% of lines contain box-drawing characters, the input passes through unchanged\n- This makes piping large text files through aadc essentially free\n- Use `--all` to force processing regardless of content\n\n```bash\n# Fast: essays, code, logs pass through instantly\ncat large_logfile.txt | aadc    # Quick scan, no processing needed\n\n# Verbose shows the decision\ncat file.txt | aadc -v          # \"Quick scan: no diagrams detected\"\n\n# Force processing\ncat ambiguous.txt | aadc --all  # Skip quick scan\n```\n```\n\n## Success Criteria\n\n- [ ] Quick scan runs before full processing\n- [ ] Plain text passes through unchanged\n- [ ] Quick scan completes in < 1ms for typical inputs\n- [ ] --all flag bypasses quick scan\n- [ ] Verbose mode explains passthrough decision\n- [ ] Unicode box chars detected in scan\n- [ ] Threshold configurable (future: via config file)\n- [ ] Unit tests pass\n- [ ] E2E tests validate passthrough behavior","status":"closed","priority":3,"issue_type":"feature","created_at":"2026-01-21T02:01:18.882041302Z","created_by":"ubuntu","updated_at":"2026-01-21T17:06:36.767391578Z","closed_at":"2026-01-21T17:06:36.767316957Z","close_reason":"Implemented quick scan passthrough, tests, README update","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1zp","depends_on_id":"bd-1ih","type":"blocks","created_at":"2026-01-21T02:01:37.790958893Z","created_by":"ubuntu"},{"issue_id":"bd-1zp","depends_on_id":"bd-2kr","type":"blocks","created_at":"2026-01-21T05:07:47.548019602Z","created_by":"ubuntu"}]}
{"id":"bd-21x","title":"Unit tests: Line analysis (classify_line, visual_width, analyze_line, detect_suffix_border)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-21T01:45:54.133655141Z","created_by":"ubuntu","updated_at":"2026-01-21T03:06:53.218238881Z","closed_at":"2026-01-21T03:06:53.218090992Z","compaction_level":0,"original_size":0}
{"id":"bd-25l","title":"Unit tests: Revision system (Revision::score, Revision::apply for all variants)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-21T01:45:44.865876446Z","created_by":"ubuntu","updated_at":"2026-01-21T03:05:03.414029668Z","closed_at":"2026-01-21T03:05:03.413945850Z","compaction_level":0,"original_size":0}
{"id":"bd-26l","title":"Add confidence threshold presets","description":"# Confidence Threshold Presets\n\n## CLI Interface\n\n```rust\nuse clap::ValueEnum;\n\n#[derive(Debug, Clone, Copy, ValueEnum)]\npub enum Preset {\n    /// Conservative: only high-confidence edits (0.8)\n    Strict,\n    /// Balanced: reasonable confidence threshold (0.5) [default]\n    Normal,\n    /// Aggressive: accept lower-confidence edits (0.3)\n    Aggressive,\n    /// Accept almost any edit (0.1)\n    Relaxed,\n}\n\n#[derive(Parser, Debug)]\npub struct Config {\n    /// Confidence threshold preset\n    #[arg(long, short = 'P', value_enum, conflicts_with = \"min_score\")]\n    pub preset: Option<Preset>,\n\n    /// Minimum confidence score (0.0-1.0) for applying edits\n    #[arg(long, short = 's', default_value = \"0.5\")]\n    pub min_score: f64,\n}\n```\n\n**Usage:**\n```bash\naadc --preset strict diagram.txt      # Only high-confidence edits\naadc --preset normal diagram.txt      # Default behavior\naadc --preset aggressive diagram.txt  # More permissive\naadc --preset relaxed diagram.txt     # Accept almost anything\naadc -P strict diagram.txt            # Short form\n```\n\n## Implementation\n\n### Preset Resolution\n\n```rust\nimpl Config {\n    pub fn effective_min_score(&self) -> f64 {\n        test_log!(\"DEBUG\", \"Resolving effective min_score\");\n\n        if let Some(preset) = self.preset {\n            let score = match preset {\n                Preset::Strict => 0.8,\n                Preset::Normal => 0.5,\n                Preset::Aggressive => 0.3,\n                Preset::Relaxed => 0.1,\n            };\n            test_log!(\"DEBUG\", \"Using preset {:?} -> min_score={}\", preset, score);\n            score\n        } else {\n            test_log!(\"DEBUG\", \"Using explicit min_score={}\", self.min_score);\n            self.min_score\n        }\n    }\n}\n```\n\n### Preset Descriptions for Help Text\n\n```rust\nimpl Preset {\n    pub fn description(&self) -> &'static str {\n        match self {\n            Preset::Strict => \"Only apply edits when very confident (score >= 0.8). \\\n                              Best for production docs where mistakes are costly.\",\n            Preset::Normal => \"Balanced threshold (score >= 0.5). \\\n                              Good for most use cases.\",\n            Preset::Aggressive => \"Accept lower-confidence edits (score >= 0.3). \\\n                                   Useful when diagrams have unusual patterns.\",\n            Preset::Relaxed => \"Accept almost any edit (score >= 0.1). \\\n                               Use with --diff to review changes.\",\n        }\n    }\n}\n```\n\n### Verbose Output Integration\n\n```rust\npub fn print_preset_info(config: &Config, colors: &VerboseColors) {\n    if let Some(preset) = config.preset {\n        eprintln!(\n            \"{}Using preset: {:?}{} (min_score = {})\",\n            colors.header.render_str(\"\"),\n            preset,\n            Style::reset(),\n            config.effective_min_score()\n        );\n    }\n}\n```\n\n## Edge Cases\n\n1. **--preset and --min-score together**: clap enforces mutual exclusion\n2. **Config file preset**: Can be overridden by CLI flag\n3. **Invalid preset name**: clap provides helpful error with valid options\n4. **Case sensitivity**: ValueEnum handles case-insensitively\n\n## Unit Tests\n\n```rust\n#[cfg(test)]\nmod preset_tests {\n    use super::*;\n\n    #[test]\n    fn test_preset_scores() {\n        test_log!(\"INFO\", \"Testing preset score mappings\");\n\n        let strict = Config { preset: Some(Preset::Strict), min_score: 0.5 };\n        assert_eq!(strict.effective_min_score(), 0.8);\n\n        let normal = Config { preset: Some(Preset::Normal), min_score: 0.5 };\n        assert_eq!(normal.effective_min_score(), 0.5);\n\n        let aggressive = Config { preset: Some(Preset::Aggressive), min_score: 0.5 };\n        assert_eq!(aggressive.effective_min_score(), 0.3);\n\n        let relaxed = Config { preset: Some(Preset::Relaxed), min_score: 0.5 };\n        assert_eq!(relaxed.effective_min_score(), 0.1);\n\n        test_log!(\"PASS\", \"All preset scores correct âœ“\");\n    }\n\n    #[test]\n    fn test_explicit_score_used_when_no_preset() {\n        test_log!(\"INFO\", \"Testing explicit min_score without preset\");\n\n        let config = Config { preset: None, min_score: 0.42 };\n        assert_eq!(config.effective_min_score(), 0.42);\n\n        test_log!(\"PASS\", \"Explicit score used correctly âœ“\");\n    }\n\n    #[test]\n    fn test_preset_conflicts_with_min_score() {\n        test_log!(\"INFO\", \"Testing --preset conflicts with --min-score\");\n\n        let args = [\"aadc\", \"--preset\", \"strict\", \"--min-score\", \"0.3\", \"file.txt\"];\n        let result = Config::try_parse_from(&args);\n\n        assert!(result.is_err());\n        test_log!(\"PASS\", \"Conflict detected as expected âœ“\");\n    }\n\n    #[test]\n    fn test_preset_case_insensitive() {\n        test_log!(\"INFO\", \"Testing preset case insensitivity\");\n\n        let args1 = [\"aadc\", \"--preset\", \"STRICT\", \"file.txt\"];\n        let config1 = Config::try_parse_from(&args1).unwrap();\n        assert!(matches!(config1.preset, Some(Preset::Strict)));\n\n        let args2 = [\"aadc\", \"--preset\", \"Aggressive\", \"file.txt\"];\n        let config2 = Config::try_parse_from(&args2).unwrap();\n        assert!(matches!(config2.preset, Some(Preset::Aggressive)));\n\n        test_log!(\"PASS\", \"Case insensitivity works âœ“\");\n    }\n}\n```\n\n## E2E Tests\n\n```bash\n#!/bin/bash\n# tests/e2e_presets.sh\n\nset -e\nsource \"$(dirname \"$0\")/e2e_runner.sh\"\n\ntest_strict_preset_skips_low_confidence() {\n    log_test_start \"strict_preset_skips_low_confidence\"\n\n    local tmpdir=$(mktemp -d)\n    # Create a diagram that might have ambiguous corrections\n    cat > \"$tmpdir/ambiguous.txt\" << 'EOF'\n+------+\n| Hi |\n+------+\nEOF\n\n    log_debug \"Running with --preset strict\"\n    local output=$(aadc -v --preset strict \"$tmpdir/ambiguous.txt\" 2>&1)\n\n    log_debug \"Output: $output\"\n    # Strict mode should be more conservative\n    echo \"$output\" | grep -q \"preset: Strict\" && \\\n        log_pass \"Strict preset applied\" || \\\n        log_fail \"Strict preset not recognized\"\n}\n\ntest_aggressive_preset_applies_more() {\n    log_test_start \"aggressive_preset_applies_more\"\n\n    local tmpdir=$(mktemp -d)\n    cat > \"$tmpdir/diagram.txt\" << 'EOF'\n+----------+\n| Content|\n+----------+\nEOF\n\n    log_debug \"Comparing strict vs aggressive\"\n    local strict_out=$(aadc --preset strict \"$tmpdir/diagram.txt\")\n    local aggressive_out=$(aadc --preset aggressive \"$tmpdir/diagram.txt\")\n\n    # Both should produce valid output\n    [[ -n \"$strict_out\" && -n \"$aggressive_out\" ]] && \\\n        log_pass \"Both presets produce output\" || \\\n        log_fail \"Preset output missing\"\n}\n\nrun_tests test_strict_preset_skips_low_confidence test_aggressive_preset_applies_more\n```\n\n## Documentation Updates\n\nREADME.md section:\n```markdown\n### Confidence Presets\n\nInstead of remembering numeric thresholds, use named presets:\n\n| Preset | Score | Use Case |\n|--------|-------|----------|\n| `strict` | 0.8 | Production docs, minimize false positives |\n| `normal` | 0.5 | General use (default) |\n| `aggressive` | 0.3 | Unusual diagram styles |\n| `relaxed` | 0.1 | Review everything with --diff |\n\n```bash\n# Conservative mode for important docs\naadc --preset strict README.md\n\n# Aggressive for tricky diagrams\naadc --preset aggressive --diff diagram.txt\n```\n\nPresets can also be set in `.aadcrc` config files.\n```\n\n## Success Criteria\n\n- [ ] Four presets available: strict, normal, aggressive, relaxed\n- [ ] Presets map to correct numeric scores\n- [ ] --preset conflicts with --min-score (mutually exclusive)\n- [ ] Case-insensitive preset names\n- [ ] Verbose mode shows active preset\n- [ ] Presets work with config file\n- [ ] Unit tests pass\n- [ ] E2E tests validate preset behavior","status":"closed","priority":3,"issue_type":"feature","created_at":"2026-01-21T02:01:16.804597381Z","created_by":"ubuntu","updated_at":"2026-01-21T18:49:22.524209180Z","closed_at":"2026-01-21T18:49:22.524146161Z","close_reason":"Fully implemented: Preset enum (strict/normal/aggressive/relaxed) with -P/--preset flag, effective_min_score() method, conflicts_with min_score, verbose mode shows active preset. All 6 preset-related tests pass.","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-26l","depends_on_id":"bd-1ih","type":"blocks","created_at":"2026-01-21T02:01:37.503223409Z","created_by":"ubuntu"},{"issue_id":"bd-26l","depends_on_id":"bd-32l","type":"blocks","created_at":"2026-01-21T05:07:45.762760324Z","created_by":"ubuntu"}]}
{"id":"bd-2am","title":"Add recursive directory mode","description":"# Recursive Directory Mode\n\n## CLI Interface\n\n```rust\n#[derive(Parser, Debug)]\npub struct Config {\n    /// Process files recursively in directories\n    #[arg(long, short = 'r')]\n    pub recursive: bool,\n\n    /// Glob pattern to match files (used with -r)\n    #[arg(long, default_value = \"*.txt,*.md\")]\n    pub glob: String,\n\n    /// Respect .gitignore when recursing\n    #[arg(long, default_value = \"true\")]\n    pub gitignore: bool,\n\n    /// Maximum directory depth (0 = unlimited)\n    #[arg(long, default_value = \"0\")]\n    pub max_depth: usize,\n\n    /// Input files or directories\n    #[arg(required = true)]\n    pub paths: Vec<PathBuf>,\n}\n```\n\n**Usage:**\n```bash\naadc -r docs/                        # All .txt and .md files\naadc -r --glob \"*.md\" docs/          # Only markdown files\naadc -r --glob \"*.txt,*.md,*.rst\" .  # Multiple patterns\naadc -r --max-depth 2 docs/          # Limit depth\naadc -r --no-gitignore docs/         # Include ignored files\naadc -ri docs/                       # Recursive in-place edit\n```\n\n## Implementation\n\n### Dependencies\nAdd to Cargo.toml:\n```toml\n[dependencies]\nignore = \"0.4\"  # Provides gitignore support and parallel walking\nglobset = \"0.4\"\n```\n\n### File Discovery\n\n```rust\nuse ignore::WalkBuilder;\nuse globset::{Glob, GlobSetBuilder};\n\npub fn discover_files(config: &Config) -> Result<Vec<PathBuf>, Error> {\n    test_log!(\"INFO\", \"Discovering files with patterns: {}\", config.glob);\n\n    // Build glob matcher\n    let mut glob_builder = GlobSetBuilder::new();\n    for pattern in config.glob.split(',') {\n        let pattern = pattern.trim();\n        test_log!(\"DEBUG\", \"Adding glob pattern: {}\", pattern);\n        glob_builder.add(Glob::new(pattern)?);\n    }\n    let globs = glob_builder.build()?;\n\n    let mut files = Vec::new();\n\n    for path in &config.paths {\n        test_log!(\"DEBUG\", \"Processing path: {:?}\", path);\n\n        if path.is_file() {\n            // Direct file argument\n            files.push(path.clone());\n            continue;\n        }\n\n        if !path.is_dir() {\n            test_log!(\"WARN\", \"Path does not exist: {:?}\", path);\n            continue;\n        }\n\n        // Build walker for directory\n        let mut walker = WalkBuilder::new(path);\n        walker.git_ignore(config.gitignore);\n        walker.hidden(false);  // Don't skip hidden files by default\n\n        if config.max_depth > 0 {\n            walker.max_depth(Some(config.max_depth));\n        }\n\n        for entry in walker.build() {\n            let entry = entry?;\n            let entry_path = entry.path();\n\n            if entry_path.is_file() {\n                // Check if filename matches any glob\n                if let Some(name) = entry_path.file_name() {\n                    if globs.is_match(name) {\n                        test_log!(\"DEBUG\", \"Matched: {:?}\", entry_path);\n                        files.push(entry_path.to_path_buf());\n                    }\n                }\n            }\n        }\n    }\n\n    test_log!(\"INFO\", \"Discovered {} files\", files.len());\n    Ok(files)\n}\n```\n\n### Processing Loop with Progress\n\n```rust\npub fn process_recursive(config: &Config) -> Result<RecursiveStats, Error> {\n    let files = discover_files(config)?;\n\n    if files.is_empty() {\n        test_log!(\"WARN\", \"No files matched the glob pattern\");\n        eprintln!(\"Warning: No files matched pattern '{}' in specified paths\", config.glob);\n        return Ok(RecursiveStats::default());\n    }\n\n    let mut stats = RecursiveStats {\n        files_processed: 0,\n        files_modified: 0,\n        files_skipped: 0,\n        total_revisions: 0,\n        errors: Vec::new(),\n    };\n\n    for (i, file) in files.iter().enumerate() {\n        test_log!(\"INFO\", \"Processing file {}/{}: {:?}\", i + 1, files.len(), file);\n\n        if config.verbose {\n            eprintln!(\"[{}/{}] Processing: {}\", i + 1, files.len(), file.display());\n        }\n\n        match process_file(config, file) {\n            Ok(file_stats) => {\n                stats.files_processed += 1;\n                stats.total_revisions += file_stats.revisions_applied;\n                if file_stats.revisions_applied > 0 {\n                    stats.files_modified += 1;\n                }\n            }\n            Err(e) => {\n                test_log!(\"ERROR\", \"Failed to process {:?}: {}\", file, e);\n                stats.errors.push((file.clone(), e.to_string()));\n                stats.files_skipped += 1;\n            }\n        }\n    }\n\n    test_log!(\"INFO\", \"Recursive processing complete: {:?}\", stats);\n    Ok(stats)\n}\n\n#[derive(Debug, Default)]\npub struct RecursiveStats {\n    pub files_processed: usize,\n    pub files_modified: usize,\n    pub files_skipped: usize,\n    pub total_revisions: usize,\n    pub errors: Vec<(PathBuf, String)>,\n}\n```\n\n## Edge Cases\n\n1. **No matching files**: Warn but don't error\n2. **Permission denied**: Log error, continue with other files\n3. **Symlink loops**: ignore crate handles this automatically\n4. **Mixed files and directories**: Process both correctly\n5. **Binary files**: Skip files that can't be read as UTF-8\n6. **Empty directories**: Handle gracefully\n\n## Unit Tests\n\n```rust\n#[cfg(test)]\nmod recursive_tests {\n    use super::*;\n    use tempfile::TempDir;\n    use std::fs;\n\n    #[test]\n    fn test_glob_pattern_parsing() {\n        test_log!(\"INFO\", \"Testing glob pattern parsing\");\n\n        let patterns = \"*.txt,*.md, *.rst\";  // Note extra space\n        let parts: Vec<_> = patterns.split(',').map(|s| s.trim()).collect();\n\n        assert_eq!(parts, vec![\"*.txt\", \"*.md\", \"*.rst\"]);\n        test_log!(\"PASS\", \"Glob parsing works âœ“\");\n    }\n\n    #[test]\n    fn test_file_discovery() {\n        test_log!(\"INFO\", \"Testing file discovery\");\n\n        let tmpdir = TempDir::new().unwrap();\n        fs::write(tmpdir.path().join(\"a.txt\"), \"content\").unwrap();\n        fs::write(tmpdir.path().join(\"b.md\"), \"content\").unwrap();\n        fs::write(tmpdir.path().join(\"c.rs\"), \"content\").unwrap();\n\n        let config = Config {\n            recursive: true,\n            glob: \"*.txt,*.md\".to_string(),\n            gitignore: false,\n            max_depth: 0,\n            paths: vec![tmpdir.path().to_path_buf()],\n            ..Default::default()\n        };\n\n        let files = discover_files(&config).unwrap();\n        assert_eq!(files.len(), 2);  // a.txt and b.md, not c.rs\n\n        test_log!(\"PASS\", \"File discovery works âœ“\");\n    }\n\n    #[test]\n    fn test_max_depth_limit() {\n        test_log!(\"INFO\", \"Testing max depth limit\");\n\n        let tmpdir = TempDir::new().unwrap();\n        let deep = tmpdir.path().join(\"a\").join(\"b\").join(\"c\");\n        fs::create_dir_all(&deep).unwrap();\n        fs::write(tmpdir.path().join(\"top.txt\"), \"\").unwrap();\n        fs::write(tmpdir.path().join(\"a/mid.txt\"), \"\").unwrap();\n        fs::write(deep.join(\"deep.txt\"), \"\").unwrap();\n\n        let config = Config {\n            recursive: true,\n            glob: \"*.txt\".to_string(),\n            gitignore: false,\n            max_depth: 2,\n            paths: vec![tmpdir.path().to_path_buf()],\n            ..Default::default()\n        };\n\n        let files = discover_files(&config).unwrap();\n        // Should find top.txt and a/mid.txt but not a/b/c/deep.txt\n        assert!(files.len() <= 2);\n        test_log!(\"PASS\", \"Max depth works âœ“\");\n    }\n\n    #[test]\n    fn test_gitignore_respected() {\n        test_log!(\"INFO\", \"Testing .gitignore respect\");\n\n        let tmpdir = TempDir::new().unwrap();\n        fs::write(tmpdir.path().join(\".gitignore\"), \"ignored.txt\\n\").unwrap();\n        fs::write(tmpdir.path().join(\"included.txt\"), \"\").unwrap();\n        fs::write(tmpdir.path().join(\"ignored.txt\"), \"\").unwrap();\n\n        let config = Config {\n            recursive: true,\n            glob: \"*.txt\".to_string(),\n            gitignore: true,\n            max_depth: 0,\n            paths: vec![tmpdir.path().to_path_buf()],\n            ..Default::default()\n        };\n\n        let files = discover_files(&config).unwrap();\n        let names: Vec<_> = files.iter().filter_map(|p| p.file_name()).collect();\n\n        assert!(!names.iter().any(|n| n == \"ignored.txt\"));\n        test_log!(\"PASS\", \"Gitignore respected âœ“\");\n    }\n}\n```\n\n## E2E Tests\n\n```bash\n#!/bin/bash\n# tests/e2e_recursive.sh\n\nset -e\nsource \"$(dirname \"$0\")/e2e_runner.sh\"\n\ntest_recursive_basic() {\n    log_test_start \"recursive_basic\"\n\n    local tmpdir=$(mktemp -d)\n    mkdir -p \"$tmpdir/docs\"\n\n    # Create test files\n    create_misaligned_diagram \"$tmpdir/a.md\"\n    create_misaligned_diagram \"$tmpdir/docs/b.md\"\n    create_misaligned_diagram \"$tmpdir/docs/c.txt\"\n\n    log_debug \"Running recursive mode\"\n    aadc -r --glob \"*.md\" \"$tmpdir\" > /dev/null\n\n    log_debug \"Checking files were processed\"\n    # Verify diagrams are now aligned\n    grep -q \"| Content |\" \"$tmpdir/a.md\" && \\\n        log_pass \"Root file processed\" || \\\n        log_fail \"Root file not processed\"\n\n    grep -q \"| Content |\" \"$tmpdir/docs/b.md\" && \\\n        log_pass \"Nested file processed\" || \\\n        log_fail \"Nested file not processed\"\n}\n\ntest_recursive_in_place() {\n    log_test_start \"recursive_in_place\"\n\n    local tmpdir=$(mktemp -d)\n    create_misaligned_diagram \"$tmpdir/test.md\"\n\n    log_debug \"Running recursive in-place\"\n    aadc -ri --glob \"*.md\" \"$tmpdir\"\n\n    # File should be modified\n    grep -q \"| Content |\" \"$tmpdir/test.md\" && \\\n        log_pass \"In-place edit worked\" || \\\n        log_fail \"In-place edit failed\"\n}\n\ntest_recursive_respects_gitignore() {\n    log_test_start \"recursive_respects_gitignore\"\n\n    local tmpdir=$(mktemp -d)\n    echo \"ignored/\" > \"$tmpdir/.gitignore\"\n    mkdir -p \"$tmpdir/ignored\"\n\n    create_misaligned_diagram \"$tmpdir/included.md\"\n    create_misaligned_diagram \"$tmpdir/ignored/excluded.md\"\n\n    log_debug \"Running with gitignore\"\n    local output=$(aadc -rv --glob \"*.md\" \"$tmpdir\" 2>&1)\n\n    echo \"$output\" | grep -q \"included.md\" && \\\n        log_pass \"Included file found\" || \\\n        log_fail \"Included file missing\"\n\n    if echo \"$output\" | grep -q \"excluded.md\"; then\n        log_fail \"Ignored file was processed\"\n    else\n        log_pass \"Ignored file skipped\"\n    fi\n}\n\nrun_tests test_recursive_basic test_recursive_in_place test_recursive_respects_gitignore\n```\n\n## Documentation Updates\n\nREADME.md section:\n```markdown\n### Recursive Mode\n\nProcess entire directory trees:\n\n```bash\n# All .txt and .md files (default patterns)\naadc -r docs/\n\n# Custom glob patterns\naadc -r --glob \"*.md\" docs/\naadc -r --glob \"*.txt,*.md,*.rst\" .\n\n# In-place recursive edit\naadc -ri docs/\n\n# Limit depth\naadc -r --max-depth 2 docs/\n\n# Include gitignored files\naadc -r --no-gitignore vendor/\n```\n\nBy default, recursive mode:\n- Matches `*.txt` and `*.md` files\n- Respects `.gitignore` rules\n- Has no depth limit\n```\n\n## Success Criteria\n\n- [ ] -r/--recursive flag enables directory traversal\n- [ ] --glob accepts comma-separated patterns\n- [ ] .gitignore respected by default (--no-gitignore to override)\n- [ ] --max-depth limits recursion depth\n- [ ] Mixed file/directory arguments work\n- [ ] Errors don't stop processing other files\n- [ ] Progress shown in verbose mode\n- [ ] Works with -i for in-place editing\n- [ ] Unit tests pass\n- [ ] E2E tests validate recursive behavior","status":"closed","priority":3,"issue_type":"feature","created_at":"2026-01-21T02:01:02.135334537Z","created_by":"ubuntu","updated_at":"2026-01-21T17:52:14.808057896Z","closed_at":"2026-01-21T17:52:14.807433642Z","close_reason":"Implemented recursive mode, tests, README","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2am","depends_on_id":"bd-1ih","type":"blocks","created_at":"2026-01-21T02:01:37.226310096Z","created_by":"ubuntu"},{"issue_id":"bd-2am","depends_on_id":"bd-5jn","type":"blocks","created_at":"2026-01-21T02:01:43.808497257Z","created_by":"ubuntu"}]}
{"id":"bd-2ig","title":"Unit tests: Block detection (find_diagram_blocks, confidence scoring, boundary detection)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-21T01:45:55.018920456Z","created_by":"ubuntu","updated_at":"2026-01-21T03:12:25.651184627Z","closed_at":"2026-01-21T03:12:25.651105307Z","compaction_level":0,"original_size":0}
{"id":"bd-2jm","title":"TESTING: Unit Test Coverage Strategy","description":"# TESTING: Unit Test Coverage Strategy\n\n## Purpose\n\nDefine comprehensive unit test coverage for all core functions. Unit tests validate individual components in isolation, complementing E2E fixture tests.\n\n## Test Module Organization\n\n```rust\n// src/main.rs (at bottom)\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    // Character detection tests\n    mod char_detection { ... }\n    \n    // Line analysis tests\n    mod line_analysis { ... }\n    \n    // Block detection tests\n    mod block_detection { ... }\n    \n    // Revision tests\n    mod revision { ... }\n    \n    // Integration tests\n    mod integration { ... }\n}\n```\n\n## Coverage by Component\n\n### 1. Character Detection (is_* functions)\n\n| Function | Test Cases | Coverage |\n|----------|------------|----------|\n| is_corner | All 13 corners + 10 non-corners | 100% |\n| is_horizontal_fill | All 12 fills + 10 non-fills | 100% |\n| is_vertical_border | All 10 borders + 10 non-borders | 100% |\n| is_junction | All 16 junctions + 10 non-junctions | 100% |\n| is_box_char | Composite of above | Derived |\n| is_border_char | Vertical + corners + junctions | Derived |\n\n```rust\n#[test]\nfn test_is_corner_ascii() {\n    assert!(is_corner('+'));\n}\n\n#[test]\nfn test_is_corner_unicode_light() {\n    assert!(is_corner('â”Œ'));\n    assert!(is_corner('â”'));\n    assert!(is_corner('â””'));\n    assert!(is_corner('â”˜'));\n}\n\n#[test]\nfn test_is_corner_negative() {\n    assert!(!is_corner('-'));\n    assert!(!is_corner('|'));\n    assert!(!is_corner('a'));\n}\n```\n\n### 2. Visual Width\n\n| Test Case | Input | Expected |\n|-----------|-------|----------|\n| ASCII | \"hello\" | 5 |\n| Unicode box | \"â”‚abcâ”‚\" | 5 |\n| CJK | \"ä½ å¥½\" | 4 |\n| Mixed | \"aä½ b\" | 4 |\n| Empty | \"\" | 0 |\n\n```rust\n#[test]\nfn test_visual_width_cjk() {\n    assert_eq!(visual_width(\"ä½ å¥½\"), 4);\n    assert_eq!(visual_width(\"aä½ bå¥½c\"), 7);\n}\n```\n\n### 3. Line Classification\n\n| LineKind | Example | Why |\n|----------|---------|-----|\n| Blank | \"\" | Empty |\n| Blank | \"   \" | Whitespace only |\n| None | \"hello\" | No box chars |\n| Weak | \"hello \\| world\" | Single pipe |\n| Strong | \"+---+\" | Has corners |\n| Strong | \"\\| x \\|\" | Both borders |\n| Strong | \"â”€â”€â”€â”€\" | High box ratio |\n\n```rust\n#[test]\nfn test_classify_line_strong_corners() {\n    assert_eq!(classify_line(\"+---+\"), LineKind::Strong);\n    assert_eq!(classify_line(\"â”Œâ”€â”€â”€â”\"), LineKind::Strong);\n}\n\n#[test]\nfn test_classify_line_strong_both_borders() {\n    assert_eq!(classify_line(\"| text |\"), LineKind::Strong);\n}\n\n#[test]\nfn test_classify_line_weak() {\n    assert_eq!(classify_line(\"text | more\"), LineKind::Weak);\n}\n```\n\n### 4. Suffix Border Detection\n\n| Input | Expected |\n|-------|----------|\n| \"\\| text \\|\" | Some(SuffixBorder { column: 7, char: '\\|', is_closing: false }) |\n| \"+----+\" | Some(SuffixBorder { column: 5, char: '+', is_closing: true }) |\n| \"no border\" | None |\n| \"\\| text\" | None (no trailing border) |\n\n```rust\n#[test]\nfn test_detect_suffix_border_simple() {\n    let border = detect_suffix_border(\"| text |\").unwrap();\n    assert_eq!(border.char, '|');\n    assert!(!border.is_closing);\n}\n```\n\n### 5. Block Detection\n\n| Input | Expected Blocks |\n|-------|-----------------|\n| Single box | 1 block |\n| Two boxes separated | 2 blocks |\n| No boxes | 0 blocks |\n| Box with blank line inside | 1 block (blank tolerated) |\n\n```rust\n#[test]\nfn test_find_diagram_blocks_simple() {\n    let lines = vec![\"+--+\", \"| |\", \"+--+\"];\n    let blocks = find_diagram_blocks(&lines, false);\n    assert_eq!(blocks.len(), 1);\n    assert_eq!(blocks[0].start, 0);\n    assert_eq!(blocks[0].end, 3);\n}\n```\n\n### 6. Revision Scoring\n\n| Revision Type | Spaces | LineKind | Expected Score |\n|---------------|--------|----------|----------------|\n| Pad | 1 | Strong | 0.9 |\n| Pad | 5 | Strong | 0.5 |\n| Pad | 1 | Weak | 0.7 |\n| Add | - | Strong | 0.7 |\n| Add | - | Weak | 0.6 |\n\n```rust\n#[test]\nfn test_score_pad_small_strong() {\n    assert!((score_pad_revision(1, &LineKind::Strong) - 0.9).abs() < 0.01);\n}\n```\n\n### 7. Tab Expansion\n\n| Input | tab_width | Expected |\n|-------|-----------|----------|\n| \"\\\\thi\" | 4 | \"    hi\" |\n| \"a\\\\tb\" | 4 | \"a   b\" |\n| \"ab\\\\tc\" | 4 | \"ab  c\" |\n| \"\\\\t\\\\t\" | 4 | \"        \" |\n\n### 8. Integration Tests\n\nFull pipeline tests:\n\n```rust\n#[test]\nfn test_correction_simple() {\n    let input = vec![\n        \"+--------+\".to_string(),\n        \"| short|\".to_string(),\n        \"| longer  |\".to_string(),\n        \"+--------+\".to_string(),\n    ];\n    let config = Config::default();\n    let console = Console::builder().markup(false).build();\n    let (output, stats) = correct_lines(&input, &config, &console);\n    \n    assert!(stats.total_revisions > 0);\n    // All borders should align now\n}\n```\n\n## Running Tests\n\n```bash\n# All tests\ncargo test\n\n# With output\ncargo test -- --nocapture\n\n# Specific test\ncargo test test_is_corner\n\n# Specific module\ncargo test char_detection\n\n# With coverage (requires grcov)\ncargo +nightly test --coverage\ngrcov . -s . --binary-path ./target/debug/ -t html --branch -o ./coverage/\n```\n\n## Coverage Goals\n\n| Component | Target | Rationale |\n|-----------|--------|-----------|\n| Character detection | 100% | Small, critical |\n| Line classification | 95%+ | Core logic |\n| Block detection | 90%+ | Complex, important |\n| Revision system | 90%+ | Core logic |\n| Tab expansion | 100% | Simple, critical |\n| CLI parsing | 80%+ | clap handles most |\n\n## Test Quality Guidelines\n\n1. **Test one thing per test**: Clear failure messages\n2. **Use descriptive names**: `test_classify_line_strong_when_has_corners`\n3. **Cover edge cases**: Empty, single char, Unicode\n4. **Test both positive and negative**: is_corner('+') and !is_corner('-')\n5. **Avoid testing implementation details**: Test behavior, not code structure\n\n## Dependencies\n\n- Runs via: cargo test\n- CI integration: .github/workflows/ci.yml\n- Related: E2E Fixture Tests","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-21T05:05:34.499361837Z","created_by":"ubuntu","updated_at":"2026-01-21T08:36:25.515934178Z","closed_at":"2026-01-21T08:36:25.515883923Z","close_reason":"done","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2jm","depends_on_id":"bd-apa","type":"blocks","created_at":"2026-01-21T05:07:30.180302098Z","created_by":"ubuntu"}]}
{"id":"bd-2kr","title":"CORE: Diagram Block Detection Algorithm","description":"# CORE: Diagram Block Detection Algorithm\n\n## Purpose\n\nIdentify contiguous regions of text that constitute ASCII diagrams. This is the critical first step - if we can't find the diagrams, we can't fix them.\n\n## DiagramBlock Structure\n\n```rust\nstruct DiagramBlock {\n    start: usize,    // Starting line index (inclusive)\n    end: usize,      // Ending line index (exclusive)\n    confidence: f64, // Quality score 0.0-1.0\n}\n```\n\n**Location**: src/main.rs lines ~308-316\n\n## Algorithm Overview\n\n```rust\nfn find_diagram_blocks(lines: &[&str], all_blocks: bool) -> Vec<DiagramBlock>\n```\n\n**Location**: src/main.rs lines ~319-401\n\n### State Machine\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚                    SCANNING FOR START                           â”‚\nâ”‚  Looking for first Weak or Strong line                          â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n                           â”‚ Found Weak/Strong\n                           â–¼\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚                    EXTENDING BLOCK                              â”‚\nâ”‚  Continue while:                                                â”‚\nâ”‚  - Strong line: extend, reset gap                               â”‚\nâ”‚  - Weak line: extend, reset gap                                 â”‚\nâ”‚  - Blank line: allow 1, break on 2+                             â”‚\nâ”‚  - None line: lookahead 3, extend if boxy found & gap=0        â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n                           â”‚ Block ended\n                           â–¼\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚                    FINALIZE BLOCK                               â”‚\nâ”‚  1. Trim trailing blanks                                        â”‚\nâ”‚  2. Calculate confidence score                                  â”‚\nâ”‚  3. Filter by threshold (0.3 or all_blocks)                     â”‚\nâ”‚  4. Return to SCANNING                                          â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n## Detailed Algorithm\n\n```rust\nlet mut blocks = Vec::new();\nlet mut i = 0;\n\nwhile i < lines.len() {\n    let kind = classify_line(lines[i]);\n    \n    // Skip non-boxy lines\n    if matches!(kind, LineKind::None | LineKind::Blank) {\n        i += 1;\n        continue;\n    }\n    \n    // Found start of potential block\n    let start = i;\n    let mut end = i + 1;\n    let mut strong_count = if kind == LineKind::Strong { 1 } else { 0 };\n    let mut boxy_count = 1;\n    let mut blank_gap = 0;\n    \n    // Extend block\n    while end < lines.len() {\n        let next_kind = classify_line(lines[end]);\n        \n        match next_kind {\n            LineKind::Strong => {\n                strong_count += 1;\n                boxy_count += 1;\n                blank_gap = 0;\n                end += 1;\n            }\n            LineKind::Weak => {\n                boxy_count += 1;\n                blank_gap = 0;\n                end += 1;\n            }\n            LineKind::Blank => {\n                blank_gap += 1;\n                if blank_gap > 1 { break; }\n                end += 1;\n            }\n            LineKind::None => {\n                // Lookahead heuristic: check next 3 lines\n                let lookahead_boxy = (end+1..min(end+4, lines.len()))\n                    .any(|j| matches!(classify_line(lines[j]), \n                         LineKind::Strong | LineKind::Weak));\n                \n                if lookahead_boxy && blank_gap == 0 {\n                    end += 1;  // Bridge the gap\n                } else {\n                    break;\n                }\n            }\n        }\n    }\n    \n    // Trim trailing blanks\n    while end > start && classify_line(lines[end-1]) == LineKind::Blank {\n        end -= 1;\n    }\n    \n    // Calculate confidence\n    let strong_ratio = strong_count as f64 / boxy_count.max(1) as f64;\n    let size_bonus = ((end - start) as f64 / 10.0).min(0.2);\n    let confidence = (strong_ratio * 0.8 + size_bonus).min(1.0);\n    \n    // Filter by threshold\n    if all_blocks || confidence >= 0.3 {\n        blocks.push(DiagramBlock { start, end, confidence });\n    }\n    \n    i = end;\n}\n\nblocks\n```\n\n## Confidence Score Formula\n\n```\nconfidence = min(strong_ratio * 0.8 + size_bonus, 1.0)\n\nwhere:\n  strong_ratio = strong_line_count / total_boxy_line_count\n  size_bonus = min(block_height / 10, 0.2)\n```\n\n### Score Examples\n\n| Block Description | Strong | Boxy | Height | Confidence |\n|-------------------|--------|------|--------|------------|\n| 3-line box, all strong | 3 | 3 | 3 | (3/3)*0.8 + 0.0 = 0.80 |\n| 5-line box, all strong | 5 | 5 | 5 | (5/5)*0.8 + 0.0 = 0.80 |\n| 10-line box, all strong | 10 | 10 | 10 | (10/10)*0.8 + 0.2 = 1.00 |\n| 3-line, 1 strong 2 weak | 1 | 3 | 3 | (1/3)*0.8 + 0.0 = 0.27 |\n| 6-line, 2 strong 4 weak | 2 | 6 | 6 | (2/6)*0.8 + 0.0 = 0.27 |\n\n## Lookahead Heuristic\n\nWhen encountering a `None` line mid-block, we look ahead 3 lines:\n\n```\nLine 5: | content |     (Strong)\nLine 6: description     (None) â† What to do here?\nLine 7: | more    |     (Strong) â† Lookahead finds this!\n```\n\n**Behavior**: If ANY of lines 7-9 are boxy AND we haven't hit a blank gap, we bridge the None line and keep extending.\n\n**Rationale**: Some diagrams have inline labels or descriptions that break the box pattern but are still part of the logical diagram.\n\n## Blank Line Tolerance\n\n- 1 blank line: tolerated (common between rows)\n- 2+ blank lines: breaks the block (separate diagrams)\n\n```\nBlock 1:\n+------+\n| box  |\n+------+\n              â† 1 blank (ok, same block)\n+------+\n| more |\n+------+\n\n              â† 2 blanks (new block)\n+------+\n| new  |\n+------+\nBlock 2\n```\n\n## Edge Cases\n\n1. **Single Line**: Valid block if Strong or (Weak + all_blocks)\n2. **No Diagrams**: Returns empty vec, content unchanged\n3. **Diagram at EOF**: Handles correctly (no trailing blank trim issues)\n4. **Only Weak Lines**: Low confidence, skipped unless --all\n\n## Performance\n\n- O(n) where n = total lines\n- Single pass through document\n- Classify each line at most twice (main scan + lookahead)\n- No allocations except result vec\n\n## Test Coverage\n\n```rust\n#[test] fn test_find_diagram_blocks_simple() { ... }\n#[test] fn test_find_diagram_blocks_multiple() { ... }\n#[test] fn test_find_diagram_blocks_with_gaps() { ... }\n#[test] fn test_find_diagram_blocks_none() { ... }\n#[test] fn test_find_diagram_blocks_confidence() { ... }\n```\n\n## Dependencies\n\n- Requires: CORE: Line Classification Algorithm\n- Used by: Main correction pipeline\n- Affects: All downstream correction","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-21T04:56:40.154471948Z","created_by":"ubuntu","updated_at":"2026-01-21T07:44:48.775804388Z","closed_at":"2026-01-21T07:44:48.775757320Z","close_reason":"Verified block detection algorithm + tests; no code changes needed","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2kr","depends_on_id":"bd-2r3","type":"blocks","created_at":"2026-01-21T05:07:18.636500214Z","created_by":"ubuntu"}]}
{"id":"bd-2lr","title":"TESTING: Implement Line Analysis Unit Tests","description":"# TESTING: Implement Line Analysis Unit Tests\n\n## Purpose\n\nImplement comprehensive unit tests for line classification (LineKind), visual width calculation, and suffix border detection. These tests validate the core analysis that drives all diagram detection and correction.\n\n## Test Requirements\n\n### LineKind Classification Tests\n\n```rust\nmod line_classification {\n    use super::*;\n\n    #[test]\n    fn test_classify_line_blank_empty() {\n        test_log\\!(\"INFO\", \"Testing empty string classification\");\n        assert_eq\\!(classify_line(\"\"), LineKind::Blank);\n        test_log\\!(\"PASS\", \"Empty string â†’ Blank âœ“\");\n    }\n\n    #[test]\n    fn test_classify_line_blank_whitespace() {\n        let cases = [\"   \", \"\\t\", \"  \\t  \", \"\\n\"];\n        for case in cases {\n            test_log\\!(\"INFO\", \"Testing whitespace {:?}\", case);\n            assert_eq\\!(classify_line(case), LineKind::Blank, \n                \"Whitespace-only {:?} should be Blank\", case);\n        }\n    }\n\n    #[test]\n    fn test_classify_line_none_plain_text() {\n        let cases = [\"hello world\", \"This is a sentence.\", \"123 abc\", \"foo(bar)\"];\n        for case in cases {\n            test_log\\!(\"INFO\", \"Testing plain text {:?}\", case);\n            assert_eq\\!(classify_line(case), LineKind::None,\n                \"Plain text {:?} should be None\", case);\n        }\n    }\n\n    #[test]\n    fn test_classify_line_strong_with_corners() {\n        let cases = [\"+---+\", \"â”Œâ”€â”€â”€â”\", \"â•”â•â•â•â•—\", \"â•­â”€â”€â”€â•®\", \"+\", \"â”˜\"];\n        for case in cases {\n            test_log\\!(\"INFO\", \"Testing corner line {:?}\", case);\n            assert_eq\\!(classify_line(case), LineKind::Strong,\n                \"Line with corner {:?} should be Strong\", case);\n        }\n    }\n\n    #[test]\n    fn test_classify_line_strong_both_borders() {\n        let cases = [\"| text |\", \"â”‚ content â”‚\", \"â•‘ data â•‘\"];\n        for case in cases {\n            test_log\\!(\"INFO\", \"Testing bordered line {:?}\", case);\n            assert_eq\\!(classify_line(case), LineKind::Strong,\n                \"Line with both borders {:?} should be Strong\", case);\n        }\n    }\n\n    #[test]\n    fn test_classify_line_strong_high_ratio() {\n        // More than 33% box chars\n        let cases = [\"â”€â”€â”€â”€â”€â”€â”€\", \"â”â”â”â”â”â”â”\", \"â•â•â•â•â•â•â•\"];\n        for case in cases {\n            test_log\\!(\"INFO\", \"Testing high-ratio line {:?}\", case);\n            let result = classify_line(case);\n            test_log\\!(\"DEBUG\", \"Result: {:?}\", result);\n            assert_eq\\!(result, LineKind::Strong,\n                \"High box-char ratio {:?} should be Strong\", case);\n        }\n    }\n\n    #[test]\n    fn test_classify_line_weak_single_border() {\n        let cases = [\"text | more\", \"fooâ”‚bar\", \"aâ”€b\"];\n        for case in cases {\n            test_log\\!(\"INFO\", \"Testing weak line {:?}\", case);\n            assert_eq\\!(classify_line(case), LineKind::Weak,\n                \"Single internal box char {:?} should be Weak\", case);\n        }\n    }\n\n    #[test]\n    fn test_classify_line_weak_start_only() {\n        let cases = [\"| text\", \"â”‚ content\"];\n        for case in cases {\n            test_log\\!(\"INFO\", \"Testing start-only border {:?}\", case);\n            // Note: This might be Strong or Weak depending on implementation\n            let result = classify_line(case);\n            test_log\\!(\"DEBUG\", \"Result: {:?}\", result);\n            // Document actual behavior\n        }\n    }\n}\n```\n\n### Visual Width Tests\n\n```rust\nmod visual_width {\n    use super::*;\n\n    #[test]\n    fn test_visual_width_empty() {\n        assert_eq\\!(visual_width(\"\"), 0);\n    }\n\n    #[test]\n    fn test_visual_width_ascii() {\n        let cases = [\n            (\"hello\", 5),\n            (\"a b c\", 5),\n            (\"12345\", 5),\n            (\"\\!@#$%\", 5),\n        ];\n        for (input, expected) in cases {\n            test_log\\!(\"INFO\", \"Testing ASCII width {:?}\", input);\n            let result = visual_width(input);\n            assert_eq\\!(result, expected, \n                \"visual_width({:?}) = {} (expected {})\", input, result, expected);\n        }\n    }\n\n    #[test]\n    fn test_visual_width_box_chars() {\n        // Box drawing chars should be 1 column each\n        let cases = [\n            (\"â”‚\", 1),\n            (\"â”€\", 1),\n            (\"â”Œâ”\", 2),\n            (\"â•”â•â•—\", 3),\n            (\"â”‚ text â”‚\", 8),\n        ];\n        for (input, expected) in cases {\n            test_log\\!(\"INFO\", \"Testing box char width {:?}\", input);\n            let result = visual_width(input);\n            assert_eq\\!(result, expected,\n                \"visual_width({:?}) = {} (expected {})\", input, result, expected);\n        }\n    }\n\n    #[test]\n    fn test_visual_width_cjk() {\n        // CJK chars should be 2 columns each\n        let cases = [\n            (\"ä½ \", 2),\n            (\"ä½ å¥½\", 4),\n            (\"æ—¥æœ¬èªž\", 6),\n            (\"í•œê¸€\", 4),\n        ];\n        for (input, expected) in cases {\n            test_log\\!(\"INFO\", \"Testing CJK width {:?}\", input);\n            let result = visual_width(input);\n            assert_eq\\!(result, expected,\n                \"visual_width({:?}) = {} (expected {})\", input, result, expected);\n        }\n    }\n\n    #[test]\n    fn test_visual_width_mixed() {\n        let cases = [\n            (\"aä½ b\", 4),      // 1 + 2 + 1\n            (\"â”‚ä½ å¥½â”‚\", 6),    // 1 + 2 + 2 + 1\n            (\"Helloä½ å¥½\", 9), // 5 + 4\n        ];\n        for (input, expected) in cases {\n            test_log\\!(\"INFO\", \"Testing mixed width {:?}\", input);\n            let result = visual_width(input);\n            assert_eq\\!(result, expected,\n                \"visual_width({:?}) = {} (expected {})\", input, result, expected);\n        }\n    }\n\n    #[test]\n    fn test_visual_width_edge_cases() {\n        // Boundary characters around U+1100\n        test_log\\!(\"INFO\", \"Testing boundary characters\");\n        \n        // U+10FF should be 1 column (just before threshold)\n        let c_10ff = '\\u{10FF}';\n        test_log\\!(\"DEBUG\", \"U+10FF char: {:?}\", c_10ff);\n        \n        // U+1100 should be 2 columns (Hangul Jamo start)\n        let c_1100 = '\\u{1100}';\n        test_log\\!(\"DEBUG\", \"U+1100 char: {:?}\", c_1100);\n    }\n}\n```\n\n### Suffix Border Detection Tests\n\n```rust\nmod suffix_border {\n    use super::*;\n\n    #[test]\n    fn test_detect_suffix_border_ascii_pipe() {\n        test_log\\!(\"INFO\", \"Testing ASCII pipe suffix\");\n        let line = \"| text |\";\n        let result = detect_suffix_border(line);\n        assert\\!(result.is_some(), \"Should detect suffix border\");\n        let border = result.unwrap();\n        assert_eq\\!(border.char, '|');\n        assert_eq\\!(border.column, 7);\n        assert\\!(\\!border.is_closing);\n        test_log\\!(\"PASS\", \"Detected border at col {} âœ“\", border.column);\n    }\n\n    #[test]\n    fn test_detect_suffix_border_unicode() {\n        let cases = [\n            (\"â”‚ text â”‚\", 'â”‚', 7, false),\n            (\"â”ƒ text â”ƒ\", 'â”ƒ', 7, false),\n            (\"â•‘ text â•‘\", 'â•‘', 7, false),\n        ];\n        for (line, expected_char, expected_col, expected_closing) in cases {\n            test_log\\!(\"INFO\", \"Testing unicode border {:?}\", line);\n            let result = detect_suffix_border(line).unwrap();\n            assert_eq\\!(result.char, expected_char);\n            assert_eq\\!(result.column, expected_col);\n            assert_eq\\!(result.is_closing, expected_closing);\n        }\n    }\n\n    #[test]\n    fn test_detect_suffix_border_corners() {\n        let cases = [\n            (\"+---+\", '+', 4, true),\n            (\"â”Œâ”€â”€â”€â”\", 'â”', 4, true),\n            (\"â””â”€â”€â”€â”˜\", 'â”˜', 4, true),\n            (\"â•”â•â•â•â•—\", 'â•—', 4, true),\n        ];\n        for (line, expected_char, expected_col, expected_closing) in cases {\n            test_log\\!(\"INFO\", \"Testing corner line {:?}\", line);\n            let result = detect_suffix_border(line).unwrap();\n            assert_eq\\!(result.char, expected_char);\n            assert_eq\\!(result.column, expected_col);\n            assert\\!(result.is_closing, \"Corners should be closing\");\n        }\n    }\n\n    #[test]\n    fn test_detect_suffix_border_junctions() {\n        let cases = [\n            (\"â”œâ”€â”€â”€â”¤\", 'â”¤', 4, true),\n            (\"â• â•â•â•â•£\", 'â•£', 4, true),\n        ];\n        for (line, expected_char, expected_col, expected_closing) in cases {\n            test_log\\!(\"INFO\", \"Testing junction line {:?}\", line);\n            let result = detect_suffix_border(line).unwrap();\n            assert\\!(result.is_closing, \"Junctions should be closing\");\n        }\n    }\n\n    #[test]\n    fn test_detect_suffix_border_none() {\n        let cases = [\"text\", \"no border here\", \"\", \"  \", \"| text\"];\n        for line in cases {\n            test_log\\!(\"INFO\", \"Testing no-border line {:?}\", line);\n            let result = detect_suffix_border(line);\n            assert\\!(result.is_none(), \n                \"Line {:?} should have no suffix border\", line);\n        }\n    }\n\n    #[test]\n    fn test_detect_suffix_border_with_cjk() {\n        test_log\\!(\"INFO\", \"Testing CJK content with border\");\n        let line = \"â”‚ ä½ å¥½ â”‚\";\n        let result = detect_suffix_border(line).unwrap();\n        // 1 + 1 + 2 + 2 + 1 = 7 (but the border is at position after 'å¥½ ')\n        test_log\\!(\"DEBUG\", \"Border column: {}\", result.column);\n        // Verify column accounts for CJK width\n    }\n\n    #[test]\n    fn test_detect_suffix_border_trailing_space() {\n        test_log\\!(\"INFO\", \"Testing border with trailing space\");\n        let line = \"| text |   \";\n        let result = detect_suffix_border(line).unwrap();\n        assert_eq\\!(result.char, '|');\n        // Should find border despite trailing space\n    }\n}\n```\n\n## Running Tests\n\n```bash\n# Run all line analysis tests\ncargo test line_analysis\ncargo test visual_width\ncargo test suffix_border\n\n# Run with verbose output\nTEST_VERBOSE=1 cargo test line -- --nocapture\n```\n\n## Success Criteria\n\n- [ ] All LineKind classifications correct\n- [ ] Visual width accurate for ASCII, Unicode, CJK\n- [ ] Suffix border detection finds correct column\n- [ ] is_closing correctly identifies corners/junctions\n- [ ] Edge cases handled (empty, whitespace, no border)\n- [ ] CJK mixed content calculates correct widths\n\n## Dependencies\n\n- Requires: TESTING: Implement Character Detection Tests (bd-370)\n- Requires: CORE: Line Classification Algorithm (bd-2r3)\n- Requires: CORE: Visual Width Calculation (bd-1q9)\n- Requires: CORE: Suffix Border Detection (bd-fdi)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-21T05:50:12.759541021Z","created_by":"ubuntu","updated_at":"2026-01-21T08:34:56.957844752Z","closed_at":"2026-01-21T08:34:56.957791100Z","close_reason":"done","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2lr","depends_on_id":"bd-1q9","type":"blocks","created_at":"2026-01-21T05:51:02.248883094Z","created_by":"ubuntu"},{"issue_id":"bd-2lr","depends_on_id":"bd-2r3","type":"blocks","created_at":"2026-01-21T05:51:02.038842549Z","created_by":"ubuntu"},{"issue_id":"bd-2lr","depends_on_id":"bd-370","type":"blocks","created_at":"2026-01-21T05:51:01.810984068Z","created_by":"ubuntu"},{"issue_id":"bd-2lr","depends_on_id":"bd-fdi","type":"blocks","created_at":"2026-01-21T05:51:02.457061994Z","created_by":"ubuntu"}]}
{"id":"bd-2r3","title":"CORE: Line Classification Algorithm (LineKind)","description":"# CORE: Line Classification Algorithm (LineKind)\n\n## Purpose\n\nClassify each line into one of four categories to determine its role in diagram detection and correction. This classification drives both block boundaries and revision confidence.\n\n## LineKind Enum\n\n```rust\nenum LineKind {\n    Blank,   // Empty or whitespace-only\n    None,    // No box-drawing characters\n    Weak,    // Some box chars but weak pattern\n    Strong,  // Clear box-drawing pattern\n}\n```\n\n**Location**: src/main.rs lines ~98-114\n\n## Classification Algorithm\n\n```rust\nfn classify_line(line: &str) -> LineKind {\n    let trimmed = line.trim();\n    \n    // Step 1: Check for blank\n    if trimmed.is_empty() {\n        return LineKind::Blank;\n    }\n    \n    // Step 2: Count box characters\n    let box_count = trimmed.chars().filter(|&c| is_box_char(c)).count();\n    \n    // Step 3: No box chars = None\n    if box_count == 0 {\n        return LineKind::None;\n    }\n    \n    // Step 4: Apply Strong heuristics\n    let chars: Vec<char> = trimmed.chars().collect();\n    let has_corner = chars.iter().any(|&c| is_corner(c));\n    let starts_with_border = is_border_char(chars[0]);\n    let ends_with_border = is_border_char(*chars.last().unwrap());\n    let box_ratio = box_count as f64 / chars.len() as f64;\n    \n    if has_corner || (starts_with_border && ends_with_border) || box_ratio >= 0.33 {\n        LineKind::Strong\n    } else {\n        LineKind::Weak\n    }\n}\n```\n\n**Location**: src/main.rs lines ~227-258\n\n## Heuristics Explained\n\n### Strong Classification Triggers\n\n1. **Has Corner Character**\n   - Any corner (â•”, +, â”Œ, etc.) indicates intentional box structure\n   - High confidence: corners are rarely accidental\n   - Example: `+---+`, `â•”â•â•â•â•—`\n\n2. **Starts AND Ends with Border**\n   - Both ends having borders indicates enclosed content\n   - Example: `| text |`, `â”‚ data â”‚`\n   - Single-sided borders (just start or end) are Weak\n\n3. **Box Character Ratio â‰¥ 33%**\n   - Lines dominated by box chars are structural\n   - Example: `â”€â”€â”€â”€â”€â”€â”€â”€` (100% box chars)\n   - Threshold: 1 box char per 3 total chars\n\n### Weak Classification\n\nLines with SOME box characters but not meeting Strong criteria:\n- `hello | world` - Single pipe, not structural\n- `xâ”€y` - Dash in middle of text\n- `| text` - Only starts with border (no end)\n\n## Why This Matters\n\n### For Block Detection\n- Strong lines anchor block boundaries\n- Weak lines can extend blocks but don't start them\n- None/Blank lines can break block continuity\n\n### For Revision Scoring\n- Strong lines get +0.2 bonus on revision confidence\n- Weak lines get +0.0 or +0.1 depending on revision type\n- Prevents aggressive edits on ambiguous content\n\n## Edge Cases\n\n1. **Empty String**: Always Blank\n2. **Whitespace Only**: Always Blank (after trim)\n3. **Single Box Char**: Depends on position (Weak or Strong)\n4. **Mixed Content**: Ratio determines outcome\n\n## Test Coverage\n\n```rust\n#[test] fn test_classify_line_blank() { ... }\n#[test] fn test_classify_line_none() { ... }\n#[test] fn test_classify_line_weak() { ... }\n#[test] fn test_classify_line_strong() { ... }\n#[test] fn test_classify_line_corners() { ... }\n#[test] fn test_classify_line_borders() { ... }\n```\n\n## Performance Notes\n\n- O(n) where n = line length\n- Single pass through characters\n- No allocations in hot path (except Vec<char> for indexing)\n\n## Dependencies\n\n- Requires: CORE: Box Character Recognition System\n- Used by: CORE: Block Detection Algorithm\n- Used by: CORE: Revision Scoring System","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-21T04:55:43.488325282Z","created_by":"ubuntu","updated_at":"2026-01-21T07:34:23.262689609Z","closed_at":"2026-01-21T07:34:23.262626600Z","close_reason":"Verified classify_line logic + tests; no code changes needed","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2r3","depends_on_id":"bd-1am","type":"blocks","created_at":"2026-01-21T05:07:17.153162381Z","created_by":"ubuntu"},{"issue_id":"bd-2r3","depends_on_id":"bd-1q9","type":"blocks","created_at":"2026-01-21T05:07:18.307025751Z","created_by":"ubuntu"}]}
{"id":"bd-2sm","title":"TESTING: E2E Fixture Test Framework","description":"# TESTING: E2E Fixture Test Framework\n\n## Purpose\n\nProvide comprehensive end-to-end testing using input/expected file pairs. This validates the entire pipeline from file input to corrected output.\n\n## Directory Structure\n\n```\ntests/\nâ”œâ”€â”€ e2e_fixtures.sh          # Test runner script\nâ””â”€â”€ fixtures/\n    â”œâ”€â”€ ascii/\n    â”‚   â”œâ”€â”€ simple_box.input.txt\n    â”‚   â”œâ”€â”€ simple_box.expected.txt\n    â”‚   â”œâ”€â”€ nested_boxes.input.txt\n    â”‚   â””â”€â”€ nested_boxes.expected.txt\n    â”œâ”€â”€ unicode/\n    â”‚   â”œâ”€â”€ light_borders.input.txt\n    â”‚   â”œâ”€â”€ light_borders.expected.txt\n    â”‚   â”œâ”€â”€ heavy_borders.input.txt\n    â”‚   â”œâ”€â”€ heavy_borders.expected.txt\n    â”‚   â”œâ”€â”€ double_borders.input.txt\n    â”‚   â”œâ”€â”€ double_borders.expected.txt\n    â”‚   â”œâ”€â”€ rounded_corners.input.txt\n    â”‚   â””â”€â”€ rounded_corners.expected.txt\n    â”œâ”€â”€ mixed/\n    â”‚   â”œâ”€â”€ prose_with_diagrams.input.txt\n    â”‚   â”œâ”€â”€ prose_with_diagrams.expected.txt\n    â”‚   â”œâ”€â”€ multiple_diagrams.input.txt\n    â”‚   â””â”€â”€ multiple_diagrams.expected.txt\n    â”œâ”€â”€ large/\n    â”‚   â”œâ”€â”€ 100_lines.input.txt\n    â”‚   â”œâ”€â”€ 100_lines.expected.txt\n    â”‚   â”œâ”€â”€ cjk_content.input.txt\n    â”‚   â””â”€â”€ cjk_content.expected.txt\n    â””â”€â”€ edge_cases/\n        â”œâ”€â”€ empty.input.txt\n        â”œâ”€â”€ empty.expected.txt\n        â”œâ”€â”€ no_diagrams.input.txt\n        â”œâ”€â”€ no_diagrams.expected.txt\n        â”œâ”€â”€ already_aligned.input.txt\n        â”œâ”€â”€ already_aligned.expected.txt\n        â”œâ”€â”€ single_line.input.txt\n        â”œâ”€â”€ single_line.expected.txt\n        â”œâ”€â”€ whitespace_only.input.txt\n        â”œâ”€â”€ whitespace_only.expected.txt\n        â”œâ”€â”€ tabs.input.txt\n        â”œâ”€â”€ tabs.expected.txt\n        â”œâ”€â”€ malformed.input.txt\n        â””â”€â”€ malformed.expected.txt\n```\n\n## Test Runner Script\n\n```bash\n#!/bin/bash\n# tests/e2e_fixtures.sh\n\nset -euo pipefail\n\nSCRIPT_DIR=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\"\nFIXTURES=\"$SCRIPT_DIR/fixtures\"\nAADC=\"${AADC:-cargo run --release --}\"\n\npassed=0\nfailed=0\n\nfor input in \"$FIXTURES\"/**/*.input.txt; do\n    expected=\"${input%.input.txt}.expected.txt\"\n    name=\"${input#$FIXTURES/}\"\n    name=\"${name%.input.txt}\"\n    \n    if [[ ! -f \"$expected\" ]]; then\n        echo \"SKIP: $name (no expected file)\"\n        continue\n    fi\n    \n    actual=\"$(mktemp)\"\n    trap \"rm -f $actual\" EXIT\n    \n    if $AADC \"$input\" > \"$actual\" 2>&1; then\n        if diff -q \"$expected\" \"$actual\" > /dev/null 2>&1; then\n            echo \"PASS: $name\"\n            ((passed++))\n        else\n            echo \"FAIL: $name\"\n            echo \"  Expected vs Actual:\"\n            diff \"$expected\" \"$actual\" | head -20\n            ((failed++))\n        fi\n    else\n        echo \"ERROR: $name (aadc returned non-zero)\"\n        ((failed++))\n    fi\n    \n    rm -f \"$actual\"\ndone\n\necho \"\"\necho \"Results: $passed passed, $failed failed\"\nexit $((failed > 0 ? 1 : 0))\n```\n\n## Fixture Categories\n\n### ASCII Fixtures\n\nTest basic ASCII box characters (+, -, |):\n\n```\n# simple_box.input.txt\n+--------+\n| short|\n| longer text |\n+--------+\n\n# simple_box.expected.txt\n+-------------+\n| short       |\n| longer text |\n+-------------+\n```\n\n### Unicode Fixtures\n\nTest each Unicode box-drawing style:\n\n```\n# light_borders.input.txt\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ shortâ”‚\nâ”‚ longer â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\n# heavy_borders.input.txt\nâ”â”â”â”â”â”â”â”â”â”“\nâ”ƒ shortâ”ƒ\nâ”ƒ longer â”ƒ\nâ”—â”â”â”â”â”â”â”â”â”›\n\n# double_borders.input.txt\nâ•”â•â•â•â•â•â•â•â•â•—\nâ•‘ shortâ•‘\nâ•‘ longer â•‘\nâ•šâ•â•â•â•â•â•â•â•â•\n```\n\n### Mixed Content Fixtures\n\nTest diagrams embedded in prose:\n\n```\n# prose_with_diagrams.input.txt\nHere is some text before the diagram.\n\n+------+\n| A|\n+------+\n\nAnd some text after.\n```\n\n### Edge Case Fixtures\n\nTest boundary conditions:\n\n```\n# empty.input.txt\n(empty file)\n\n# no_diagrams.input.txt\nThis is just plain text.\nNo diagrams here.\n\n# already_aligned.input.txt\n+----+\n| OK |\n+----+\n\n# single_line.input.txt\n+----+\n\n# whitespace_only.input.txt\n   \n   \n\n# tabs.input.txt\n\\t+----+\n\\t| hi|\n\\t+----+\n```\n\n## Running Tests\n\n```bash\n# From project root\n./tests/e2e_fixtures.sh\n\n# With custom binary\nAADC=\"./target/release/aadc\" ./tests/e2e_fixtures.sh\n\n# Verbose mode (shows diffs)\n./tests/e2e_fixtures.sh 2>&1 | less\n```\n\n## CI Integration\n\n```yaml\n# .github/workflows/ci.yml\ntest-fixtures:\n  runs-on: ubuntu-latest\n  steps:\n    - uses: actions/checkout@v4\n    - uses: dtolnay/rust-toolchain@nightly\n    - run: cargo build --release\n    - run: ./tests/e2e_fixtures.sh\n```\n\n## Adding New Fixtures\n\n1. Create `tests/fixtures/category/name.input.txt`\n2. Create `tests/fixtures/category/name.expected.txt`\n3. Run `./tests/e2e_fixtures.sh` to verify\n4. Commit both files\n\n## Generating Expected Files\n\nFor new fixtures, generate expected output:\n\n```bash\n# Run aadc and verify output manually\ncargo run -- tests/fixtures/new/test.input.txt > temp.txt\n# Review temp.txt carefully\n# If correct, rename to expected\nmv temp.txt tests/fixtures/new/test.expected.txt\n```\n\n## Test Categories by Risk\n\n| Category | Risk Level | Focus |\n|----------|------------|-------|\n| ASCII | Low | Basic functionality |\n| Unicode | Medium | Encoding handling |\n| Mixed | Medium | Block detection |\n| Large | Low | Performance |\n| Edge Cases | High | Boundary conditions |\n\n## Performance Baseline\n\nLarge fixtures establish performance expectations:\n- 100 lines: <100ms\n- 1000 lines: <500ms\n- 10000 lines: <2s\n\n## Dependencies\n\n- Requires: Built aadc binary\n- Used by: CI pipeline\n- Related: Unit tests in src/main.rs","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-21T05:04:07.585214421Z","created_by":"ubuntu","updated_at":"2026-01-21T08:30:23.195806991Z","closed_at":"2026-01-21T08:30:23.195763198Z","close_reason":"Auto-discovered fixture pairs in tests/e2e_fixtures.sh; added AADC_CMD handling and skip-missing expected.","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2sm","depends_on_id":"bd-apa","type":"blocks","created_at":"2026-01-21T05:07:29.826753297Z","created_by":"ubuntu"}]}
{"id":"bd-2tr","title":"Add statistics summary in verbose mode","description":"# Statistics Summary in Verbose Mode\n\n## CLI Interface\n\nThe statistics summary is part of verbose mode output, no additional flags needed.\n\n```rust\n#[derive(Parser, Debug)]\npub struct Config {\n    /// Show detailed progress and statistics\n    #[arg(long, short = 'v')]\n    pub verbose: bool,\n}\n```\n\n**Usage:**\n```bash\naadc -v diagram.txt           # Shows stats at end\naadc -v -r docs/              # Aggregate stats for all files\naadc -v --json diagram.txt    # Stats in JSON format\n```\n\n## Implementation\n\n### Statistics Structure\n\n```rust\nuse std::time::{Duration, Instant};\n\n#[derive(Debug, Default, Clone)]\npub struct ProcessingStats {\n    pub files_processed: usize,\n    pub files_modified: usize,\n    pub files_unchanged: usize,\n    pub files_skipped: usize,\n    pub blocks_found: usize,\n    pub blocks_processed: usize,\n    pub blocks_skipped: usize,\n    pub revisions_applied: usize,\n    pub revisions_skipped: usize,\n    pub total_lines: usize,\n    pub elapsed: Duration,\n    pub errors: Vec<String>,\n}\n\nimpl ProcessingStats {\n    pub fn new() -> Self {\n        Self::default()\n    }\n\n    pub fn merge(&mut self, other: &ProcessingStats) {\n        self.files_processed += other.files_processed;\n        self.files_modified += other.files_modified;\n        self.files_unchanged += other.files_unchanged;\n        self.files_skipped += other.files_skipped;\n        self.blocks_found += other.blocks_found;\n        self.blocks_processed += other.blocks_processed;\n        self.blocks_skipped += other.blocks_skipped;\n        self.revisions_applied += other.revisions_applied;\n        self.revisions_skipped += other.revisions_skipped;\n        self.total_lines += other.total_lines;\n        self.errors.extend(other.errors.clone());\n    }\n}\n```\n\n### Statistics Collection During Processing\n\n```rust\npub fn process_with_stats(config: &Config, input: &str) -> (String, ProcessingStats) {\n    let start = Instant::now();\n    let mut stats = ProcessingStats::new();\n\n    test_log!(\"INFO\", \"Starting processing with stats collection\");\n\n    let lines: Vec<&str> = input.lines().collect();\n    stats.total_lines = lines.len();\n\n    // Detect blocks\n    let blocks = detect_blocks(&lines);\n    stats.blocks_found = blocks.len();\n    test_log!(\"DEBUG\", \"Found {} blocks in {} lines\", stats.blocks_found, stats.total_lines);\n\n    let mut output_lines = lines.iter().map(|s| s.to_string()).collect::<Vec<_>>();\n\n    for block in blocks {\n        if block.confidence < config.effective_min_score() {\n            stats.blocks_skipped += 1;\n            test_log!(\"DEBUG\", \"Skipping block (confidence {:.2} < {:.2})\",\n                block.confidence, config.effective_min_score());\n            continue;\n        }\n\n        stats.blocks_processed += 1;\n\n        // Process block iterations\n        let (revised_lines, block_revisions, skipped) = correct_block(config, &block, &output_lines);\n        stats.revisions_applied += block_revisions;\n        stats.revisions_skipped += skipped;\n\n        // Apply revisions\n        for (i, line) in revised_lines.iter().enumerate() {\n            if block.start + i < output_lines.len() {\n                output_lines[block.start + i] = line.clone();\n            }\n        }\n    }\n\n    stats.elapsed = start.elapsed();\n    stats.files_processed = 1;\n\n    if stats.revisions_applied > 0 {\n        stats.files_modified = 1;\n    } else {\n        stats.files_unchanged = 1;\n    }\n\n    test_log!(\"INFO\", \"Processing complete: {:?}\", stats);\n\n    (output_lines.join(\"\\n\"), stats)\n}\n```\n\n### Statistics Display\n\n```rust\npub fn print_statistics(stats: &ProcessingStats, colors: &VerboseColors) {\n    test_log!(\"INFO\", \"Printing statistics summary\");\n\n    eprintln!();\n    eprintln!(\"{}â”€â”€â”€ Summary â”€â”€â”€{}\", colors.header.render_str(\"\"), Style::reset());\n\n    // File statistics (for recursive mode)\n    if stats.files_processed > 1 {\n        eprintln!(\n            \"  {}Files:{} {} processed, {} modified, {} unchanged, {} skipped\",\n            colors.stat_label.render_str(\"\"),\n            Style::reset(),\n            stats.files_processed,\n            stats.files_modified,\n            stats.files_unchanged,\n            stats.files_skipped\n        );\n    }\n\n    // Block statistics\n    eprintln!(\n        \"  {}Blocks:{} {} found, {} processed, {} skipped (low confidence)\",\n        colors.stat_label.render_str(\"\"),\n        Style::reset(),\n        stats.blocks_found,\n        stats.blocks_processed,\n        stats.blocks_skipped\n    );\n\n    // Revision statistics\n    eprintln!(\n        \"  {}Revisions:{} {} applied, {} skipped\",\n        colors.stat_label.render_str(\"\"),\n        Style::reset(),\n        stats.revisions_applied,\n        stats.revisions_skipped\n    );\n\n    // Performance\n    let lines_per_sec = if stats.elapsed.as_secs_f64() > 0.0 {\n        stats.total_lines as f64 / stats.elapsed.as_secs_f64()\n    } else {\n        stats.total_lines as f64\n    };\n\n    eprintln!(\n        \"  {}Time:{} {:.2}ms ({:.0} lines/sec)\",\n        colors.stat_label.render_str(\"\"),\n        Style::reset(),\n        stats.elapsed.as_secs_f64() * 1000.0,\n        lines_per_sec\n    );\n\n    // Errors\n    if !stats.errors.is_empty() {\n        eprintln!(\n            \"  {}Errors:{} {}\",\n            colors.error.render_str(\"\"),\n            Style::reset(),\n            stats.errors.len()\n        );\n        for err in &stats.errors {\n            eprintln!(\"    â€¢ {}\", err);\n        }\n    }\n\n    eprintln!();\n}\n```\n\n### JSON Statistics Output\n\n```rust\nuse serde::Serialize;\n\n#[derive(Serialize)]\npub struct JsonStats {\n    pub files: FileStats,\n    pub blocks: BlockStats,\n    pub revisions: RevisionStats,\n    pub performance: PerfStats,\n    #[serde(skip_serializing_if = \"Vec::is_empty\")]\n    pub errors: Vec<String>,\n}\n\n#[derive(Serialize)]\npub struct FileStats {\n    pub processed: usize,\n    pub modified: usize,\n    pub unchanged: usize,\n    pub skipped: usize,\n}\n\n#[derive(Serialize)]\npub struct BlockStats {\n    pub found: usize,\n    pub processed: usize,\n    pub skipped: usize,\n}\n\n#[derive(Serialize)]\npub struct RevisionStats {\n    pub applied: usize,\n    pub skipped: usize,\n}\n\n#[derive(Serialize)]\npub struct PerfStats {\n    pub elapsed_ms: f64,\n    pub lines_total: usize,\n    pub lines_per_second: f64,\n}\n\nimpl From<&ProcessingStats> for JsonStats {\n    fn from(stats: &ProcessingStats) -> Self {\n        let elapsed_ms = stats.elapsed.as_secs_f64() * 1000.0;\n        let lines_per_sec = if elapsed_ms > 0.0 {\n            stats.total_lines as f64 / (elapsed_ms / 1000.0)\n        } else {\n            0.0\n        };\n\n        JsonStats {\n            files: FileStats {\n                processed: stats.files_processed,\n                modified: stats.files_modified,\n                unchanged: stats.files_unchanged,\n                skipped: stats.files_skipped,\n            },\n            blocks: BlockStats {\n                found: stats.blocks_found,\n                processed: stats.blocks_processed,\n                skipped: stats.blocks_skipped,\n            },\n            revisions: RevisionStats {\n                applied: stats.revisions_applied,\n                skipped: stats.revisions_skipped,\n            },\n            performance: PerfStats {\n                elapsed_ms,\n                lines_total: stats.total_lines,\n                lines_per_second: lines_per_sec,\n            },\n            errors: stats.errors.clone(),\n        }\n    }\n}\n```\n\n## Edge Cases\n\n1. **Zero elapsed time**: Handle division by zero in lines/sec calculation\n2. **Empty input**: Show meaningful stats (0 lines, 0 blocks)\n3. **Large files**: Use appropriate number formatting\n4. **Aggregated stats**: Merge correctly across multiple files\n5. **Error accumulation**: Collect all errors across files\n\n## Unit Tests\n\n```rust\n#[cfg(test)]\nmod stats_tests {\n    use super::*;\n\n    #[test]\n    fn test_stats_merge() {\n        test_log!(\"INFO\", \"Testing stats merge\");\n\n        let mut stats1 = ProcessingStats {\n            files_processed: 1,\n            blocks_found: 2,\n            revisions_applied: 3,\n            ..Default::default()\n        };\n\n        let stats2 = ProcessingStats {\n            files_processed: 1,\n            blocks_found: 3,\n            revisions_applied: 5,\n            ..Default::default()\n        };\n\n        stats1.merge(&stats2);\n\n        assert_eq!(stats1.files_processed, 2);\n        assert_eq!(stats1.blocks_found, 5);\n        assert_eq!(stats1.revisions_applied, 8);\n\n        test_log!(\"PASS\", \"Stats merge works âœ“\");\n    }\n\n    #[test]\n    fn test_lines_per_second_calculation() {\n        test_log!(\"INFO\", \"Testing lines/sec calculation\");\n\n        let stats = ProcessingStats {\n            total_lines: 1000,\n            elapsed: Duration::from_millis(100),\n            ..Default::default()\n        };\n\n        let lines_per_sec = stats.total_lines as f64 / stats.elapsed.as_secs_f64();\n        assert!((lines_per_sec - 10000.0).abs() < 1.0);\n\n        test_log!(\"PASS\", \"Lines/sec calculation works âœ“\");\n    }\n\n    #[test]\n    fn test_zero_elapsed_handling() {\n        test_log!(\"INFO\", \"Testing zero elapsed time handling\");\n\n        let stats = ProcessingStats {\n            total_lines: 100,\n            elapsed: Duration::ZERO,\n            ..Default::default()\n        };\n\n        // Should not panic\n        let json: JsonStats = (&stats).into();\n        assert!(json.performance.lines_per_second.is_finite() || json.performance.lines_per_second == 0.0);\n\n        test_log!(\"PASS\", \"Zero elapsed handled safely âœ“\");\n    }\n\n    #[test]\n    fn test_json_stats_serialization() {\n        test_log!(\"INFO\", \"Testing JSON stats serialization\");\n\n        let stats = ProcessingStats {\n            files_processed: 5,\n            blocks_found: 10,\n            revisions_applied: 15,\n            elapsed: Duration::from_millis(250),\n            ..Default::default()\n        };\n\n        let json: JsonStats = (&stats).into();\n        let serialized = serde_json::to_string_pretty(&json).unwrap();\n\n        assert!(serialized.contains(\"\\\"processed\\\": 5\"));\n        assert!(serialized.contains(\"\\\"found\\\": 10\"));\n        assert!(serialized.contains(\"\\\"applied\\\": 15\"));\n\n        test_log!(\"PASS\", \"JSON serialization works âœ“\");\n    }\n}\n```\n\n## E2E Tests\n\n```bash\n#!/bin/bash\n# tests/e2e_statistics.sh\n\nset -e\nsource \"$(dirname \"$0\")/e2e_runner.sh\"\n\ntest_verbose_shows_stats() {\n    log_test_start \"verbose_shows_stats\"\n\n    local tmpdir=$(mktemp -d)\n    create_misaligned_diagram \"$tmpdir/diagram.txt\"\n\n    log_debug \"Running verbose mode\"\n    local output=$(aadc -v \"$tmpdir/diagram.txt\" 2>&1)\n\n    log_debug \"Checking for statistics\"\n    echo \"$output\" | grep -q \"Summary\" && \\\n        log_pass \"Summary header present\" || \\\n        log_fail \"Summary header missing\"\n\n    echo \"$output\" | grep -q \"Blocks:\" && \\\n        log_pass \"Block stats present\" || \\\n        log_fail \"Block stats missing\"\n\n    echo \"$output\" | grep -q \"Revisions:\" && \\\n        log_pass \"Revision stats present\" || \\\n        log_fail \"Revision stats missing\"\n\n    echo \"$output\" | grep -q \"Time:\" && \\\n        log_pass \"Time stats present\" || \\\n        log_fail \"Time stats missing\"\n}\n\ntest_json_includes_stats() {\n    log_test_start \"json_includes_stats\"\n\n    local tmpdir=$(mktemp -d)\n    create_misaligned_diagram \"$tmpdir/diagram.txt\"\n\n    log_debug \"Running with --json\"\n    local output=$(aadc --json \"$tmpdir/diagram.txt\" 2>&1)\n\n    echo \"$output\" | jq -e '.stats' > /dev/null && \\\n        log_pass \"JSON stats present\" || \\\n        log_fail \"JSON stats missing\"\n\n    echo \"$output\" | jq -e '.stats.blocks.found' > /dev/null && \\\n        log_pass \"Block stats in JSON\" || \\\n        log_fail \"Block stats missing from JSON\"\n}\n\ntest_recursive_aggregated_stats() {\n    log_test_start \"recursive_aggregated_stats\"\n\n    local tmpdir=$(mktemp -d)\n    mkdir -p \"$tmpdir/docs\"\n    create_misaligned_diagram \"$tmpdir/a.md\"\n    create_misaligned_diagram \"$tmpdir/docs/b.md\"\n\n    log_debug \"Running recursive verbose\"\n    local output=$(aadc -rv --glob \"*.md\" \"$tmpdir\" 2>&1)\n\n    echo \"$output\" | grep -q \"2 processed\" && \\\n        log_pass \"File count correct\" || \\\n        log_fail \"File count wrong\"\n}\n\nrun_tests test_verbose_shows_stats test_json_includes_stats test_recursive_aggregated_stats\n```\n\n## Documentation Updates\n\nREADME.md section:\n```markdown\n### Statistics Summary\n\nVerbose mode shows detailed statistics after processing:\n\n```\nâ”€â”€â”€ Summary â”€â”€â”€\n  Blocks: 3 found, 3 processed, 0 skipped (low confidence)\n  Revisions: 7 applied, 2 skipped\n  Time: 2.45ms (4082 lines/sec)\n```\n\nFor recursive mode, file statistics are also shown:\n\n```\nâ”€â”€â”€ Summary â”€â”€â”€\n  Files: 15 processed, 8 modified, 7 unchanged, 0 skipped\n  Blocks: 24 found, 22 processed, 2 skipped (low confidence)\n  Revisions: 41 applied, 5 skipped\n  Time: 45.2ms (12500 lines/sec)\n```\n\nUse `--json` for machine-readable statistics.\n```\n\n## Success Criteria\n\n- [ ] Statistics collected during processing\n- [ ] Summary displayed at end of verbose output\n- [ ] File/block/revision counts accurate\n- [ ] Timing and throughput calculated\n- [ ] Stats aggregated correctly for recursive mode\n- [ ] JSON output includes stats object\n- [ ] Division by zero handled safely\n- [ ] Colors applied to stats output\n- [ ] Unit tests pass\n- [ ] E2E tests validate stats display","status":"in_progress","priority":3,"issue_type":"feature","created_at":"2026-01-21T02:01:17.694836117Z","created_by":"ubuntu","updated_at":"2026-01-21T19:21:57.929872765Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2tr","depends_on_id":"bd-1ih","type":"blocks","created_at":"2026-01-21T02:01:37.646993637Z","created_by":"ubuntu"},{"issue_id":"bd-2tr","depends_on_id":"bd-3fp","type":"blocks","created_at":"2026-01-21T05:07:44.669884938Z","created_by":"ubuntu"},{"issue_id":"bd-2tr","depends_on_id":"bd-apa","type":"blocks","created_at":"2026-01-21T05:07:45.027463928Z","created_by":"ubuntu"},{"issue_id":"bd-2tr","depends_on_id":"bd-raz","type":"blocks","created_at":"2026-01-21T02:01:44.042121071Z","created_by":"ubuntu"}]}
{"id":"bd-30v","title":"ARCHITECTURE: Project Foundation and Design Philosophy","description":"# ARCHITECTURE: Project Foundation and Design Philosophy\n\n## Executive Summary\n\naadc (ASCII Art Diagram Corrector) is a Rust CLI tool that automatically fixes misaligned right-hand borders in ASCII diagrams. This epic captures the foundational architecture decisions, design philosophy, and technical constraints that govern all development.\n\n## Problem Statement\n\nUsers spend significant time crafting ASCII diagrams in documentation, only to have right borders become misaligned after content edits. Manual fixing is tedious and error-prone. aadc solves this by:\n\n1. **Automatic Detection**: Heuristically identifies ASCII diagram blocks within mixed text\n2. **Safe Correction**: Only adds padding (never removes content)\n3. **Iterative Refinement**: Multiple passes with confidence scoring\n4. **Universal Compatibility**: Handles both ASCII and Unicode box-drawing characters\n\n## Core Design Principles\n\n### 1. Safety First (Monotone/Insert-Only)\n- NEVER delete characters from user content\n- Only add whitespace padding to align borders\n- Preserve all original text, just adjust spacing\n- Rationale: User content is sacred; we can't risk data loss\n\n### 2. Heuristic Detection Over Markers\n- No special comments or markers required\n- Recognize box-drawing patterns automatically\n- Allow users to work naturally with their documents\n- Trade-off: May occasionally misidentify blocks (mitigated by confidence scoring)\n\n### 3. Conservative by Default\n- Only modify high-confidence detections\n- Skip ambiguous blocks unless forced with --all\n- Scoring system prevents aggressive false positives\n- Users can lower threshold explicitly if needed\n\n### 4. Iterative Convergence\n- Multiple correction passes until stable\n- Each pass brings borders closer to alignment\n- Converges naturally when all borders match target column\n- Max iterations cap prevents infinite loops\n\n### 5. No Backwards Compatibility Burden\n- Early development, no external users yet\n- Do things the RIGHT way with NO tech debt\n- Never create compatibility shims or wrapper functions\n- Just fix code directly when changes needed\n\n## Technical Architecture\n\n```\nInput â†’ Tab Expansion â†’ Block Detection â†’ Iterative Correction â†’ Output\n                              â†“\n                        For each block:\n                          1. Analyze lines (classify as Strong/Weak/Blank/None)\n                          2. Find target column (rightmost border position)\n                          3. Generate revision candidates\n                          4. Score revisions (0.0-1.0 confidence)\n                          5. Apply revisions above threshold\n                          6. Repeat until converged or max_iters\n```\n\n## Key Data Structures\n\n| Structure | Purpose |\n|-----------|---------|\n| Config | CLI params: max_iters, min_score, tab_width, verbose |\n| LineKind | Classification: Strong, Weak, Blank, None |\n| AnalyzedLine | Per-line metadata: content, kind, visual_width, suffix_border |\n| SuffixBorder | Right border info: column, character, is_closing |\n| DiagramBlock | Detected region: start/end indices, confidence |\n| Revision | Edit proposal: PadBeforeSuffixBorder or AddSuffixBorder |\n\n## Toolchain Constraints\n\n- Rust 2024 Edition (nightly required)\n- ONLY Cargo for package management\n- Unsafe code FORBIDDEN (`#\\![forbid(unsafe_code)]`)\n- Release profile optimized for binary size (opt-level=z, LTO, strip)\n\n## Dependencies (Minimal)\n\n| Crate | Purpose | Justification |\n|-------|---------|---------------|\n| anyhow | Error handling | Clean error context propagation |\n| clap | CLI parsing | Industry standard, derive macros |\n| rich_rust | Terminal styling | Python Rich port, markup syntax |\n| similar | Diff generation | Unified diff for --diff flag |\n\n## Quality Gates\n\nAll changes MUST pass before commit:\n```bash\ncargo check --all-targets\ncargo clippy --all-targets -- -D warnings\ncargo fmt --check\ncargo test\n```\n\n## File Organization\n\n| File | Purpose |\n|------|---------|\n| src/main.rs | Complete implementation (CLI, core logic, tests) |\n| Cargo.toml | Dependencies and release optimizations |\n| rust-toolchain.toml | Nightly toolchain requirement |\n| tests/fixtures/ | E2E test cases |\n\n## Success Metrics\n\n1. Correctly aligns all standard ASCII box diagrams\n2. Correctly aligns all Unicode box-drawing diagrams\n3. Preserves non-diagram content exactly\n4. Converges in â‰¤3 iterations for typical diagrams\n5. Zero data loss (never removes user content)\n6. Sub-100ms processing for typical documents\n\n## Anti-Patterns to Avoid\n\n- Creating new files for variations (mainV2.rs, main_improved.rs)\n- Script-based bulk code changes\n- Backwards compatibility shims\n- Over-engineering beyond current requirements\n- Adding features not explicitly requested","status":"closed","priority":0,"issue_type":"epic","assignee":"ubuntu","created_at":"2026-01-21T04:54:42.979268043Z","created_by":"ubuntu","updated_at":"2026-01-21T07:28:06.918452023Z","closed_at":"2026-01-21T07:28:06.918263949Z","close_reason":"Validated architecture against code; summary delivered in session","compaction_level":0,"original_size":0}
{"id":"bd-31j","title":"TESTING: Implement Block Detection Unit Tests","description":"# TESTING: Implement Block Detection Unit Tests\n\n## Purpose\n\nImplement comprehensive unit tests for the diagram block detection algorithm. This validates the critical boundary detection that determines which regions of text are processed.\n\n## Test Requirements\n\n### Single Block Detection Tests\n\n```rust\nmod block_detection {\n    use super::*;\n\n    #[test]\n    fn test_find_blocks_simple_ascii_box() {\n        test_log!(\"INFO\", \"Testing simple ASCII box detection\");\n        let lines = vec![\n            \"+------+\",\n            \"| text |\",\n            \"+------+\",\n        ];\n        let blocks = find_diagram_blocks(&lines.iter().map(|s| *s).collect::<Vec<_>>(), false);\n        \n        test_log!(\"DEBUG\", \"Found {} blocks\", blocks.len());\n        assert_eq!(blocks.len(), 1, \"Should find exactly 1 block\");\n        \n        let block = &blocks[0];\n        test_log!(\"DEBUG\", \"Block: start={}, end={}, confidence={}\", \n            block.start, block.end, block.confidence);\n        \n        assert_eq!(block.start, 0);\n        assert_eq!(block.end, 3);\n        assert!(block.confidence >= 0.8, \"High confidence expected for clean box\");\n        test_log!(\"PASS\", \"Simple box detected correctly âœ“\");\n    }\n\n    #[test]\n    fn test_find_blocks_unicode_box() {\n        test_log!(\"INFO\", \"Testing Unicode box detection\");\n        let lines = vec![\n            \"â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”\",\n            \"â”‚ å†…å®¹   â”‚\",\n            \"â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜\",\n        ];\n        let blocks = find_diagram_blocks(&lines.iter().map(|s| *s).collect::<Vec<_>>(), false);\n        \n        assert_eq!(blocks.len(), 1);\n        assert_eq!(blocks[0].start, 0);\n        assert_eq!(blocks[0].end, 3);\n        test_log!(\"PASS\", \"Unicode box detected correctly âœ“\");\n    }\n\n    #[test]\n    fn test_find_blocks_double_border() {\n        test_log!(\"INFO\", \"Testing double-border box detection\");\n        let lines = vec![\n            \"â•”â•â•â•â•â•â•â•â•â•—\",\n            \"â•‘ data   â•‘\",\n            \"â•šâ•â•â•â•â•â•â•â•â•\",\n        ];\n        let blocks = find_diagram_blocks(&lines.iter().map(|s| *s).collect::<Vec<_>>(), false);\n        \n        assert_eq!(blocks.len(), 1);\n        assert!(blocks[0].confidence >= 0.8);\n    }\n}\n```\n\n### Multiple Block Detection Tests\n\n```rust\n#[test]\nfn test_find_blocks_two_separate_boxes() {\n    test_log!(\"INFO\", \"Testing two separate boxes\");\n    let lines = vec![\n        \"+---+\",\n        \"| A |\",\n        \"+---+\",\n        \"\",\n        \"\",  // Two blank lines = separator\n        \"+---+\",\n        \"| B |\",\n        \"+---+\",\n    ];\n    let blocks = find_diagram_blocks(&lines.iter().map(|s| *s).collect::<Vec<_>>(), false);\n    \n    test_log!(\"DEBUG\", \"Found {} blocks\", blocks.len());\n    for (i, b) in blocks.iter().enumerate() {\n        test_log!(\"DEBUG\", \"Block {}: lines {}-{}\", i, b.start, b.end);\n    }\n    \n    assert_eq!(blocks.len(), 2, \"Should find 2 separate blocks\");\n    assert_eq!(blocks[0].end, 3);  // First box ends at line 3\n    assert_eq!(blocks[1].start, 5); // Second box starts at line 5\n    test_log!(\"PASS\", \"Two separate boxes detected âœ“\");\n}\n\n#[test]\nfn test_find_blocks_with_prose() {\n    test_log!(\"INFO\", \"Testing boxes with surrounding prose\");\n    let lines = vec![\n        \"Here is some text before.\",\n        \"\",\n        \"+------+\",\n        \"| box  |\",\n        \"+------+\",\n        \"\",\n        \"And text after.\",\n    ];\n    let blocks = find_diagram_blocks(&lines.iter().map(|s| *s).collect::<Vec<_>>(), false);\n    \n    assert_eq!(blocks.len(), 1);\n    assert_eq!(blocks[0].start, 2);\n    assert_eq!(blocks[0].end, 5);\n    test_log!(\"PASS\", \"Box within prose detected correctly âœ“\");\n}\n```\n\n### Gap Tolerance Tests\n\n```rust\n#[test]\nfn test_find_blocks_single_blank_inside() {\n    test_log!(\"INFO\", \"Testing single blank line tolerance\");\n    let lines = vec![\n        \"+------+\",\n        \"| row1 |\",\n        \"\",           // Single blank - should be included\n        \"| row2 |\",\n        \"+------+\",\n    ];\n    let blocks = find_diagram_blocks(&lines.iter().map(|s| *s).collect::<Vec<_>>(), false);\n    \n    test_log!(\"DEBUG\", \"Found {} blocks\", blocks.len());\n    assert_eq!(blocks.len(), 1, \"Single blank should be tolerated\");\n    assert_eq!(blocks[0].end, 5, \"Block should include all 5 lines\");\n    test_log!(\"PASS\", \"Single blank inside block tolerated âœ“\");\n}\n\n#[test]\nfn test_find_blocks_two_blanks_splits() {\n    test_log!(\"INFO\", \"Testing two blank lines splits blocks\");\n    let lines = vec![\n        \"+---+\",\n        \"| A |\",\n        \"\",\n        \"\",           // Two blanks - should split\n        \"| B |\",\n        \"+---+\",\n    ];\n    let blocks = find_diagram_blocks(&lines.iter().map(|s| *s).collect::<Vec<_>>(), false);\n    \n    test_log!(\"DEBUG\", \"Found {} blocks\", blocks.len());\n    assert!(blocks.len() >= 1, \"Should find at least one block\");\n    // The exact behavior depends on implementation\n    // Document actual behavior here\n}\n```\n\n### Lookahead Heuristic Tests\n\n```rust\n#[test]\nfn test_find_blocks_lookahead_bridges_gap() {\n    test_log!(\"INFO\", \"Testing lookahead heuristic\");\n    let lines = vec![\n        \"+------+\",\n        \"| box  |\",\n        \"label:\",      // None line - lookahead should bridge\n        \"| more |\",\n        \"+------+\",\n    ];\n    let blocks = find_diagram_blocks(&lines.iter().map(|s| *s).collect::<Vec<_>>(), false);\n    \n    test_log!(\"DEBUG\", \"Found {} blocks\", blocks.len());\n    // If lookahead bridges, we get 1 block\n    // If not, we might get 2 or behavior differs\n    // Document actual behavior\n}\n\n#[test]\nfn test_find_blocks_lookahead_limit() {\n    test_log!(\"INFO\", \"Testing lookahead limit (3 lines)\");\n    let lines = vec![\n        \"+---+\",\n        \"| A |\",\n        \"text1\",  // None\n        \"text2\",  // None\n        \"text3\",  // None\n        \"text4\",  // None - beyond lookahead\n        \"| B |\",\n        \"+---+\",\n    ];\n    let blocks = find_diagram_blocks(&lines.iter().map(|s| *s).collect::<Vec<_>>(), false);\n    \n    test_log!(\"DEBUG\", \"Found {} blocks\", blocks.len());\n    // 4 None lines should exceed lookahead of 3\n}\n```\n\n### Confidence Scoring Tests\n\n```rust\n#[test]\nfn test_block_confidence_all_strong() {\n    test_log!(\"INFO\", \"Testing confidence for all-strong block\");\n    let lines = vec![\n        \"+------+\",\n        \"| text |\",\n        \"+------+\",\n    ];\n    let blocks = find_diagram_blocks(&lines.iter().map(|s| *s).collect::<Vec<_>>(), false);\n    \n    let confidence = blocks[0].confidence;\n    test_log!(\"DEBUG\", \"Confidence: {:.2}\", confidence);\n    assert!(confidence >= 0.8, \"All-strong block should have high confidence\");\n}\n\n#[test]\nfn test_block_confidence_mixed() {\n    test_log!(\"INFO\", \"Testing confidence for mixed block\");\n    let lines = vec![\n        \"+------+\",\n        \"text | more\",  // Weak line\n        \"+------+\",\n    ];\n    let blocks = find_diagram_blocks(&lines.iter().map(|s| *s).collect::<Vec<_>>(), false);\n    \n    if !blocks.is_empty() {\n        let confidence = blocks[0].confidence;\n        test_log!(\"DEBUG\", \"Confidence: {:.2}\", confidence);\n        // Mixed strong/weak should have lower confidence\n    }\n}\n\n#[test]\nfn test_block_confidence_size_bonus() {\n    test_log!(\"INFO\", \"Testing confidence size bonus\");\n    // Larger blocks get up to 0.2 bonus\n    let lines: Vec<&str> = (0..10).map(|i| {\n        if i == 0 || i == 9 { \"+------+\" }\n        else { \"| line |\" }\n    }).collect();\n    \n    let blocks = find_diagram_blocks(&lines, false);\n    if !blocks.is_empty() {\n        test_log!(\"DEBUG\", \"10-line block confidence: {:.2}\", blocks[0].confidence);\n    }\n}\n```\n\n### Edge Cases\n\n```rust\n#[test]\nfn test_find_blocks_empty_input() {\n    test_log!(\"INFO\", \"Testing empty input\");\n    let lines: Vec<&str> = vec![];\n    let blocks = find_diagram_blocks(&lines, false);\n    assert!(blocks.is_empty(), \"Empty input should yield no blocks\");\n}\n\n#[test]\nfn test_find_blocks_no_diagrams() {\n    test_log!(\"INFO\", \"Testing input with no diagrams\");\n    let lines = vec![\"Just plain text.\", \"No boxes here.\", \"Really.\"];\n    let blocks = find_diagram_blocks(&lines.iter().map(|s| *s).collect::<Vec<_>>(), false);\n    assert!(blocks.is_empty(), \"Plain text should yield no blocks\");\n}\n\n#[test]\nfn test_find_blocks_single_line() {\n    test_log!(\"INFO\", \"Testing single-line box\");\n    let lines = vec![\"+------+\"];\n    let blocks = find_diagram_blocks(&lines.iter().map(|s| *s).collect::<Vec<_>>(), false);\n    \n    test_log!(\"DEBUG\", \"Found {} blocks\", blocks.len());\n    // Single line with corners might be detected\n}\n\n#[test]\nfn test_find_blocks_at_eof() {\n    test_log!(\"INFO\", \"Testing block at end of file\");\n    let lines = vec![\n        \"text\",\n        \"+---+\",\n        \"| A |\",\n        \"+---+\",\n    ];\n    let blocks = find_diagram_blocks(&lines.iter().map(|s| *s).collect::<Vec<_>>(), false);\n    \n    assert_eq!(blocks.len(), 1);\n    assert_eq!(blocks[0].end, 4);\n    test_log!(\"PASS\", \"Block at EOF detected correctly âœ“\");\n}\n\n#[test]\nfn test_find_blocks_all_flag() {\n    test_log!(\"INFO\", \"Testing --all flag behavior\");\n    let lines = vec![\n        \"weak | line\",  // Low confidence\n        \"more | weak\",\n    ];\n    \n    let without_all = find_diagram_blocks(&lines.iter().map(|s| *s).collect::<Vec<_>>(), false);\n    let with_all = find_diagram_blocks(&lines.iter().map(|s| *s).collect::<Vec<_>>(), true);\n    \n    test_log!(\"DEBUG\", \"Without --all: {} blocks\", without_all.len());\n    test_log!(\"DEBUG\", \"With --all: {} blocks\", with_all.len());\n    // --all should include low-confidence blocks\n}\n```\n\n## Running Tests\n\n```bash\ncargo test block_detection -- --nocapture\nTEST_VERBOSE=1 cargo test find_blocks -- --nocapture\n```\n\n## Success Criteria\n\n- [ ] Single blocks detected with correct boundaries\n- [ ] Multiple blocks correctly separated\n- [ ] Prose around blocks handled correctly\n- [ ] Single blank line tolerance works\n- [ ] Two blank lines split blocks\n- [ ] Lookahead heuristic bridges gaps appropriately\n- [ ] Confidence scoring follows documented formula\n- [ ] Edge cases (empty, EOF, single-line) handled\n- [ ] --all flag includes low-confidence blocks\n\n## Dependencies\n\n- Requires: TESTING: Implement Line Analysis Tests (bd-2lr)\n- Requires: CORE: Diagram Block Detection Algorithm (bd-2kr)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-21T05:51:08.881814514Z","created_by":"ubuntu","updated_at":"2026-01-21T08:35:26.330474594Z","closed_at":"2026-01-21T08:35:26.330427245Z","close_reason":"done","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-31j","depends_on_id":"bd-2kr","type":"blocks","created_at":"2026-01-21T05:51:58.466066123Z","created_by":"ubuntu"},{"issue_id":"bd-31j","depends_on_id":"bd-2lr","type":"blocks","created_at":"2026-01-21T05:51:58.248072059Z","created_by":"ubuntu"}]}
{"id":"bd-32l","title":"INFRA: CLI Argument Parsing with clap","description":"# INFRA: CLI Argument Parsing with clap\n\n## Purpose\n\nParse command-line arguments using clap's derive macros. Provides type-safe, self-documenting CLI with automatic help generation.\n\n## Current CLI Structure\n\n```rust\nuse clap::Parser;\n\n#[derive(Parser)]\n#[command(name = \"aadc\")]\n#[command(author, version, about, long_about = None)]\nstruct Args {\n    /// Input file (reads from stdin if not provided)\n    #[arg(value_name = \"FILE\")]\n    file: Option<PathBuf>,\n\n    /// Edit file in place\n    #[arg(short = 'i', long)]\n    in_place: bool,\n\n    /// Maximum correction iterations\n    #[arg(short = 'm', long, default_value = \"10\")]\n    max_iters: usize,\n\n    /// Minimum confidence score (0.0-1.0)\n    #[arg(short = 's', long, default_value = \"0.5\")]\n    min_score: f64,\n\n    /// Tab expansion width\n    #[arg(short = 't', long, default_value = \"4\")]\n    tab_width: usize,\n\n    /// Process all diagram-like blocks\n    #[arg(short = 'a', long)]\n    all: bool,\n\n    /// Show correction progress\n    #[arg(short = 'v', long)]\n    verbose: bool,\n\n    /// Output unified diff\n    #[arg(short = 'd', long)]\n    diff: bool,\n}\n```\n\n**Location**: src/main.rs lines ~15-60\n\n## Argument Summary\n\n| Argument | Short | Long | Type | Default | Description |\n|----------|-------|------|------|---------|-------------|\n| FILE | - | - | Option<PathBuf> | None | Input file |\n| in_place | -i | --in-place | bool | false | Edit in place |\n| max_iters | -m | --max-iters | usize | 10 | Max iterations |\n| min_score | -s | --min-score | f64 | 0.5 | Score threshold |\n| tab_width | -t | --tab-width | usize | 4 | Tab size |\n| all | -a | --all | bool | false | Process all blocks |\n| verbose | -v | --verbose | bool | false | Show progress |\n| diff | -d | --diff | bool | false | Unified diff output |\n\n## Generated Help\n\n```\naadc - ASCII Art Diagram Corrector\n\nUsage: aadc [OPTIONS] [FILE]\n\nArguments:\n  [FILE]  Input file (reads from stdin if not provided)\n\nOptions:\n  -i, --in-place          Edit file in place\n  -m, --max-iters <NUM>   Maximum correction iterations [default: 10]\n  -s, --min-score <SCORE> Minimum confidence score (0.0-1.0) [default: 0.5]\n  -t, --tab-width <NUM>   Tab expansion width [default: 4]\n  -a, --all               Process all diagram-like blocks\n  -v, --verbose           Show correction progress\n  -d, --diff              Output unified diff\n  -h, --help              Print help\n  -V, --version           Print version\n```\n\n## Argument Validation\n\n### min_score Range\n\n```rust\nfn validate_args(args: &Args) -> Result<()> {\n    if args.min_score < 0.0 || args.min_score > 1.0 {\n        anyhow::bail!(\"--min-score must be between 0.0 and 1.0\");\n    }\n    // ...\n}\n```\n\n### in_place Requires File\n\n```rust\nif args.in_place && args.file.is_none() {\n    anyhow::bail!(\"--in-place requires a file argument\");\n}\n```\n\n### max_iters > 0\n\n```rust\nif args.max_iters == 0 {\n    anyhow::bail!(\"--max-iters must be at least 1\");\n}\n```\n\n## Config Struct Conversion\n\nArgs are converted to an internal Config struct:\n\n```rust\nlet config = Config {\n    max_iters: args.max_iters,\n    min_score: args.min_score,\n    tab_width: args.tab_width,\n    all_blocks: args.all,\n    verbose: args.verbose,\n    diff: args.diff,\n};\n```\n\n**Rationale**: Separates CLI concerns from core logic. Core functions don't need clap dependency.\n\n## Future Arguments\n\nPlanned additions (see feature beads):\n\n| Argument | Description | Bead |\n|----------|-------------|------|\n| --dry-run | Preview without writing | bd-13d |\n| --backup | Create .bak before -i | bd-3tf |\n| --json | Machine-readable output | bd-1c4 |\n| --preset | Named score thresholds | bd-26l |\n| --lines | Process specific range | bd-3uw |\n| --watch | Auto-correct on change | bd-1on |\n\n## Short Flag Conventions\n\n| Flag | Meaning | Standard? |\n|------|---------|-----------|\n| -i | in-place | Yes (sed, perl) |\n| -v | verbose | Yes (common) |\n| -a | all | Yes (common) |\n| -d | diff | Yes (patch tools) |\n| -m | max/limit | Somewhat |\n| -s | score/sensitivity | Custom |\n| -t | tab | Yes (expand) |\n\n## Error Handling\n\nclap automatically handles:\n- Unknown arguments â†’ error + help\n- Missing required args â†’ error + help\n- Invalid types â†’ error + expected type\n\nCustom validation uses anyhow for consistent error format.\n\n## Testing CLI Parsing\n\n```rust\n#[test]\nfn test_args_defaults() {\n    let args = Args::parse_from([\"aadc\"]);\n    assert_eq!(args.max_iters, 10);\n    assert_eq!(args.min_score, 0.5);\n    assert!(!args.in_place);\n}\n\n#[test]\nfn test_args_custom() {\n    let args = Args::parse_from([\"aadc\", \"-i\", \"-m\", \"20\", \"file.txt\"]);\n    assert!(args.in_place);\n    assert_eq!(args.max_iters, 20);\n    assert_eq!(args.file, Some(PathBuf::from(\"file.txt\")));\n}\n```\n\n## Dependencies\n\n- External: clap (4.5, features = [\"derive\"])\n- Used by: main()\n- Outputs: Config struct for core logic","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-21T05:03:00.577912171Z","created_by":"ubuntu","updated_at":"2026-01-21T07:44:09.585266477Z","closed_at":"2026-01-21T07:44:09.585218607Z","close_reason":"Added CLI validation + tests; QA passed","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-32l","depends_on_id":"bd-30v","type":"blocks","created_at":"2026-01-21T05:07:31.262895150Z","created_by":"ubuntu"}]}
{"id":"bd-370","title":"TESTING: Implement Character Detection Unit Tests","description":"# TESTING: Implement Character Detection Unit Tests\n\n## Purpose\n\nImplement comprehensive unit tests for all character detection functions (is_corner, is_horizontal_fill, is_vertical_border, is_junction, is_box_char, is_border_char). These are foundational tests that MUST pass before any other functionality can be trusted.\n\n## Test Requirements\n\n### Test Logging Format\n\nAll tests MUST use consistent logging with the `test_log\\!` macro:\n\n```rust\nmacro_rules\\! test_log {\n    ($level:expr, $($arg:tt)*) => {\n        if std::env::var(\"TEST_VERBOSE\").is_ok() {\n            eprintln\\!(\"[{}] [{}:{}] {}\", \n                $level, \n                file\\!(), \n                line\\!(), \n                format\\!($($arg)*)\n            );\n        }\n    };\n}\n\n// Usage:\ntest_log\\!(\"INFO\", \"Testing corner char: {:?}\", c);\ntest_log\\!(\"PASS\", \"is_corner('{}') = {} âœ“\", c, result);\ntest_log\\!(\"FAIL\", \"is_corner('{}') expected {} got {}\", c, expected, actual);\n```\n\n### is_corner Tests\n\n```rust\n#[test]\nfn test_is_corner_ascii_plus() {\n    test_log\\!(\"INFO\", \"Testing ASCII corner '+'\");\n    assert\\!(is_corner('+'), \"'+' should be recognized as corner\");\n    test_log\\!(\"PASS\", \"is_corner('+') = true âœ“\");\n}\n\n#[test]\nfn test_is_corner_unicode_light() {\n    let corners = ['â”Œ', 'â”', 'â””', 'â”˜'];\n    for c in corners {\n        test_log\\!(\"INFO\", \"Testing light corner {:?} (U+{:04X})\", c, c as u32);\n        assert\\!(is_corner(c), \"'{}' (U+{:04X}) should be corner\", c, c as u32);\n        test_log\\!(\"PASS\", \"is_corner('{}') = true âœ“\", c);\n    }\n}\n\n#[test]\nfn test_is_corner_unicode_double() {\n    let corners = ['â•”', 'â•—', 'â•š', 'â•'];\n    for c in corners {\n        test_log\\!(\"INFO\", \"Testing double corner {:?} (U+{:04X})\", c, c as u32);\n        assert\\!(is_corner(c), \"'{}' (U+{:04X}) should be corner\", c, c as u32);\n        test_log\\!(\"PASS\", \"is_corner('{}') = true âœ“\", c);\n    }\n}\n\n#[test]\nfn test_is_corner_unicode_rounded() {\n    let corners = ['â•­', 'â•®', 'â•¯', 'â•°'];\n    for c in corners {\n        test_log\\!(\"INFO\", \"Testing rounded corner {:?} (U+{:04X})\", c, c as u32);\n        assert\\!(is_corner(c), \"'{}' (U+{:04X}) should be corner\", c, c as u32);\n        test_log\\!(\"PASS\", \"is_corner('{}') = true âœ“\", c);\n    }\n}\n\n#[test]\nfn test_is_corner_negative_cases() {\n    let not_corners = ['-', '|', 'â”€', 'â”‚', 'a', '1', ' ', '\\n', '*', '#'];\n    for c in not_corners {\n        test_log\\!(\"INFO\", \"Testing non-corner {:?}\", c);\n        assert\\!(\\!is_corner(c), \"'{}' should NOT be corner\", c);\n        test_log\\!(\"PASS\", \"is_corner('{}') = false âœ“\", c);\n    }\n}\n```\n\n### is_horizontal_fill Tests\n\n```rust\n#[test]\nfn test_is_horizontal_fill_ascii() {\n    let fills = ['-', '~', '='];\n    for c in fills {\n        test_log\\!(\"INFO\", \"Testing ASCII horizontal fill {:?}\", c);\n        assert\\!(is_horizontal_fill(c));\n        test_log\\!(\"PASS\", \"is_horizontal_fill('{}') = true âœ“\", c);\n    }\n}\n\n#[test]\nfn test_is_horizontal_fill_unicode_light() {\n    let fills = ['â”€', 'â•Œ', 'â”„', 'â”ˆ'];\n    for c in fills {\n        test_log\\!(\"INFO\", \"Testing light horizontal {:?} (U+{:04X})\", c, c as u32);\n        assert\\!(is_horizontal_fill(c));\n    }\n}\n\n#[test]\nfn test_is_horizontal_fill_unicode_heavy() {\n    let fills = ['â”', 'â•', 'â”…', 'â”‰'];\n    for c in fills {\n        test_log\\!(\"INFO\", \"Testing heavy horizontal {:?} (U+{:04X})\", c, c as u32);\n        assert\\!(is_horizontal_fill(c));\n    }\n}\n\n#[test]\nfn test_is_horizontal_fill_unicode_double() {\n    test_log\\!(\"INFO\", \"Testing double horizontal 'â•'\");\n    assert\\!(is_horizontal_fill('â•'));\n}\n```\n\n### is_vertical_border Tests\n\n```rust\n#[test]\nfn test_is_vertical_border_ascii() {\n    test_log\\!(\"INFO\", \"Testing ASCII vertical '|'\");\n    assert\\!(is_vertical_border('|'));\n}\n\n#[test]\nfn test_is_vertical_border_unicode_light() {\n    let borders = ['â”‚', 'â•Ž', 'â”†', 'â”Š'];\n    for c in borders {\n        test_log\\!(\"INFO\", \"Testing light vertical {:?} (U+{:04X})\", c, c as u32);\n        assert\\!(is_vertical_border(c));\n    }\n}\n\n#[test]\nfn test_is_vertical_border_unicode_heavy() {\n    let borders = ['â”ƒ', 'â•', 'â”‡', 'â”‹'];\n    for c in borders {\n        test_log\\!(\"INFO\", \"Testing heavy vertical {:?} (U+{:04X})\", c, c as u32);\n        assert\\!(is_vertical_border(c));\n    }\n}\n\n#[test]\nfn test_is_vertical_border_unicode_double() {\n    test_log\\!(\"INFO\", \"Testing double vertical 'â•‘'\");\n    assert\\!(is_vertical_border('â•‘'));\n}\n```\n\n### is_junction Tests\n\n```rust\n#[test]\nfn test_is_junction_t_junctions() {\n    let junctions = ['â”¬', 'â”´', 'â”œ', 'â”¤'];\n    for c in junctions {\n        test_log\\!(\"INFO\", \"Testing T-junction {:?} (U+{:04X})\", c, c as u32);\n        assert\\!(is_junction(c));\n    }\n}\n\n#[test]\nfn test_is_junction_crosses() {\n    let junctions = ['â”¼', 'â•¬'];\n    for c in junctions {\n        test_log\\!(\"INFO\", \"Testing cross junction {:?} (U+{:04X})\", c, c as u32);\n        assert\\!(is_junction(c));\n    }\n}\n\n#[test]\nfn test_is_junction_double() {\n    let junctions = ['â•¦', 'â•©', 'â• ', 'â•£'];\n    for c in junctions {\n        test_log\\!(\"INFO\", \"Testing double junction {:?} (U+{:04X})\", c, c as u32);\n        assert\\!(is_junction(c));\n    }\n}\n\n#[test]\nfn test_is_junction_mixed() {\n    let junctions = ['â•¤', 'â•§', 'â•Ÿ', 'â•¢', 'â•«', 'â•ª'];\n    for c in junctions {\n        test_log\\!(\"INFO\", \"Testing mixed junction {:?} (U+{:04X})\", c, c as u32);\n        assert\\!(is_junction(c));\n    }\n}\n```\n\n### Composite Function Tests\n\n```rust\n#[test]\nfn test_is_box_char_covers_all_categories() {\n    // All corners\n    for c in ['+', 'â”Œ', 'â”', 'â””', 'â”˜', 'â•”', 'â•—', 'â•š', 'â•', 'â•­', 'â•®', 'â•¯', 'â•°'] {\n        assert\\!(is_box_char(c), \"is_box_char should include corner '{}'\", c);\n    }\n    // All horizontal\n    for c in ['-', '~', '=', 'â”€', 'â”', 'â•', 'â•Œ', 'â•', 'â”„', 'â”…', 'â”ˆ', 'â”‰'] {\n        assert\\!(is_box_char(c), \"is_box_char should include horizontal '{}'\", c);\n    }\n    // All vertical\n    for c in ['|', 'â”‚', 'â”ƒ', 'â•‘', 'â•Ž', 'â•', 'â”†', 'â”‡', 'â”Š', 'â”‹'] {\n        assert\\!(is_box_char(c), \"is_box_char should include vertical '{}'\", c);\n    }\n    // All junctions\n    for c in ['â”¬', 'â”´', 'â”œ', 'â”¤', 'â”¼', 'â•¦', 'â•©', 'â• ', 'â•£', 'â•¬', 'â•¤', 'â•§', 'â•Ÿ', 'â•¢', 'â•«', 'â•ª'] {\n        assert\\!(is_box_char(c), \"is_box_char should include junction '{}'\", c);\n    }\n}\n\n#[test]\nfn test_is_border_char_includes_closers() {\n    // Vertical borders\n    for c in ['|', 'â”‚', 'â”ƒ', 'â•‘'] {\n        assert\\!(is_border_char(c), \"'{}' should be border char\", c);\n    }\n    // Corners (can close lines)\n    for c in ['+', 'â”', 'â”˜', 'â•—', 'â•', 'â•®', 'â•¯'] {\n        assert\\!(is_border_char(c), \"'{}' should be border char\", c);\n    }\n    // Junctions (can close lines)\n    for c in ['â”¤', 'â•£', 'â•¢'] {\n        assert\\!(is_border_char(c), \"'{}' should be border char\", c);\n    }\n}\n```\n\n## Running Tests\n\n```bash\n# Run all character detection tests\ncargo test char_detection\n\n# Run with verbose logging\nTEST_VERBOSE=1 cargo test char_detection -- --nocapture\n\n# Run single test with logging\nTEST_VERBOSE=1 cargo test test_is_corner_unicode_light -- --nocapture\n```\n\n## Success Criteria\n\n- [ ] All 13 corner characters correctly identified\n- [ ] All 12 horizontal fill characters correctly identified\n- [ ] All 10 vertical border characters correctly identified\n- [ ] All 16 junction characters correctly identified\n- [ ] Negative cases verified (non-box chars return false)\n- [ ] is_box_char covers union of all categories\n- [ ] is_border_char includes line-closing characters\n- [ ] All tests pass with `cargo test`\n- [ ] Verbose logging works with TEST_VERBOSE=1\n\n## Dependencies\n\n- Requires: CORE: Box Character Recognition System (bd-1am)\n- Blocks: All other unit tests (foundational)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-21T05:49:24.665840006Z","created_by":"ubuntu","updated_at":"2026-01-21T08:33:43.308417739Z","closed_at":"2026-01-21T08:33:43.308359209Z","close_reason":"done","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-370","depends_on_id":"bd-1am","type":"blocks","created_at":"2026-01-21T05:50:06.786916033Z","created_by":"ubuntu"}]}
{"id":"bd-387","title":"E2E tests: CLI options (--max-iters, --min-score, --tab-width, --all, --verbose)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-21T01:46:04.541778363Z","created_by":"ubuntu","updated_at":"2026-01-21T02:29:52.572815552Z","closed_at":"2026-01-21T02:29:52.572773803Z","close_reason":"Created E2E test script with 17 tests covering --max-iters, --min-score, --tab-width, --all, --verbose options including short flags and combined usage.","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-387","depends_on_id":"bd-p73","type":"blocks","created_at":"2026-01-21T01:46:31.509611452Z","created_by":"ubuntu"}]}
{"id":"bd-3e8","title":"Unit tests: Correction loop (correct_block convergence, expand_tabs, correct_lines integration)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-21T01:45:56.604740584Z","created_by":"ubuntu","updated_at":"2026-01-21T03:14:23.883996365Z","closed_at":"2026-01-21T03:14:23.883907548Z","compaction_level":0,"original_size":0}
{"id":"bd-3fp","title":"INFRA: rich_rust Integration for Terminal Output","description":"# INFRA: rich_rust Integration for Terminal Output\n\n## Purpose\n\nProvide styled terminal output for verbose mode using the rich_rust library. This makes debugging and progress tracking more readable for users.\n\n## Library Overview\n\n**rich_rust** is a Rust port of Python's Rich library, providing:\n- Markup syntax for inline styling\n- Automatic terminal capability detection\n- Color downgrading for limited terminals\n- NO_COLOR environment variable support\n\n**Location**: Dependency in Cargo.toml, sourced from /dp/rich_rust\n\n## Current Usage in aadc\n\n### Initialization\n\n```rust\nuse rich_rust::Console;\n\nfn main() {\n    let console = Console::new();  // Auto-detects terminal capabilities\n    // ...\n}\n```\n\n### Verbose Output\n\n```rust\nif config.verbose {\n    console.print(\"[bold cyan]Processing {} lines...[/]\", lines.len());\n    console.print(\"[bold cyan]Found {} diagram block(s)[/]\", blocks.len());\n}\n```\n\n### Block Progress\n\n```rust\nconsole.print(&format\\!(\n    \"[yellow]  Block {}: lines {}-{} (confidence: {:.0}%)[/]\",\n    i + 1,\n    block.start + 1,\n    block.end,\n    block.confidence * 100.0\n));\n```\n\n### Iteration Progress\n\n```rust\nconsole.print(&format\\!(\n    \"[dim]    Iteration {}: applied {} revision(s)[/]\",\n    iteration + 1,\n    valid_revisions.len()\n));\n```\n\n### Final Summary\n\n```rust\nconsole.print(&format\\!(\n    \"[bold green]Processed {} block(s), {} revision(s) applied[/]\",\n    stats.blocks_modified,\n    stats.total_revisions\n));\n```\n\n## Markup Syntax\n\n### Colors\n```\n[red] [green] [blue] [cyan] [yellow] [magenta] [white]\n[bright_red] [bright_green] ...\n[#ff0000]  // Hex color\n[rgb(255,0,0)]  // RGB\n```\n\n### Styles\n```\n[bold] [dim] [italic] [underline] [strike]\n```\n\n### Combined\n```\n[bold cyan]Text[/]\n[dim yellow]Text[/]\n```\n\n### Closing Tags\n```\n[/]       // Close any open tag\n[/bold]   // Close specific tag\n```\n\n## Color Scheme for aadc\n\n| Element | Style | Rationale |\n|---------|-------|-----------|\n| Header/Count | [bold cyan] | Attention-grabbing, informational |\n| Block Info | [yellow] | Warning-like, secondary importance |\n| Iteration | [dim] | Tertiary, progress detail |\n| Success | [bold green] | Positive outcome |\n| Error | [bold red] | (future) Negative outcome |\n\n## Terminal Detection\n\nrich_rust automatically handles:\n\n1. **NO_COLOR env var**: Disables all colors\n2. **FORCE_COLOR env var**: Forces color level\n3. **TTY detection**: Plain text for pipes\n4. **Color capability**: Downgrades 24-bit to 256 to 16\n\n### Example Behavior\n\n```bash\n# TTY with truecolor support\naadc -v file.txt\nâ†’ Full colors\n\n# Piped output\naadc -v file.txt | cat\nâ†’ Plain text (no ANSI codes)\n\n# NO_COLOR set\nNO_COLOR=1 aadc -v file.txt\nâ†’ Plain text\n```\n\n## Performance Considerations\n\n### Lazy Initialization\nConsole is created once in main(), passed to functions.\n\n### No Overhead When Not Verbose\nStyling code only runs when config.verbose is true.\n\n### Efficient Rendering\nrich_rust uses zero-copy Segments with Cow<str>.\n\n## Alternatives Considered\n\n| Library | Pros | Cons |\n|---------|------|------|\n| **rich_rust** | Markup syntax, auto-detection | Larger dependency |\n| colored | Simple, small | No markup, manual TTY check |\n| termcolor | Cross-platform | Verbose API |\n| owo-colors | Zero-alloc | No markup, no auto-detect |\n\n**Decision**: rich_rust provides the best DX for our use case. The markup syntax makes formatting readable in code.\n\n## Future Enhancements\n\n1. **Progress Bars**: For large files, show processing progress\n2. **Tables**: Formatted output for --json alternative\n3. **Panels**: Boxed summaries in verbose mode\n4. **Syntax Highlighting**: Highlight diagram content in diff output\n\n## Test Considerations\n\nFor testing, use `Console::builder().markup(false).build()` to disable markup:\n\n```rust\n#[test]\nfn test_verbose_output() {\n    let console = Console::builder().markup(false).build();\n    // Test without ANSI codes\n}\n```\n\n## Dependencies\n\n- External: rich_rust crate (path = /dp/rich_rust)\n- Used by: CLI main(), correct_block(), correct_lines()\n- Configured by: --verbose flag","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-21T05:01:56.282204328Z","created_by":"ubuntu","updated_at":"2026-01-21T09:55:40.174285551Z","closed_at":"2026-01-21T09:55:40.174228884Z","close_reason":"Verified rich_rust Console usage and markup-based verbose output already implemented in src/main.rs with dependency in Cargo.toml.","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3fp","depends_on_id":"bd-32l","type":"blocks","created_at":"2026-01-21T05:07:29.479180280Z","created_by":"ubuntu"}]}
{"id":"bd-3h4","title":"TESTING: Implement Revision System Unit Tests","description":"## Purpose\nImplement comprehensive unit tests for the Revision system covering:\n1. **Revision Generation** (generate_revisions function)\n2. **Revision Scoring** (score_revision function)\n3. **Revision Application** (apply_revision function)\n\n## Test Logging Infrastructure\nAll tests use the test_log! macro for verbose debugging:\n\n```rust\n/// Logging macro for test diagnostics\n/// Set TEST_VERBOSE=1 to see detailed output during test runs\nmacro_rules! test_log {\n    ($level:expr, $($arg:tt)*) => {\n        if std::env::var(\"TEST_VERBOSE\").is_ok() {\n            eprintln!(\"[{}] [{}:{}] {}\", \n                $level, \n                file!(), \n                line!(), \n                format!($($arg)*)\n            );\n        }\n    };\n}\n```\n\n---\n\n## TEST SECTION 1: Revision Generation Tests\n\n### Test Case 1.1: PadBeforeSuffixBorder Generation\n```rust\n#[test]\nfn test_generate_pad_before_suffix_border() {\n    test_log!(\"START\", \"Testing PadBeforeSuffixBorder generation\");\n    \n    // Setup: Line with content shorter than target column\n    let line = AnalyzedLine {\n        original: \"| Hello |\".to_string(),\n        kind: LineKind::Strong,\n        suffix_border: Some(SuffixBorder { col: 8, char: '|' }),\n        left_border_pos: Some(0),\n    };\n    let target_col = 20;\n    \n    test_log!(\"INPUT\", \"Line: '{}', target_col: {}\", line.original, target_col);\n    test_log!(\"INPUT\", \"suffix_border col: {}, char: '{}'\", \n        line.suffix_border.as_ref().unwrap().col,\n        line.suffix_border.as_ref().unwrap().char);\n    \n    let revisions = generate_revisions(&line, target_col);\n    \n    test_log!(\"OUTPUT\", \"Generated {} revision(s)\", revisions.len());\n    for (i, rev) in revisions.iter().enumerate() {\n        test_log!(\"OUTPUT\", \"  Revision {}: {:?}\", i, rev);\n    }\n    \n    assert_eq!(revisions.len(), 1, \"Should generate exactly one PadBeforeSuffixBorder\");\n    match &revisions[0] {\n        Revision::PadBeforeSuffixBorder { spaces_to_add, .. } => {\n            let expected_spaces = target_col - 8;\n            assert_eq!(*spaces_to_add, expected_spaces, \n                \"Should add {} spaces\", expected_spaces);\n            test_log!(\"PASS\", \"Correct spaces_to_add: {}\", spaces_to_add);\n        }\n        _ => panic!(\"Expected PadBeforeSuffixBorder revision\"),\n    }\n    \n    test_log!(\"END\", \"Test PASSED\");\n}\n```\n\n### Test Case 1.2: AddSuffixBorder Generation\n```rust\n#[test]\nfn test_generate_add_suffix_border() {\n    test_log!(\"START\", \"Testing AddSuffixBorder generation for line missing right border\");\n    \n    // Setup: Line with left border but missing right border\n    let line = AnalyzedLine {\n        original: \"| Hello\".to_string(),\n        kind: LineKind::Weak,\n        suffix_border: None,\n        left_border_pos: Some(0),\n    };\n    let target_col = 12;\n    \n    test_log!(\"INPUT\", \"Line: '{}', target_col: {}\", line.original, target_col);\n    test_log!(\"INPUT\", \"suffix_border: None, left_border_pos: {:?}\", line.left_border_pos);\n    \n    let revisions = generate_revisions(&line, target_col);\n    \n    test_log!(\"OUTPUT\", \"Generated {} revision(s)\", revisions.len());\n    \n    assert!(!revisions.is_empty(), \"Should generate AddSuffixBorder revision\");\n    let has_add_suffix = revisions.iter().any(|r| matches!(r, Revision::AddSuffixBorder { .. }));\n    assert!(has_add_suffix, \"Should contain AddSuffixBorder variant\");\n    \n    test_log!(\"END\", \"Test PASSED\");\n}\n```\n\n### Test Case 1.3: No Revision for Already-Aligned Lines\n```rust\n#[test]\nfn test_no_revision_for_aligned_line() {\n    test_log!(\"START\", \"Testing no revision generated for already-aligned line\");\n    \n    let line = AnalyzedLine {\n        original: \"| Hello         |\".to_string(),\n        kind: LineKind::Strong,\n        suffix_border: Some(SuffixBorder { col: 16, char: '|' }),\n        left_border_pos: Some(0),\n    };\n    let target_col = 16; // Same as suffix_border col\n    \n    test_log!(\"INPUT\", \"Line: '{}', target_col: {} (equals suffix col)\", \n        line.original, target_col);\n    \n    let revisions = generate_revisions(&line, target_col);\n    \n    test_log!(\"OUTPUT\", \"Generated {} revision(s)\", revisions.len());\n    \n    assert!(revisions.is_empty(), \"Should not generate revisions for aligned line\");\n    \n    test_log!(\"END\", \"Test PASSED\");\n}\n```\n\n### Test Case 1.4: Unicode Content Revision Generation\n```rust\n#[test]\nfn test_revision_generation_with_cjk() {\n    test_log!(\"START\", \"Testing revision generation with CJK characters\");\n    \n    // CJK characters take 2 columns each\n    let line = AnalyzedLine {\n        original: \"â”‚ ä½ å¥½ â”‚\".to_string(),  // \"ä½ å¥½\" = 4 visual columns\n        kind: LineKind::Strong,\n        suffix_border: Some(SuffixBorder { col: 8, char: 'â”‚' }),\n        left_border_pos: Some(0),\n    };\n    let target_col = 15;\n    \n    test_log!(\"INPUT\", \"Line with CJK: '{}', target_col: {}\", line.original, target_col);\n    test_log!(\"INPUT\", \"Visual width of 'ä½ å¥½': 4 columns\");\n    \n    let revisions = generate_revisions(&line, target_col);\n    \n    test_log!(\"OUTPUT\", \"Generated {} revision(s)\", revisions.len());\n    \n    assert!(!revisions.is_empty(), \"Should generate revision for CJK line\");\n    \n    test_log!(\"END\", \"Test PASSED\");\n}\n```\n\n---\n\n## TEST SECTION 2: Revision Scoring Tests\n\n### Test Case 2.1: Score Strong Lines Higher\n```rust\n#[test]\nfn test_score_strong_line_revision() {\n    test_log!(\"START\", \"Testing that Strong line revisions score higher\");\n    \n    let strong_line = AnalyzedLine {\n        original: \"+----------+\".to_string(),\n        kind: LineKind::Strong,\n        suffix_border: Some(SuffixBorder { col: 11, char: '+' }),\n        left_border_pos: Some(0),\n    };\n    \n    let weak_line = AnalyzedLine {\n        original: \"| content |\".to_string(),\n        kind: LineKind::Weak,\n        suffix_border: Some(SuffixBorder { col: 10, char: '|' }),\n        left_border_pos: Some(0),\n    };\n    \n    let strong_revision = Revision::PadBeforeSuffixBorder {\n        line_idx: 0,\n        spaces_to_add: 5,\n        suffix_char: '+',\n    };\n    \n    let weak_revision = Revision::PadBeforeSuffixBorder {\n        line_idx: 1,\n        spaces_to_add: 5,\n        suffix_char: '|',\n    };\n    \n    let strong_score = score_revision(&strong_revision, &strong_line);\n    let weak_score = score_revision(&weak_revision, &weak_line);\n    \n    test_log!(\"SCORE\", \"Strong line revision score: {:.3}\", strong_score);\n    test_log!(\"SCORE\", \"Weak line revision score: {:.3}\", weak_score);\n    \n    assert!(strong_score >= weak_score, \n        \"Strong line revision ({}) should score >= weak line revision ({})\",\n        strong_score, weak_score);\n    \n    test_log!(\"END\", \"Test PASSED\");\n}\n```\n\n### Test Case 2.2: Score Decreases with Larger Padding\n```rust\n#[test]\nfn test_score_decreases_with_large_padding() {\n    test_log!(\"START\", \"Testing that score decreases as padding amount increases\");\n    \n    let line = AnalyzedLine {\n        original: \"| text |\".to_string(),\n        kind: LineKind::Weak,\n        suffix_border: Some(SuffixBorder { col: 7, char: '|' }),\n        left_border_pos: Some(0),\n    };\n    \n    let small_pad = Revision::PadBeforeSuffixBorder {\n        line_idx: 0,\n        spaces_to_add: 2,\n        suffix_char: '|',\n    };\n    \n    let large_pad = Revision::PadBeforeSuffixBorder {\n        line_idx: 0,\n        spaces_to_add: 50,\n        suffix_char: '|',\n    };\n    \n    let small_score = score_revision(&small_pad, &line);\n    let large_score = score_revision(&large_pad, &line);\n    \n    test_log!(\"SCORE\", \"Small padding (2) score: {:.3}\", small_score);\n    test_log!(\"SCORE\", \"Large padding (50) score: {:.3}\", large_score);\n    \n    assert!(small_score > large_score,\n        \"Small padding ({}) should score higher than large padding ({})\",\n        small_score, large_score);\n    \n    test_log!(\"END\", \"Test PASSED\");\n}\n```\n\n### Test Case 2.3: Score Within Valid Range\n```rust\n#[test]\nfn test_score_within_valid_range() {\n    test_log!(\"START\", \"Testing that all scores are within 0.0-1.0 range\");\n    \n    let test_cases = vec![\n        (LineKind::Strong, 1),\n        (LineKind::Strong, 100),\n        (LineKind::Weak, 1),\n        (LineKind::Weak, 50),\n        (LineKind::Blank, 5),\n        (LineKind::None, 10),\n    ];\n    \n    for (kind, spaces) in test_cases {\n        let line = AnalyzedLine {\n            original: \"| test |\".to_string(),\n            kind: kind.clone(),\n            suffix_border: Some(SuffixBorder { col: 7, char: '|' }),\n            left_border_pos: Some(0),\n        };\n        \n        let revision = Revision::PadBeforeSuffixBorder {\n            line_idx: 0,\n            spaces_to_add: spaces,\n            suffix_char: '|',\n        };\n        \n        let score = score_revision(&revision, &line);\n        \n        test_log!(\"SCORE\", \"kind={:?}, spaces={}: score={:.3}\", kind, spaces, score);\n        \n        assert!(score >= 0.0 && score <= 1.0,\n            \"Score {} should be in [0.0, 1.0] for kind={:?}, spaces={}\",\n            score, kind, spaces);\n    }\n    \n    test_log!(\"END\", \"Test PASSED\");\n}\n```\n\n### Test Case 2.4: AddSuffixBorder Scoring\n```rust\n#[test]\nfn test_add_suffix_border_scoring() {\n    test_log!(\"START\", \"Testing AddSuffixBorder revision scoring\");\n    \n    let line = AnalyzedLine {\n        original: \"| Missing border\".to_string(),\n        kind: LineKind::Weak,\n        suffix_border: None,\n        left_border_pos: Some(0),\n    };\n    \n    let revision = Revision::AddSuffixBorder {\n        line_idx: 0,\n        target_col: 20,\n        border_char: '|',\n    };\n    \n    let score = score_revision(&revision, &line);\n    \n    test_log!(\"SCORE\", \"AddSuffixBorder score: {:.3}\", score);\n    \n    // AddSuffixBorder should have lower confidence (it's guessing the border)\n    assert!(score >= 0.0 && score <= 1.0, \"Score should be valid\");\n    assert!(score < 0.8, \"AddSuffixBorder should have conservative score (< 0.8)\");\n    \n    test_log!(\"END\", \"Test PASSED\");\n}\n```\n\n---\n\n## TEST SECTION 3: Revision Application Tests\n\n### Test Case 3.1: Apply PadBeforeSuffixBorder\n```rust\n#[test]\nfn test_apply_pad_before_suffix_border() {\n    test_log!(\"START\", \"Testing PadBeforeSuffixBorder application\");\n    \n    let original = \"| Hello |\";\n    let revision = Revision::PadBeforeSuffixBorder {\n        line_idx: 0,\n        spaces_to_add: 5,\n        suffix_char: '|',\n    };\n    \n    test_log!(\"INPUT\", \"Original: '{}'\", original);\n    test_log!(\"INPUT\", \"Revision: add {} spaces before suffix\", 5);\n    \n    let result = apply_revision(original, &revision);\n    \n    test_log!(\"OUTPUT\", \"Result: '{}'\", result);\n    \n    assert_eq!(result, \"| Hello      |\", \"Should insert 5 spaces before final |\");\n    assert_eq!(result.chars().filter(|c| *c == '|').count(), 2, \n        \"Should still have 2 border chars\");\n    \n    test_log!(\"END\", \"Test PASSED\");\n}\n```\n\n### Test Case 3.2: Apply AddSuffixBorder\n```rust\n#[test]\nfn test_apply_add_suffix_border() {\n    test_log!(\"START\", \"Testing AddSuffixBorder application\");\n    \n    let original = \"| Missing border\";\n    let revision = Revision::AddSuffixBorder {\n        line_idx: 0,\n        target_col: 20,\n        border_char: '|',\n    };\n    \n    test_log!(\"INPUT\", \"Original: '{}' (len={})\", original, original.len());\n    test_log!(\"INPUT\", \"Revision: add '|' at col {}\", 20);\n    \n    let result = apply_revision(original, &revision);\n    \n    test_log!(\"OUTPUT\", \"Result: '{}' (len={})\", result, result.len());\n    \n    assert!(result.ends_with('|'), \"Should end with border char\");\n    \n    // Verify padding was added\n    let visual_width = visual_width(&result);\n    test_log!(\"OUTPUT\", \"Visual width: {}\", visual_width);\n    \n    assert_eq!(visual_width, 21, \"Visual width should be target_col + 1\");\n    \n    test_log!(\"END\", \"Test PASSED\");\n}\n```\n\n### Test Case 3.3: Apply Revision Preserves Unicode\n```rust\n#[test]\nfn test_apply_revision_preserves_unicode() {\n    test_log!(\"START\", \"Testing revision application preserves Unicode content\");\n    \n    let original = \"â”‚ cafÃ© â˜• â”‚\";\n    let revision = Revision::PadBeforeSuffixBorder {\n        line_idx: 0,\n        spaces_to_add: 3,\n        suffix_char: 'â”‚',\n    };\n    \n    test_log!(\"INPUT\", \"Original: '{}'\", original);\n    \n    let result = apply_revision(original, &revision);\n    \n    test_log!(\"OUTPUT\", \"Result: '{}'\", result);\n    \n    // Verify Unicode content preserved\n    assert!(result.contains(\"cafÃ©\"), \"Should preserve 'cafÃ©'\");\n    assert!(result.contains(\"â˜•\"), \"Should preserve emoji\");\n    assert!(result.starts_with(\"â”‚\"), \"Should preserve left border\");\n    assert!(result.ends_with(\"â”‚\"), \"Should preserve right border\");\n    \n    test_log!(\"END\", \"Test PASSED\");\n}\n```\n\n### Test Case 3.4: Apply Revision Idempotent Check\n```rust\n#[test]\nfn test_revision_application_idempotent() {\n    test_log!(\"START\", \"Testing that re-applying revision to aligned line is safe\");\n    \n    let original = \"| Content     |\";\n    let target_col = 14;\n    \n    // Analyze and generate revisions\n    let line = analyze_line(original);\n    test_log!(\"ANALYZE\", \"Line kind: {:?}, suffix_col: {:?}\", \n        line.kind,\n        line.suffix_border.as_ref().map(|s| s.col));\n    \n    let revisions = generate_revisions(&line, target_col);\n    test_log!(\"GENERATE\", \"Revisions generated: {}\", revisions.len());\n    \n    // If already aligned, no revisions should be generated\n    if line.suffix_border.as_ref().map(|s| s.col) == Some(target_col) {\n        assert!(revisions.is_empty(), \"No revisions for already-aligned line\");\n        test_log!(\"PASS\", \"Correctly generated no revisions\");\n    }\n    \n    test_log!(\"END\", \"Test PASSED\");\n}\n```\n\n---\n\n## TEST SECTION 4: Edge Cases\n\n### Test Case 4.1: Empty Line Revision\n```rust\n#[test]\nfn test_empty_line_no_revision() {\n    test_log!(\"START\", \"Testing empty line generates no revisions\");\n    \n    let line = AnalyzedLine {\n        original: \"\".to_string(),\n        kind: LineKind::Blank,\n        suffix_border: None,\n        left_border_pos: None,\n    };\n    \n    let revisions = generate_revisions(&line, 20);\n    \n    test_log!(\"OUTPUT\", \"Revisions for empty line: {}\", revisions.len());\n    \n    assert!(revisions.is_empty(), \"Empty line should not generate revisions\");\n    \n    test_log!(\"END\", \"Test PASSED\");\n}\n```\n\n### Test Case 4.2: Line Beyond Target Column\n```rust\n#[test]\nfn test_line_beyond_target_no_truncation() {\n    test_log!(\"START\", \"Testing that lines beyond target are never truncated\");\n    \n    let line = AnalyzedLine {\n        original: \"| Very long content that exceeds target |\".to_string(),\n        kind: LineKind::Strong,\n        suffix_border: Some(SuffixBorder { col: 40, char: '|' }),\n        left_border_pos: Some(0),\n    };\n    let target_col = 20; // Less than current suffix position\n    \n    test_log!(\"INPUT\", \"Line suffix at col {}, target {}\", 40, target_col);\n    \n    let revisions = generate_revisions(&line, target_col);\n    \n    test_log!(\"OUTPUT\", \"Revisions generated: {}\", revisions.len());\n    \n    // Monotone edit rule: never remove content\n    for rev in &revisions {\n        match rev {\n            Revision::PadBeforeSuffixBorder { spaces_to_add, .. } => {\n                assert!(*spaces_to_add >= 0, \"Should never have negative padding\");\n            }\n            _ => {}\n        }\n    }\n    \n    // Should generate no revisions since line already exceeds target\n    assert!(revisions.is_empty(), \n        \"Should not generate revisions when line exceeds target (monotone edits)\");\n    \n    test_log!(\"END\", \"Test PASSED\");\n}\n```\n\n### Test Case 4.3: Zero-Width Joiner Characters\n```rust\n#[test]\nfn test_zero_width_characters() {\n    test_log!(\"START\", \"Testing handling of zero-width characters\");\n    \n    // U+200B = zero-width space\n    let line_with_zwj = \"| text\\u{200B}content |\";\n    \n    test_log!(\"INPUT\", \"Line with zero-width: '{}'\", line_with_zwj);\n    test_log!(\"INPUT\", \"Byte length: {}, char count: {}\", \n        line_with_zwj.len(),\n        line_with_zwj.chars().count());\n    \n    let analyzed = analyze_line(line_with_zwj);\n    let visual_w = visual_width(line_with_zwj);\n    \n    test_log!(\"ANALYZE\", \"Visual width: {}\", visual_w);\n    test_log!(\"ANALYZE\", \"Suffix border col: {:?}\", \n        analyzed.suffix_border.as_ref().map(|s| s.col));\n    \n    // Zero-width chars should not affect visual width\n    assert!(visual_w < line_with_zwj.chars().count(), \n        \"Visual width should be less than char count due to ZWJ\");\n    \n    test_log!(\"END\", \"Test PASSED\");\n}\n```\n\n---\n\n## Success Criteria\n- [ ] All test cases pass with `cargo test`\n- [ ] Tests provide detailed output when run with `TEST_VERBOSE=1 cargo test -- --nocapture`\n- [ ] Edge cases for Unicode, empty lines, and overflow are covered\n- [ ] Scoring tests verify the confidence formula\n- [ ] Application tests verify monotone edit guarantee\n\n## Dependencies\n- Depends on bd-1oq (Revision Generation System)\n- Depends on bd-sy7 (Revision Scoring System)\n\n## Implementation Notes\n- Test file location: `src/main.rs` (test module) or separate `tests/revision_tests.rs`\n- All tests must use test_log! macro for consistent debugging\n- Run with `TEST_VERBOSE=1 cargo test revision -- --nocapture` for full output","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-21T05:53:15.345920891Z","created_by":"ubuntu","updated_at":"2026-01-21T08:36:00.758978166Z","closed_at":"2026-01-21T08:36:00.758926058Z","close_reason":"done","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3h4","depends_on_id":"bd-1oq","type":"blocks","created_at":"2026-01-21T05:54:25.310419032Z","created_by":"ubuntu"},{"issue_id":"bd-3h4","depends_on_id":"bd-31j","type":"blocks","created_at":"2026-01-21T05:54:25.747504339Z","created_by":"ubuntu"},{"issue_id":"bd-3h4","depends_on_id":"bd-sy7","type":"blocks","created_at":"2026-01-21T05:54:25.534018635Z","created_by":"ubuntu"}]}
{"id":"bd-3i9","title":"Add git pre-commit hook installer","description":"## Purpose\nAdd a command to install a git pre-commit hook that automatically checks/fixes diagram alignment. Makes aadc a natural part of the development workflow.\n\n## CLI Interface\n\n```bash\n# Install hook in current repo\naadc hook install\n\n# Install with check-only mode (no auto-fix)\naadc hook install --check-only\n\n# Install with auto-fix\naadc hook install --auto-fix\n\n# Uninstall hook\naadc hook uninstall\n\n# Show hook status\naadc hook status\n```\n\n## Implementation\n\n### Subcommand Definition (clap)\n```rust\n#[derive(Subcommand, Debug)]\nenum Commands {\n    /// Manage git pre-commit hook\n    Hook {\n        #[command(subcommand)]\n        action: HookAction,\n    },\n    // ... other subcommands or main processing\n}\n\n#[derive(Subcommand, Debug)]\nenum HookAction {\n    /// Install pre-commit hook\n    Install {\n        /// Only check, don't auto-fix\n        #[arg(long)]\n        check_only: bool,\n        \n        /// Auto-fix diagrams before commit\n        #[arg(long, conflicts_with = \"check_only\")]\n        auto_fix: bool,\n        \n        /// File patterns to check (default: *.md *.txt)\n        #[arg(long, value_delimiter = ',')]\n        patterns: Option<Vec<String>>,\n    },\n    /// Uninstall pre-commit hook\n    Uninstall,\n    /// Show hook status\n    Status,\n}\n```\n\n### Hook Script (Check Mode)\n```bash\n#!/usr/bin/env bash\n# aadc pre-commit hook (check mode)\n# Generated by: aadc hook install --check-only\n\nset -e\n\nPATTERNS=\"*.md *.txt\"\n\n# Get staged files matching patterns\nstaged_files() {\n    for pattern in $PATTERNS; do\n        git diff --cached --name-only --diff-filter=ACM | grep -E \"${pattern//\\*/.*}\" || true\n    done | sort -u\n}\n\nfiles=$(staged_files)\nif [[ -z \"$files\" ]]; then\n    exit 0\nfi\n\nfailed=0\nfor file in $files; do\n    if ! aadc --dry-run \"$file\" > /dev/null 2>&1; then\n        echo \"Diagram alignment needed: $file\"\n        ((failed++))\n    fi\ndone\n\nif [[ $failed -gt 0 ]]; then\n    echo \"\"\n    echo \"Run 'aadc -i <file>' to fix, or 'git commit --no-verify' to skip\"\n    exit 1\nfi\n```\n\n### Hook Script (Auto-fix Mode)\n```bash\n#!/usr/bin/env bash\n# aadc pre-commit hook (auto-fix mode)\n# Generated by: aadc hook install --auto-fix\n\nset -e\n\nPATTERNS=\"*.md *.txt\"\n\n# Get staged files matching patterns\nstaged_files() {\n    for pattern in $PATTERNS; do\n        git diff --cached --name-only --diff-filter=ACM | grep -E \"${pattern//\\*/.*}\" || true\n    done | sort -u\n}\n\nfiles=$(staged_files)\nif [[ -z \"$files\" ]]; then\n    exit 0\nfi\n\nmodified=0\nfor file in $files; do\n    if ! aadc --dry-run \"$file\" > /dev/null 2>&1; then\n        echo \"Auto-fixing diagrams: $file\"\n        aadc -i \"$file\"\n        git add \"$file\"\n        ((modified++))\n    fi\ndone\n\nif [[ $modified -gt 0 ]]; then\n    echo \"Auto-fixed $modified file(s)\"\nfi\n```\n\n### Installation Logic\n```rust\nfn install_hook(action: &HookInstall) -> anyhow::Result<()> {\n    // Find git root\n    let git_dir = find_git_dir()?;\n    let hooks_dir = git_dir.join(\"hooks\");\n    let hook_path = hooks_dir.join(\"pre-commit\");\n    \n    // Check for existing hook\n    if hook_path.exists() {\n        let content = fs::read_to_string(&hook_path)?;\n        if content.contains(\"# aadc pre-commit hook\") {\n            println!(\"aadc hook already installed\");\n            return Ok(());\n        }\n        // Backup existing hook\n        let backup = hook_path.with_extension(\"pre-aadc\");\n        fs::rename(&hook_path, &backup)?;\n        println!(\"Backed up existing hook to: {}\", backup.display());\n    }\n    \n    // Generate hook script\n    let script = if action.auto_fix {\n        generate_autofix_hook(&action.patterns)\n    } else {\n        generate_check_hook(&action.patterns)\n    };\n    \n    // Write hook\n    fs::write(&hook_path, script)?;\n    \n    // Make executable\n    #[cfg(unix)]\n    {\n        use std::os::unix::fs::PermissionsExt;\n        let mut perms = fs::metadata(&hook_path)?.permissions();\n        perms.set_mode(0o755);\n        fs::set_permissions(&hook_path, perms)?;\n    }\n    \n    println!(\"Installed aadc pre-commit hook: {}\", hook_path.display());\n    Ok(())\n}\n```\n\n### Status Command\n```rust\nfn show_hook_status() -> anyhow::Result<()> {\n    let git_dir = find_git_dir()?;\n    let hook_path = git_dir.join(\"hooks\").join(\"pre-commit\");\n    \n    if !hook_path.exists() {\n        println!(\"No pre-commit hook installed\");\n        return Ok(());\n    }\n    \n    let content = fs::read_to_string(&hook_path)?;\n    \n    if content.contains(\"# aadc pre-commit hook (check mode)\") {\n        println!(\"aadc hook installed (check mode)\");\n    } else if content.contains(\"# aadc pre-commit hook (auto-fix mode)\") {\n        println!(\"aadc hook installed (auto-fix mode)\");\n    } else {\n        println!(\"Non-aadc pre-commit hook present\");\n    }\n    \n    Ok(())\n}\n```\n\n## Test Cases\n\n### Unit Tests\n```rust\n#[test]\nfn test_generate_check_hook() {\n    let hook = generate_check_hook(&[\"*.md\", \"*.txt\"]);\n    \n    assert!(hook.contains(\"#!/usr/bin/env bash\"));\n    assert!(hook.contains(\"aadc --dry-run\"));\n    assert!(hook.contains(\"*.md\"));\n}\n\n#[test]\nfn test_generate_autofix_hook() {\n    let hook = generate_autofix_hook(&[\"*.md\"]);\n    \n    assert!(hook.contains(\"aadc -i\"));\n    assert!(hook.contains(\"git add\"));\n}\n\n#[test]\nfn test_find_git_dir() {\n    let temp = tempfile::tempdir().unwrap();\n    let git_dir = temp.path().join(\".git\");\n    fs::create_dir(&git_dir).unwrap();\n    \n    std::env::set_current_dir(temp.path()).unwrap();\n    \n    let found = find_git_dir().unwrap();\n    assert_eq!(found, git_dir);\n}\n```\n\n### E2E Tests\n```bash\ntest_hook_install() {\n    # Setup test repo\n    git init \"$TEMP/repo\"\n    cd \"$TEMP/repo\"\n    \n    # Install hook\n    aadc hook install\n    \n    # Verify hook exists and is executable\n    [[ -x .git/hooks/pre-commit ]] || fail \"Hook not installed\"\n    grep -q \"aadc\" .git/hooks/pre-commit || fail \"Hook doesn't contain aadc\"\n}\n\ntest_hook_check_mode() {\n    git init \"$TEMP/repo\"\n    cd \"$TEMP/repo\"\n    \n    aadc hook install --check-only\n    \n    # Create misaligned file\n    echo \"+---+\n| a|\n+---+\" > test.md\n    git add test.md\n    \n    # Hook should fail\n    ! git commit -m \"test\" || fail \"Hook should have blocked commit\"\n}\n\ntest_hook_autofix_mode() {\n    git init \"$TEMP/repo\"\n    cd \"$TEMP/repo\"\n    git config user.email \"test@test.com\"\n    git config user.name \"Test\"\n    \n    aadc hook install --auto-fix\n    \n    # Create misaligned file\n    echo \"+---+\n| a|\n+---+\" > test.md\n    git add test.md\n    \n    # Hook should auto-fix\n    git commit -m \"test\"\n    \n    # File should be fixed\n    [[ \"$(cat test.md)\" == *\"| a |\"* ]] || fail \"File not auto-fixed\"\n}\n\ntest_hook_uninstall() {\n    git init \"$TEMP/repo\"\n    cd \"$TEMP/repo\"\n    \n    aadc hook install\n    aadc hook uninstall\n    \n    [[ ! -f .git/hooks/pre-commit ]] || fail \"Hook still exists\"\n}\n```\n\n## Documentation Updates\n\n### README\n```markdown\n## Git Integration\n\nInstall a pre-commit hook to automatically check diagrams:\n\n\\`\\`\\`bash\n# Check mode (blocks commits with misaligned diagrams)\naadc hook install --check-only\n\n# Auto-fix mode (fixes diagrams before commit)\naadc hook install --auto-fix\n\n# Check status\naadc hook status\n\n# Remove hook\naadc hook uninstall\n\\`\\`\\`\n```\n\n## Success Criteria\n- [ ] \\`aadc hook install\\` creates pre-commit hook\n- [ ] --check-only mode blocks bad commits\n- [ ] --auto-fix mode fixes before commit\n- [ ] Hook is executable (Unix)\n- [ ] Existing hooks are backed up\n- [ ] \\`aadc hook uninstall\\` removes hook\n- [ ] \\`aadc hook status\\` shows info\n- [ ] Works with custom patterns\n- [ ] Unit tests pass\n- [ ] E2E tests pass\n- [ ] README documents feature\n\n## Dependencies\n- Requires: CORE: Iterative Correction Loop (bd-apa)\n- Requires: --diff flag (bd-raz) for showing changes\n- Requires: --dry-run flag (bd-13d) for check mode\n- Belongs to: Feature Improvements Epic (bd-1ih)","status":"closed","priority":3,"issue_type":"feature","created_at":"2026-01-21T02:00:57.708201193Z","created_by":"ubuntu","updated_at":"2026-01-21T18:49:28.391497743Z","closed_at":"2026-01-21T18:49:28.391444854Z","close_reason":"Fully implemented: 'aadc hook install/uninstall/status' subcommands with --check-only and --auto-fix modes. Check mode uses --dry-run, auto-fix mode uses -i and git add. Backs up existing hooks. All 16 hook-related tests pass.","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3i9","depends_on_id":"bd-1ih","type":"blocks","created_at":"2026-01-21T02:01:36.668939906Z","created_by":"ubuntu"},{"issue_id":"bd-3i9","depends_on_id":"bd-nci","type":"blocks","created_at":"2026-01-21T05:07:46.487854687Z","created_by":"ubuntu"},{"issue_id":"bd-3i9","depends_on_id":"bd-raz","type":"blocks","created_at":"2026-01-21T02:01:44.286649772Z","created_by":"ubuntu"}]}
{"id":"bd-3ie","title":"PERF: Performance Profiling and Optimization Strategy","description":"# PERF: Performance Profiling and Optimization Strategy\n\n## Purpose\n\nEstablish performance baselines and optimization strategies. aadc should be fast enough for interactive use and CI pipelines.\n\n## Performance Goals\n\n| Metric | Target | Rationale |\n|--------|--------|-----------|\n| Small files (<100 lines) | <50ms | Interactive feel |\n| Medium files (<1000 lines) | <200ms | Acceptable wait |\n| Large files (<10000 lines) | <2s | Background acceptable |\n| Memory usage | <50MB | Reasonable for CLI |\n| Binary size | <5MB | Fast download/install |\n\n## Current Architecture Analysis\n\n### Time Complexity\n\n```\nTotal: O(B Ã— I Ã— L Ã— W)\n\nWhere:\n  B = number of diagram blocks\n  I = iterations per block (typically 1-3, max 10)\n  L = lines per block\n  W = average line width (for visual_width)\n```\n\n### Hot Paths\n\n1. **visual_width()**: Called for every line, every iteration\n2. **classify_line()**: Called during block detection and analysis\n3. **is_box_char()**: Called for every character in boxy lines\n\n### Memory Allocation\n\n- Lines stored as Vec<String>\n- AnalyzedLine created per iteration (could reuse)\n- Revisions collected in Vec (small)\n\n## Profiling Approach\n\n### 1. Benchmarking Setup\n\n```rust\n// benches/correction.rs\nuse criterion::{criterion_group, criterion_main, Criterion};\n\nfn bench_small_file(c: &mut Criterion) {\n    let input = include_str!(\"../tests/fixtures/ascii/simple_box.input.txt\");\n    let lines: Vec<String> = input.lines().map(|s| s.to_string()).collect();\n    let config = Config::default();\n    let console = Console::builder().markup(false).build();\n    \n    c.bench_function(\"small_file\", |b| {\n        b.iter(|| correct_lines(&lines, &config, &console))\n    });\n}\n```\n\n### 2. Flamegraph Generation\n\n```bash\n# Install flamegraph\ncargo install flamegraph\n\n# Generate with DWARF info\nCARGO_PROFILE_RELEASE_DEBUG=true cargo flamegraph --bin aadc -- large_file.txt\n\n# View in browser\nopen flamegraph.svg\n```\n\n### 3. Heap Profiling\n\n```bash\n# With heaptrack\nheaptrack ./target/release/aadc large_file.txt\nheaptrack_gui heaptrack.aadc.*.gz\n```\n\n## Optimization Opportunities\n\n### Tier 1: Low-Hanging Fruit\n\n#### 1. Reuse AnalyzedLine Allocations\nCurrently creates new Vec<AnalyzedLine> each iteration.\n\n```rust\n// Before: Allocates every iteration\nlet analyzed: Vec<AnalyzedLine> = lines.iter()\n    .map(|l| analyze_line(l))\n    .collect();\n\n// After: Reuse buffer\nanalyzed.clear();\nfor line in lines {\n    analyzed.push(analyze_line(line));\n}\n```\n\n#### 2. Avoid String Allocation in is_box_char\nCurrently uses match which is efficient, but could use lookup table.\n\n```rust\n// Create static lookup set\nstatic BOX_CHARS: LazyLock<HashSet<char>> = LazyLock::new(|| {\n    // All box chars\n});\n\nfn is_box_char(c: char) -> bool {\n    BOX_CHARS.contains(&c)\n}\n```\n\n**Trade-off**: Hash lookup vs match statement. Benchmark first!\n\n### Tier 2: Algorithm Improvements\n\n#### 3. Early Termination in Block Detection\nIf no box chars in first N lines, skip file entirely.\n\n```rust\nfn quick_scan(lines: &[&str]) -> bool {\n    lines.iter().take(100).any(|l| l.chars().any(is_box_char))\n}\n```\n\n#### 4. Skip Already-Aligned Blocks\nIf all borders already at same column, skip correction loop.\n\n```rust\nfn needs_correction(analyzed: &[AnalyzedLine]) -> bool {\n    let columns: HashSet<_> = analyzed.iter()\n        .filter_map(|l| l.suffix_border.as_ref())\n        .map(|b| b.column)\n        .collect();\n    columns.len() > 1  // More than one column = needs alignment\n}\n```\n\n### Tier 3: Advanced Optimizations\n\n#### 5. SIMD for Box Char Detection\nUse packed_simd for vectorized character scanning.\n\n```rust\n// Scan 16 bytes at once for ASCII box chars\nfn contains_ascii_box_simd(bytes: &[u8]) -> bool {\n    // SIMD implementation\n}\n```\n\n**Note**: Only worthwhile for very large files.\n\n#### 6. Parallel Block Processing\nProcess multiple blocks concurrently with rayon.\n\n```rust\nuse rayon::prelude::*;\n\nblocks.par_iter_mut().for_each(|block| {\n    correct_block(&mut lines[block.start..block.end], ...);\n});\n```\n\n**Note**: Requires careful lifetime management.\n\n## Binary Size Optimization\n\nCurrent profile already optimizes for size:\n\n```toml\n[profile.release]\nopt-level = \"z\"     # Size over speed\nlto = true          # Link-time optimization\ncodegen-units = 1   # Better optimization\npanic = \"abort\"     # No unwinding\nstrip = true        # Remove symbols\n```\n\nAdditional options:\n- Remove debug assertions in dependencies\n- Use `#[inline(never)]` on cold paths\n- Consider `cargo-bloat` for size analysis\n\n## Measurement Commands\n\n```bash\n# Time execution\ntime aadc large_file.txt > /dev/null\n\n# With hyperfine (better stats)\nhyperfine 'aadc large_file.txt' --warmup 3\n\n# Memory usage\n/usr/bin/time -v aadc large_file.txt\n\n# Binary size\nls -lh target/release/aadc\n```\n\n## Regression Prevention\n\nAdd performance tests to CI:\n\n```yaml\n# .github/workflows/ci.yml\nperf-test:\n  runs-on: ubuntu-latest\n  steps:\n    - uses: actions/checkout@v4\n    - run: cargo build --release\n    - run: |\n        time ./target/release/aadc tests/fixtures/large/100_lines.input.txt > /dev/null\n        # Fail if >500ms (generous margin)\n```\n\n## Dependencies\n\n- Profiling tools: flamegraph, heaptrack, hyperfine\n- Optional: criterion (benchmarking), rayon (parallelism)\n- Related: CORE: Iterative Correction Loop","status":"closed","priority":2,"issue_type":"epic","created_at":"2026-01-21T05:06:21.215543437Z","created_by":"ubuntu","updated_at":"2026-01-21T17:27:31.969087176Z","closed_at":"2026-01-21T17:27:31.969005882Z","close_reason":"Implemented performance profiling infrastructure: criterion benchmarks, hyperfine script, PERF.md documentation with baseline measurements. Quality gates pass.","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3ie","depends_on_id":"bd-apa","type":"blocks","created_at":"2026-01-21T05:07:30.538956123Z","created_by":"ubuntu"}]}
{"id":"bd-3j4","title":"CORE: Tab Expansion System","description":"# CORE: Tab Expansion System\n\n## Purpose\n\nConvert tab characters to spaces before processing. Tabs have variable width depending on column position, which breaks visual width calculations. Expanding them first normalizes the input.\n\n## The Problem\n\nTabs are rendered based on column position, not fixed width:\n\n```\nWith tab_width=4:\n\"\\thi\" displays as:     \"    hi\"  (4 spaces)\n\"a\\tb\" displays as:     \"a   b\"   (3 spaces to reach col 4)\n\"ab\\tc\" displays as:    \"ab  c\"   (2 spaces to reach col 4)\n\"abc\\td\" displays as:   \"abc d\"   (1 space to reach col 4)\n\"abcd\\te\" displays as:  \"abcd    e\" (4 spaces to reach col 8)\n```\n\nWithout expansion, visual_width returns wrong values.\n\n## Implementation\n\n```rust\nfn expand_tabs(line: &str, tab_width: usize) -> String {\n    let mut result = String::with_capacity(line.len() * 2);\n    let mut col = 0;\n    \n    for c in line.chars() {\n        if c == '\\t' {\n            // Calculate spaces to next tab stop\n            let spaces = tab_width - (col % tab_width);\n            for _ in 0..spaces {\n                result.push(' ');\n            }\n            col += spaces;\n        } else {\n            result.push(c);\n            col += if c.is_ascii() { 1 } else if is_box_char(c) { 1 } else if c >= '\\u{1100}' { 2 } else { 1 };\n        }\n    }\n    \n    result\n}\n```\n\n**Location**: src/main.rs lines ~571-587\n\n## Tab Stop Calculation\n\nThe key formula: `spaces = tab_width - (col % tab_width)`\n\n| Current Column | tab_width=4 | Spaces Added |\n|----------------|-------------|--------------|\n| 0 | 4 - (0 % 4) = 4 | 4 |\n| 1 | 4 - (1 % 4) = 3 | 3 |\n| 2 | 4 - (2 % 4) = 2 | 2 |\n| 3 | 4 - (3 % 4) = 1 | 1 |\n| 4 | 4 - (4 % 4) = 4 | 4 |\n\n## When Expansion Occurs\n\nTab expansion is the FIRST step in the pipeline:\n\n```\nInput â†’ [TAB EXPANSION] â†’ Block Detection â†’ Correction â†’ Output\n         â†‘ Here\n```\n\nAll subsequent processing works with space-only content.\n\n## Configuration\n\nControlled by --tab-width CLI flag (default: 4):\n\n```bash\naadc --tab-width 2 file.txt   # For 2-space tabs\naadc --tab-width 8 file.txt   # For 8-space tabs (traditional Unix)\naadc -t 4 file.txt            # Short form\n```\n\n## CJK-Aware Column Tracking\n\nThe expansion tracks visual columns, not character count:\n\n```\n\"ä½ å¥½\\tä¸–ç•Œ\" with tab_width=4:\n- 'ä½ ' â†’ col=2 (CJK = 2 columns)\n- 'å¥½' â†’ col=4 (CJK = 2 columns)\n- '\\t' â†’ spaces = 4 - (4 % 4) = 4 â†’ col=8\n- 'ä¸–' â†’ col=10\n- 'ç•Œ' â†’ col=12\nResult: \"ä½ å¥½    ä¸–ç•Œ\"\n```\n\n## Considerations\n\n### Why Not Preserve Tabs?\n\nWe could try to preserve tabs and handle them specially:\n- Pro: Output matches input format\n- Con: Massively complicates all width calculations\n- Con: Tab semantics vary by editor/terminal\n- Decision: Expand and simplify\n\n### What About Tab Expansion Reversibility?\n\nOnce expanded, we can't reliably re-insert tabs:\n- We don't know which spaces were tabs\n- Different editors have different preferences\n- Decision: Accept spaces-only output\n\n### User Expectation\n\nMost users expect:\n1. Input with tabs â†’ Output with spaces\n2. Or they run through a formatter after\n\nFor \"preserve tabs\" users, we'd need a --preserve-tabs flag (future feature).\n\n## Edge Cases\n\n1. **Tab at start**: Full tab_width spaces\n2. **Multiple consecutive tabs**: Each reaches next tab stop\n3. **Tab after CJK**: Correctly accounts for 2-column chars\n4. **No tabs**: Pass through unchanged\n\n## Performance\n\n- O(n) where n = line length\n- Single allocation (String with capacity hint)\n- No regex or complex parsing\n\n## Test Coverage\n\n```rust\n#[test] fn test_expand_tabs_simple() { ... }\n#[test] fn test_expand_tabs_multiple() { ... }\n#[test] fn test_expand_tabs_position() { ... }\n#[test] fn test_expand_tabs_no_tabs() { ... }\n#[test] fn test_expand_tabs_width_8() { ... }\n```\n\n## Dependencies\n\n- Requires: CORE: Visual Width Calculation (for CJK tracking)\n- Used by: Main Pipeline (first step)\n- Configured by: CLI --tab-width flag","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-21T05:01:18.182564288Z","created_by":"ubuntu","updated_at":"2026-01-21T08:16:52.232838443Z","closed_at":"2026-01-21T08:16:52.232765165Z","close_reason":"done","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3j4","depends_on_id":"bd-1q9","type":"blocks","created_at":"2026-01-21T05:07:18.970835371Z","created_by":"ubuntu"}]}
{"id":"bd-3lo","title":"Add config file support (.aadcrc)","description":"# Config File Support (.aadcrc)\n\n## CLI Interface\n\n```rust\n#[derive(Parser, Debug)]\npub struct Config {\n    /// Path to config file (default: search for .aadcrc)\n    #[arg(long)]\n    pub config: Option<PathBuf>,\n\n    /// Ignore config files\n    #[arg(long)]\n    pub no_config: bool,\n\n    // ... other fields with #[serde(default)] for config file support\n}\n```\n\n**Usage:**\n```bash\naadc diagram.txt                    # Uses .aadcrc if found\naadc --config custom.toml diagram.txt  # Use specific config\naadc --no-config diagram.txt        # Ignore config files\naadc config init                    # Create default .aadcrc\naadc config show                    # Show effective config\n```\n\n## Config File Format\n\n### .aadcrc (TOML)\n\n```toml\n# aadc configuration file\n# Place in project root or home directory\n\n# Processing options\nmin_score = 0.5           # or use preset\npreset = \"normal\"         # strict | normal | aggressive | relaxed\nmax_iters = 10\ntab_width = 4\n\n# Output options\nverbose = false\ncolor = \"auto\"            # auto | always | never\njson = false\n\n# File handling\nbackup = false\nbackup_suffix = \".bak\"\n\n# Recursive mode defaults\nrecursive = false\nglob = \"*.txt,*.md\"\ngitignore = true\nmax_depth = 0\n\n# Watch mode\ndebounce_ms = 500\n\n# Advanced\nall = false               # Process low-confidence blocks\n```\n\n## Implementation\n\n### Config Search and Loading\n\n```rust\nuse std::path::{Path, PathBuf};\nuse serde::Deserialize;\n\nconst CONFIG_FILENAMES: &[&str] = &[\".aadcrc\", \".aadcrc.toml\", \"aadcrc.toml\"];\n\n#[derive(Debug, Deserialize, Default)]\n#[serde(default)]\npub struct FileConfig {\n    pub min_score: Option<f64>,\n    pub preset: Option<String>,\n    pub max_iters: Option<usize>,\n    pub tab_width: Option<usize>,\n    pub verbose: Option<bool>,\n    pub color: Option<String>,\n    pub json: Option<bool>,\n    pub backup: Option<bool>,\n    pub backup_suffix: Option<String>,\n    pub recursive: Option<bool>,\n    pub glob: Option<String>,\n    pub gitignore: Option<bool>,\n    pub max_depth: Option<usize>,\n    pub debounce_ms: Option<u64>,\n    pub all: Option<bool>,\n}\n\npub fn find_config_file(start_dir: &Path) -> Option<PathBuf> {\n    test_log!(\"DEBUG\", \"Searching for config file from: {:?}\", start_dir);\n\n    let mut current = start_dir.to_path_buf();\n\n    // Search up directory tree\n    loop {\n        for filename in CONFIG_FILENAMES {\n            let config_path = current.join(filename);\n            if config_path.exists() {\n                test_log!(\"INFO\", \"Found config file: {:?}\", config_path);\n                return Some(config_path);\n            }\n        }\n\n        if !current.pop() {\n            break;\n        }\n    }\n\n    // Check home directory\n    if let Some(home) = dirs::home_dir() {\n        for filename in CONFIG_FILENAMES {\n            let config_path = home.join(filename);\n            if config_path.exists() {\n                test_log!(\"INFO\", \"Found config file in home: {:?}\", config_path);\n                return Some(config_path);\n            }\n        }\n    }\n\n    test_log!(\"DEBUG\", \"No config file found\");\n    None\n}\n\npub fn load_config_file(path: &Path) -> Result<FileConfig, Error> {\n    test_log!(\"INFO\", \"Loading config from: {:?}\", path);\n\n    let content = std::fs::read_to_string(path)?;\n    let config: FileConfig = toml::from_str(&content)\n        .map_err(|e| Error::ConfigParse(format!(\"Invalid TOML: {}\", e)))?;\n\n    test_log!(\"DEBUG\", \"Loaded config: {:?}\", config);\n    Ok(config)\n}\n```\n\n### Config Merging (CLI overrides file)\n\n```rust\nimpl Config {\n    pub fn with_file_config(mut self, file_config: FileConfig) -> Self {\n        test_log!(\"DEBUG\", \"Merging file config with CLI args\");\n\n        // Only apply file config values if CLI didn't override\n        if self.min_score_from_cli.is_none() {\n            if let Some(score) = file_config.min_score {\n                self.min_score = score;\n            }\n            if let Some(preset) = file_config.preset {\n                self.preset = Some(preset.parse().ok()?);\n            }\n        }\n\n        if self.max_iters_from_cli.is_none() {\n            if let Some(iters) = file_config.max_iters {\n                self.max_iters = iters;\n            }\n        }\n\n        if self.tab_width_from_cli.is_none() {\n            if let Some(width) = file_config.tab_width {\n                self.tab_width = width;\n            }\n        }\n\n        // Boolean flags: CLI explicit value overrides file\n        if !self.verbose_from_cli {\n            self.verbose = file_config.verbose.unwrap_or(self.verbose);\n        }\n\n        if !self.backup_from_cli {\n            self.backup = file_config.backup.unwrap_or(self.backup);\n        }\n\n        if self.backup_suffix_from_cli.is_none() {\n            if let Some(suffix) = file_config.backup_suffix {\n                self.backup_suffix = suffix;\n            }\n        }\n\n        // Recursive mode options\n        if !self.recursive_from_cli {\n            self.recursive = file_config.recursive.unwrap_or(self.recursive);\n        }\n\n        if self.glob_from_cli.is_none() {\n            if let Some(glob) = file_config.glob {\n                self.glob = glob;\n            }\n        }\n\n        // ... continue for other options\n\n        test_log!(\"DEBUG\", \"Merged config: {:?}\", self);\n        self\n    }\n}\n```\n\n### Config Subcommand\n\n```rust\n#[derive(Subcommand, Debug)]\npub enum ConfigCommand {\n    /// Initialize a new .aadcrc file\n    Init {\n        /// Create in home directory instead of current\n        #[arg(long)]\n        global: bool,\n    },\n    /// Show effective configuration\n    Show,\n    /// Show config file path\n    Path,\n}\n\npub fn run_config_command(cmd: &ConfigCommand) -> Result<(), Error> {\n    match cmd {\n        ConfigCommand::Init { global } => {\n            let path = if *global {\n                dirs::home_dir()\n                    .ok_or(Error::NoHomeDir)?\n                    .join(\".aadcrc\")\n            } else {\n                PathBuf::from(\".aadcrc\")\n            };\n\n            if path.exists() {\n                return Err(Error::ConfigExists(path));\n            }\n\n            let default_config = include_str!(\"default_config.toml\");\n            std::fs::write(&path, default_config)?;\n            eprintln!(\"Created config file: {}\", path.display());\n            Ok(())\n        }\n\n        ConfigCommand::Show => {\n            let config = Config::load_effective()?;\n            eprintln!(\"Effective configuration:\");\n            eprintln!(\"{}\", toml::to_string_pretty(&config)?);\n            Ok(())\n        }\n\n        ConfigCommand::Path => {\n            if let Some(path) = find_config_file(&std::env::current_dir()?) {\n                println!(\"{}\", path.display());\n            } else {\n                eprintln!(\"No config file found\");\n                std::process::exit(1);\n            }\n            Ok(())\n        }\n    }\n}\n```\n\n### Default Config Template\n\n```toml\n# .aadcrc - aadc configuration file\n# https://github.com/Dicklesworthstone/aadc\n\n# Confidence threshold for applying edits\n# Use either min_score (0.0-1.0) or preset (strict|normal|aggressive|relaxed)\n# preset = \"normal\"\nmin_score = 0.5\n\n# Maximum correction iterations per block\nmax_iters = 10\n\n# Tab expansion width\ntab_width = 4\n\n# Output options\n# verbose = false\n# color = \"auto\"  # auto | always | never\n# json = false\n\n# Backup options (for --in-place)\n# backup = false\n# backup_suffix = \".bak\"\n\n# Recursive mode defaults\n# recursive = false\n# glob = \"*.txt,*.md\"\n# gitignore = true\n# max_depth = 0\n\n# Watch mode debounce (milliseconds)\n# debounce_ms = 500\n\n# Force processing of low-confidence blocks\n# all = false\n```\n\n## Edge Cases\n\n1. **Invalid TOML syntax**: Clear error message with line number\n2. **Unknown keys**: Warn but don't fail (forward compatibility)\n3. **Type mismatches**: Clear error about expected type\n4. **Conflicting options**: CLI always wins\n5. **Circular includes**: Not supported (no include directive)\n6. **Permission denied**: Graceful fallback to defaults\n\n## Unit Tests\n\n```rust\n#[cfg(test)]\nmod config_tests {\n    use super::*;\n    use tempfile::TempDir;\n\n    #[test]\n    fn test_config_file_search() {\n        test_log!(\"INFO\", \"Testing config file search\");\n\n        let tmpdir = TempDir::new().unwrap();\n        let config_path = tmpdir.path().join(\".aadcrc\");\n        std::fs::write(&config_path, \"min_score = 0.7\\n\").unwrap();\n\n        let found = find_config_file(tmpdir.path());\n        assert!(found.is_some());\n        assert_eq!(found.unwrap(), config_path);\n\n        test_log!(\"PASS\", \"Config file found âœ“\");\n    }\n\n    #[test]\n    fn test_config_parsing() {\n        test_log!(\"INFO\", \"Testing config parsing\");\n\n        let config_str = r#\"\nmin_score = 0.8\nmax_iters = 20\npreset = \"strict\"\nverbose = true\nglob = \"*.md\"\n\"#;\n\n        let config: FileConfig = toml::from_str(config_str).unwrap();\n        assert_eq!(config.min_score, Some(0.8));\n        assert_eq!(config.max_iters, Some(20));\n        assert_eq!(config.preset, Some(\"strict\".to_string()));\n        assert_eq!(config.verbose, Some(true));\n\n        test_log!(\"PASS\", \"Config parsed correctly âœ“\");\n    }\n\n    #[test]\n    fn test_cli_overrides_file() {\n        test_log!(\"INFO\", \"Testing CLI overrides file config\");\n\n        let file_config = FileConfig {\n            min_score: Some(0.3),\n            verbose: Some(true),\n            ..Default::default()\n        };\n\n        let mut cli_config = Config::default();\n        cli_config.min_score = 0.8;\n        cli_config.min_score_from_cli = Some(true);  // Mark as CLI-provided\n\n        let merged = cli_config.with_file_config(file_config);\n        assert_eq!(merged.min_score, 0.8);  // CLI wins\n\n        test_log!(\"PASS\", \"CLI override works âœ“\");\n    }\n\n    #[test]\n    fn test_invalid_config_error() {\n        test_log!(\"INFO\", \"Testing invalid config error handling\");\n\n        let bad_config = \"min_score = \\\"not a number\\\"\";\n        let result: Result<FileConfig, _> = toml::from_str(bad_config);\n\n        assert!(result.is_err());\n\n        test_log!(\"PASS\", \"Invalid config rejected âœ“\");\n    }\n\n    #[test]\n    fn test_unknown_keys_tolerated() {\n        test_log!(\"INFO\", \"Testing unknown keys are tolerated\");\n\n        let config_str = r#\"\nmin_score = 0.5\nfuture_option = \"ignored\"\n\"#;\n\n        // Should parse without error\n        let config: FileConfig = toml::from_str(config_str).unwrap();\n        assert_eq!(config.min_score, Some(0.5));\n\n        test_log!(\"PASS\", \"Unknown keys tolerated âœ“\");\n    }\n}\n```\n\n## E2E Tests\n\n```bash\n#!/bin/bash\n# tests/e2e_config_file.sh\n\nset -e\nsource \"$(dirname \"$0\")/e2e_runner.sh\"\n\ntest_config_file_applied() {\n    log_test_start \"config_file_applied\"\n\n    local tmpdir=$(mktemp -d)\n\n    # Create config with strict preset\n    cat > \"$tmpdir/.aadcrc\" << 'EOF'\npreset = \"strict\"\nverbose = true\nEOF\n\n    create_misaligned_diagram \"$tmpdir/diagram.txt\"\n\n    log_debug \"Running with config file\"\n    cd \"$tmpdir\"\n    local output=$(aadc diagram.txt 2>&1)\n\n    echo \"$output\" | grep -qi \"strict\\|0.8\" && \\\n        log_pass \"Config file applied\" || \\\n        log_fail \"Config file not applied\"\n}\n\ntest_cli_overrides_config() {\n    log_test_start \"cli_overrides_config\"\n\n    local tmpdir=$(mktemp -d)\n\n    # Config says strict\n    cat > \"$tmpdir/.aadcrc\" << 'EOF'\npreset = \"strict\"\nEOF\n\n    create_misaligned_diagram \"$tmpdir/diagram.txt\"\n\n    log_debug \"Running with --preset aggressive (should override)\"\n    cd \"$tmpdir\"\n    local output=$(aadc -v --preset aggressive diagram.txt 2>&1)\n\n    echo \"$output\" | grep -qi \"aggressive\\|0.3\" && \\\n        log_pass \"CLI override works\" || \\\n        log_fail \"CLI did not override config\"\n}\n\ntest_no_config_flag() {\n    log_test_start \"no_config_flag\"\n\n    local tmpdir=$(mktemp -d)\n\n    # Config says verbose\n    cat > \"$tmpdir/.aadcrc\" << 'EOF'\nverbose = true\nEOF\n\n    create_misaligned_diagram \"$tmpdir/diagram.txt\"\n\n    log_debug \"Running with --no-config\"\n    cd \"$tmpdir\"\n    local output=$(aadc --no-config diagram.txt 2>&1)\n\n    # Should not be verbose (config ignored)\n    if echo \"$output\" | grep -q \"Processing\\|Block\"; then\n        log_fail \"--no-config did not ignore config\"\n    else\n        log_pass \"--no-config works\"\n    fi\n}\n\ntest_config_init() {\n    log_test_start \"config_init\"\n\n    local tmpdir=$(mktemp -d)\n    cd \"$tmpdir\"\n\n    log_debug \"Running config init\"\n    aadc config init\n\n    [[ -f \".aadcrc\" ]] && \\\n        log_pass \"Config file created\" || \\\n        log_fail \"Config file not created\"\n\n    grep -q \"min_score\" .aadcrc && \\\n        log_pass \"Config has expected content\" || \\\n        log_fail \"Config missing expected content\"\n}\n\nrun_tests test_config_file_applied test_cli_overrides_config test_no_config_flag test_config_init\n```\n\n## Documentation Updates\n\nREADME.md section:\n```markdown\n### Configuration File\n\nCreate a `.aadcrc` file in your project or home directory:\n\n```bash\n# Initialize config in current directory\naadc config init\n\n# Initialize global config\naadc config init --global\n\n# Show effective configuration\naadc config show\n```\n\nExample `.aadcrc`:\n\n```toml\n# Use strict mode for production docs\npreset = \"strict\"\n\n# Always create backups\nbackup = true\nbackup_suffix = \".orig\"\n\n# Default recursive glob pattern\nglob = \"*.md,*.txt,*.rst\"\n```\n\nConfig is searched in order:\n1. `--config <path>` if specified\n2. `.aadcrc` in current directory\n3. `.aadcrc` in parent directories (up to root)\n4. `~/.aadcrc` in home directory\n\nCLI flags always override config file settings.\n```\n\n## Success Criteria\n\n- [ ] .aadcrc file found via directory tree search\n- [ ] TOML format parsed correctly\n- [ ] CLI flags override config file values\n- [ ] --no-config ignores config files\n- [ ] --config specifies custom config path\n- [ ] `aadc config init` creates default config\n- [ ] `aadc config show` displays effective config\n- [ ] Invalid config produces helpful error\n- [ ] Unknown keys tolerated for forward compatibility\n- [ ] Unit tests pass\n- [ ] E2E tests validate config behavior","status":"in_progress","priority":3,"issue_type":"feature","created_at":"2026-01-21T02:00:55.228350732Z","created_by":"ubuntu","updated_at":"2026-01-21T18:49:49.058474267Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3lo","depends_on_id":"bd-1ih","type":"blocks","created_at":"2026-01-21T02:01:36.392559146Z","created_by":"ubuntu"},{"issue_id":"bd-3lo","depends_on_id":"bd-26l","type":"blocks","created_at":"2026-01-21T02:01:44.778448619Z","created_by":"ubuntu"},{"issue_id":"bd-3lo","depends_on_id":"bd-32l","type":"blocks","created_at":"2026-01-21T05:07:46.844458371Z","created_by":"ubuntu"}]}
{"id":"bd-3tf","title":"Add --backup flag for in-place safety","description":"## Purpose\nAdd a `--backup` flag that creates a backup copy of the original file before in-place editing. This is a critical safety feature that users expect from any file-modifying tool.\n\n## CLI Interface\n\n```bash\n# Create backup before in-place edit\naadc -i --backup file.txt\n# Creates: file.txt.bak, then edits file.txt\n\n# With custom backup extension\naadc -i --backup --backup-ext .orig file.txt\n# Creates: file.txt.orig\n\n# Default: only with -i flag\naadc --backup file.txt  # Error: --backup requires --in-place\n```\n\n## Implementation\n\n### Argument Definition (clap)\n```rust\n#[derive(Parser, Debug)]\npub struct Config {\n    // ... existing args ...\n    \n    /// Create backup file before in-place editing\n    /// \n    /// Creates a copy of the original file with .bak extension\n    /// before making any changes. Only valid with --in-place.\n    #[arg(long, requires = \"in_place\")]\n    pub backup: bool,\n    \n    /// Backup file extension (default: .bak)\n    #[arg(long, default_value = \".bak\", requires = \"backup\")]\n    pub backup_ext: String,\n}\n```\n\n### Backup Logic\n```rust\nfn create_backup(path: &Path, ext: &str) -> anyhow::Result<PathBuf> {\n    let backup_path = path.with_extension(\n        format!(\"{}{}\", \n            path.extension().map(|e| e.to_str().unwrap_or(\"\")).unwrap_or(\"\"),\n            ext\n        )\n    );\n    \n    // More robust: append extension rather than replace\n    let mut backup_name = path.as_os_str().to_owned();\n    backup_name.push(ext);\n    let backup_path = PathBuf::from(backup_name);\n    \n    fs::copy(path, &backup_path)\n        .with_context(|| format!(\n            \"Failed to create backup at {}\",\n            backup_path.display()\n        ))?;\n    \n    Ok(backup_path)\n}\n```\n\n### Integration Point\n```rust\nfn process_file(path: &Path, config: &Config) -> anyhow::Result<()> {\n    // Create backup BEFORE reading (to preserve exact original)\n    if config.in_place && config.backup {\n        let backup = create_backup(path, &config.backup_ext)?;\n        if config.verbose {\n            eprintln!(\"Created backup: {}\", backup.display());\n        }\n    }\n    \n    let content = fs::read_to_string(path)?;\n    let result = process_content(&content, config)?;\n    \n    if config.in_place {\n        fs::write(path, &result)?;\n    } else {\n        print!(\"{}\", result);\n    }\n    \n    Ok(())\n}\n```\n\n## Edge Cases\n\n### 1. Backup Already Exists\n```rust\n// Option A: Overwrite (current approach)\nfs::copy(path, &backup_path)?;\n\n// Option B: Numbered backups (future enhancement)\n// file.txt.bak, file.txt.bak.1, file.txt.bak.2, etc.\n```\n\n### 2. No Permission to Create Backup\n```\nError: Failed to create backup at /path/file.txt.bak: Permission denied\nHint: Ensure write permission in the directory\n```\n\n### 3. Disk Full\n```\nError: Failed to create backup at /path/file.txt.bak: No space left on device\n```\n\n### 4. Network/Remote Filesystems\n- Use atomic copy where possible\n- Consider temp file approach for better reliability\n\n## Test Cases\n\n### Unit Tests\n```rust\n#[test]\nfn test_backup_creates_file() {\n    let temp = tempfile::tempdir().unwrap();\n    let file = temp.path().join(\"test.txt\");\n    fs::write(&file, \"original\").unwrap();\n    \n    create_backup(&file, \".bak\").unwrap();\n    \n    let backup = temp.path().join(\"test.txt.bak\");\n    assert!(backup.exists());\n    assert_eq!(fs::read_to_string(&backup).unwrap(), \"original\");\n}\n\n#[test]\nfn test_backup_preserves_extension() {\n    let temp = tempfile::tempdir().unwrap();\n    let file = temp.path().join(\"diagram.md\");\n    fs::write(&file, \"content\").unwrap();\n    \n    let backup = create_backup(&file, \".bak\").unwrap();\n    \n    // Should be diagram.md.bak, not diagram.bak\n    assert_eq!(backup.file_name().unwrap(), \"diagram.md.bak\");\n}\n\n#[test]\nfn test_backup_custom_extension() {\n    let temp = tempfile::tempdir().unwrap();\n    let file = temp.path().join(\"test.txt\");\n    fs::write(&file, \"content\").unwrap();\n    \n    let backup = create_backup(&file, \".orig\").unwrap();\n    \n    assert!(backup.to_str().unwrap().ends_with(\".orig\"));\n}\n```\n\n### E2E Tests\n```bash\n# Test backup creation\nsetup() {\n    TEMP=$(mktemp -d)\n    echo \"original content\" > \"$TEMP/test.txt\"\n}\n\ntest_backup_created() {\n    aadc -i --backup \"$TEMP/test.txt\"\n    [[ -f \"$TEMP/test.txt.bak\" ]] || fail \"Backup not created\"\n    [[ \"$(cat \"$TEMP/test.txt.bak\")\" == \"original content\" ]] || fail \"Backup content wrong\"\n}\n\ntest_backup_requires_inplace() {\n    aadc --backup \"$TEMP/test.txt\" 2>&1 | grep -q \"requires --in-place\" || fail \"Should require -i\"\n}\n```\n\n## Documentation Updates\n\n### README\nAdd to Command Reference:\n\n| Option | Short | Default | Description |\n|--------|-------|---------|-------------|\n| `--backup` | | false | Create backup file before in-place editing |\n| `--backup-ext` | | .bak | Extension for backup files |\n\n### Help Text\n```\n--backup\n    Create backup file before in-place editing.\n    Creates file.bak before modifying the original.\n    Requires --in-place.\n\n--backup-ext <EXT>\n    Extension for backup files [default: .bak]\n    Requires --backup.\n```\n\n## Success Criteria\n- [ ] --backup flag creates .bak file before edit\n- [ ] --backup-ext allows custom extension\n- [ ] Backup contains exact original content\n- [ ] Error if backup creation fails\n- [ ] Verbose mode shows backup path\n- [ ] Unit tests pass\n- [ ] E2E tests pass\n- [ ] README updated\n\n## Dependencies\n- Requires: CORE: Iterative Correction Loop (bd-apa)\n- Belongs to: Feature Improvements Epic (bd-1ih)","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-21T02:00:53.154976375Z","created_by":"ubuntu","updated_at":"2026-01-21T09:12:46.048099242Z","closed_at":"2026-01-21T09:12:46.048054598Z","close_reason":"done","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3tf","depends_on_id":"bd-1ih","type":"blocks","created_at":"2026-01-21T02:01:36.113469935Z","created_by":"ubuntu"},{"issue_id":"bd-3tf","depends_on_id":"bd-apa","type":"blocks","created_at":"2026-01-21T05:07:43.180535444Z","created_by":"ubuntu"}]}
{"id":"bd-3uw","title":"Add --lines flag for range processing","description":"# --lines Flag for Range Processing\n\n## CLI Interface\n\n```rust\n#[derive(Parser, Debug)]\npub struct Config {\n    /// Process only specific line ranges (e.g., \"10-50\", \"1-100,200-250\")\n    #[arg(long, short = 'L', value_parser = parse_line_ranges)]\n    pub lines: Option<Vec<LineRange>>,\n}\n\n#[derive(Debug, Clone)]\npub struct LineRange {\n    pub start: usize,  // 1-indexed, inclusive\n    pub end: usize,    // 1-indexed, inclusive\n}\n```\n\n**Usage:**\n```bash\naadc --lines 10-50 diagram.txt         # Process only lines 10-50\naadc -L 1-100 diagram.txt              # First 100 lines\naadc --lines 10-50,100-150 diagram.txt # Multiple ranges\naadc --lines 50- diagram.txt           # Line 50 to end\naadc --lines -100 diagram.txt          # First 100 lines\n```\n\n## Implementation\n\n### Line Range Parsing\n\n```rust\nuse std::str::FromStr;\n\nfn parse_line_ranges(s: &str) -> Result<Vec<LineRange>, String> {\n    test_log!(\"DEBUG\", \"Parsing line ranges: {}\", s);\n\n    let mut ranges = Vec::new();\n\n    for part in s.split(',') {\n        let part = part.trim();\n        let range = parse_single_range(part)?;\n        ranges.push(range);\n    }\n\n    // Sort and merge overlapping ranges\n    ranges.sort_by_key(|r| r.start);\n    let merged = merge_ranges(ranges);\n\n    test_log!(\"DEBUG\", \"Parsed ranges: {:?}\", merged);\n    Ok(merged)\n}\n\nfn parse_single_range(s: &str) -> Result<LineRange, String> {\n    if s.contains('-') {\n        let parts: Vec<&str> = s.splitn(2, '-').collect();\n\n        let start = if parts[0].is_empty() {\n            1  // \"-100\" means \"1-100\"\n        } else {\n            parts[0].parse::<usize>()\n                .map_err(|_| format!(\"Invalid start line: {}\", parts[0]))?\n        };\n\n        let end = if parts.len() < 2 || parts[1].is_empty() {\n            usize::MAX  // \"50-\" means \"50 to end\"\n        } else {\n            parts[1].parse::<usize>()\n                .map_err(|_| format!(\"Invalid end line: {}\", parts[1]))?\n        };\n\n        if start > end && end != usize::MAX {\n            return Err(format!(\"Invalid range: start ({}) > end ({})\", start, end));\n        }\n\n        Ok(LineRange { start, end })\n    } else {\n        // Single line number\n        let line = s.parse::<usize>()\n            .map_err(|_| format!(\"Invalid line number: {}\", s))?;\n        Ok(LineRange { start: line, end: line })\n    }\n}\n\nfn merge_ranges(ranges: Vec<LineRange>) -> Vec<LineRange> {\n    if ranges.is_empty() {\n        return ranges;\n    }\n\n    let mut merged = Vec::new();\n    let mut current = ranges[0].clone();\n\n    for range in ranges.into_iter().skip(1) {\n        if range.start <= current.end + 1 {\n            // Overlapping or adjacent, merge\n            current.end = current.end.max(range.end);\n        } else {\n            merged.push(current);\n            current = range;\n        }\n    }\n    merged.push(current);\n\n    merged\n}\n```\n\n### Selective Processing\n\n```rust\npub fn process_with_line_ranges(\n    config: &Config,\n    input: &str,\n) -> (String, ProcessingStats) {\n    test_log!(\"INFO\", \"Processing with line ranges: {:?}\", config.lines);\n\n    let lines: Vec<&str> = input.lines().collect();\n    let total_lines = lines.len();\n\n    // Determine which lines to process\n    let process_mask = if let Some(ref ranges) = config.lines {\n        let mut mask = vec![false; total_lines];\n        for range in ranges {\n            let start = range.start.saturating_sub(1);  // Convert to 0-indexed\n            let end = range.end.min(total_lines);\n            for i in start..end {\n                mask[i] = true;\n            }\n        }\n        mask\n    } else {\n        vec![true; total_lines]  // Process all\n    };\n\n    test_log!(\"DEBUG\", \"Process mask: {} lines marked for processing\",\n        process_mask.iter().filter(|&&b| b).count());\n\n    // Detect blocks only in marked regions\n    let blocks = detect_blocks_with_mask(&lines, &process_mask);\n\n    let mut output_lines: Vec<String> = lines.iter().map(|s| s.to_string()).collect();\n    let mut stats = ProcessingStats::new();\n    stats.total_lines = total_lines;\n\n    for block in blocks {\n        // Only process if block overlaps with ranges\n        let block_in_range = (block.start..block.end).any(|i| process_mask.get(i).copied().unwrap_or(false));\n\n        if !block_in_range {\n            test_log!(\"DEBUG\", \"Skipping block at lines {}-{}: outside requested range\", block.start + 1, block.end + 1);\n            stats.blocks_skipped += 1;\n            continue;\n        }\n\n        stats.blocks_found += 1;\n\n        if block.confidence < config.effective_min_score() {\n            stats.blocks_skipped += 1;\n            continue;\n        }\n\n        stats.blocks_processed += 1;\n\n        let (revised, revisions, skipped) = correct_block(config, &block, &output_lines);\n        stats.revisions_applied += revisions;\n        stats.revisions_skipped += skipped;\n\n        for (i, line) in revised.iter().enumerate() {\n            if block.start + i < output_lines.len() {\n                output_lines[block.start + i] = line.clone();\n            }\n        }\n    }\n\n    (output_lines.join(\"\\n\"), stats)\n}\n```\n\n### Verbose Output for Range Processing\n\n```rust\npub fn print_range_info(config: &Config, total_lines: usize, colors: &VerboseColors) {\n    if let Some(ref ranges) = config.lines {\n        let covered: usize = ranges.iter()\n            .map(|r| r.end.min(total_lines).saturating_sub(r.start.saturating_sub(1)))\n            .sum();\n\n        let range_strs: Vec<String> = ranges.iter()\n            .map(|r| {\n                if r.end == usize::MAX {\n                    format!(\"{}-\", r.start)\n                } else if r.start == r.end {\n                    format!(\"{}\", r.start)\n                } else {\n                    format!(\"{}-{}\", r.start, r.end)\n                }\n            })\n            .collect();\n\n        eprintln!(\n            \"{}Line ranges:{} {} ({} of {} lines)\",\n            colors.header.render_str(\"\"),\n            Style::reset(),\n            range_strs.join(\", \"),\n            covered,\n            total_lines\n        );\n    }\n}\n```\n\n## Edge Cases\n\n1. **Range exceeds file length**: Clamp to actual file length\n2. **Overlapping ranges**: Merge automatically\n3. **Single line**: \"42\" means just line 42\n4. **Open-ended ranges**: \"50-\" or \"-100\" supported\n5. **Zero or negative**: Error with helpful message\n6. **Empty ranges**: Process nothing, output unchanged\n\n## Unit Tests\n\n```rust\n#[cfg(test)]\nmod line_range_tests {\n    use super::*;\n\n    #[test]\n    fn test_parse_simple_range() {\n        test_log!(\"INFO\", \"Testing simple range parsing\");\n\n        let ranges = parse_line_ranges(\"10-50\").unwrap();\n        assert_eq!(ranges.len(), 1);\n        assert_eq!(ranges[0].start, 10);\n        assert_eq!(ranges[0].end, 50);\n\n        test_log!(\"PASS\", \"Simple range parsed âœ“\");\n    }\n\n    #[test]\n    fn test_parse_multiple_ranges() {\n        test_log!(\"INFO\", \"Testing multiple range parsing\");\n\n        let ranges = parse_line_ranges(\"1-10, 20-30, 50-60\").unwrap();\n        assert_eq!(ranges.len(), 3);\n\n        test_log!(\"PASS\", \"Multiple ranges parsed âœ“\");\n    }\n\n    #[test]\n    fn test_parse_open_ended_ranges() {\n        test_log!(\"INFO\", \"Testing open-ended ranges\");\n\n        let start_only = parse_line_ranges(\"50-\").unwrap();\n        assert_eq!(start_only[0].start, 50);\n        assert_eq!(start_only[0].end, usize::MAX);\n\n        let end_only = parse_line_ranges(\"-100\").unwrap();\n        assert_eq!(end_only[0].start, 1);\n        assert_eq!(end_only[0].end, 100);\n\n        test_log!(\"PASS\", \"Open-ended ranges parsed âœ“\");\n    }\n\n    #[test]\n    fn test_parse_single_line() {\n        test_log!(\"INFO\", \"Testing single line number\");\n\n        let ranges = parse_line_ranges(\"42\").unwrap();\n        assert_eq!(ranges.len(), 1);\n        assert_eq!(ranges[0].start, 42);\n        assert_eq!(ranges[0].end, 42);\n\n        test_log!(\"PASS\", \"Single line parsed âœ“\");\n    }\n\n    #[test]\n    fn test_merge_overlapping_ranges() {\n        test_log!(\"INFO\", \"Testing overlapping range merge\");\n\n        let ranges = parse_line_ranges(\"1-50, 40-100\").unwrap();\n        assert_eq!(ranges.len(), 1);\n        assert_eq!(ranges[0].start, 1);\n        assert_eq!(ranges[0].end, 100);\n\n        test_log!(\"PASS\", \"Overlapping ranges merged âœ“\");\n    }\n\n    #[test]\n    fn test_invalid_range_error() {\n        test_log!(\"INFO\", \"Testing invalid range error\");\n\n        let result = parse_line_ranges(\"50-10\");\n        assert!(result.is_err());\n\n        let result = parse_line_ranges(\"abc\");\n        assert!(result.is_err());\n\n        test_log!(\"PASS\", \"Invalid ranges rejected âœ“\");\n    }\n\n    #[test]\n    fn test_process_with_ranges() {\n        test_log!(\"INFO\", \"Testing processing with line ranges\");\n\n        let input = r#\"Line 1\n+------+\n| Test|\n+------+\nLine 5\n+------+\n| More|\n+------+\nLine 9\"#;\n\n        let mut config = Config::default();\n        config.lines = Some(vec![LineRange { start: 2, end: 4 }]);\n\n        let (output, stats) = process_with_line_ranges(&config, input);\n\n        // Only first diagram should be processed\n        assert!(output.contains(\"| Test  |\"));  // Corrected\n        assert!(output.contains(\"| More|\"));    // Not corrected (outside range)\n\n        test_log!(\"PASS\", \"Range processing works âœ“\");\n    }\n}\n```\n\n## E2E Tests\n\n```bash\n#!/bin/bash\n# tests/e2e_line_ranges.sh\n\nset -e\nsource \"$(dirname \"$0\")/e2e_runner.sh\"\n\ntest_line_range_basic() {\n    log_test_start \"line_range_basic\"\n\n    local tmpdir=$(mktemp -d)\n    cat > \"$tmpdir/diagram.txt\" << 'EOF'\nLine 1 - prose\nLine 2 - prose\n+------+\n| Hi|\n+------+\nLine 6 - prose\nLine 7 - prose\n+------+\n| Lo|\n+------+\nEOF\n\n    log_debug \"Processing only lines 3-5\"\n    local output=$(aadc --lines 3-5 \"$tmpdir/diagram.txt\")\n\n    # First diagram should be corrected\n    echo \"$output\" | grep -q \"| Hi   |\" && \\\n        log_pass \"First diagram corrected\" || \\\n        log_fail \"First diagram not corrected\"\n\n    # Second diagram should NOT be corrected (outside range)\n    echo \"$output\" | grep -q \"| Lo|\" && \\\n        log_pass \"Second diagram unchanged\" || \\\n        log_fail \"Second diagram was incorrectly modified\"\n}\n\ntest_multiple_ranges() {\n    log_test_start \"multiple_ranges\"\n\n    local tmpdir=$(mktemp -d)\n    # Generate file with diagrams at lines 10, 50, 100\n    for i in $(seq 1 120); do\n        if [[ $i -eq 10 || $i -eq 50 || $i -eq 100 ]]; then\n            echo \"+--+\"\n            echo \"|X|\"\n            echo \"+--+\"\n        else\n            echo \"Line $i prose\"\n        fi\n    done > \"$tmpdir/multi.txt\"\n\n    log_debug \"Processing ranges 8-14 and 98-104\"\n    local output=$(aadc -v --lines \"8-14,98-104\" \"$tmpdir/multi.txt\" 2>&1)\n\n    echo \"$output\" | grep -q \"Line ranges:\" && \\\n        log_pass \"Range info shown\" || \\\n        log_fail \"Range info missing\"\n}\n\ntest_open_ended_range() {\n    log_test_start \"open_ended_range\"\n\n    local tmpdir=$(mktemp -d)\n    for i in $(seq 1 50); do\n        echo \"Line $i\"\n    done > \"$tmpdir/lines.txt\"\n    echo \"+--+\" >> \"$tmpdir/lines.txt\"\n    echo \"|X|\" >> \"$tmpdir/lines.txt\"\n    echo \"+--+\" >> \"$tmpdir/lines.txt\"\n\n    log_debug \"Processing from line 50 onwards\"\n    local output=$(aadc --lines \"50-\" \"$tmpdir/lines.txt\")\n\n    echo \"$output\" | grep -q \"| X |\" && \\\n        log_pass \"Open-ended range works\" || \\\n        log_fail \"Open-ended range failed\"\n}\n\nrun_tests test_line_range_basic test_multiple_ranges test_open_ended_range\n```\n\n## Documentation Updates\n\nREADME.md section:\n```markdown\n### Line Range Processing\n\nProcess only specific portions of a file:\n\n```bash\n# Process lines 10-50 only\naadc --lines 10-50 diagram.txt\n\n# Multiple ranges\naadc --lines 10-50,100-150 diagram.txt\n\n# From line 100 to end\naadc --lines 100- diagram.txt\n\n# First 50 lines\naadc --lines -50 diagram.txt\n\n# Single line (useful for debugging)\naadc --lines 42 diagram.txt\n```\n\nThis is useful for:\n- Large files where you know diagram locations\n- Avoiding processing of sensitive sections\n- Debugging specific diagrams\n```\n\n## Success Criteria\n\n- [ ] --lines/-L flag accepts range specifications\n- [ ] Single ranges (10-50) work\n- [ ] Multiple ranges (10-50,100-150) work\n- [ ] Open-ended ranges (50-, -100) work\n- [ ] Single line numbers work\n- [ ] Overlapping ranges merged automatically\n- [ ] Invalid ranges produce helpful errors\n- [ ] Only diagrams within ranges are processed\n- [ ] Content outside ranges passes through unchanged\n- [ ] Verbose mode shows range information\n- [ ] Unit tests pass\n- [ ] E2E tests validate range behavior","status":"closed","priority":3,"issue_type":"feature","created_at":"2026-01-21T02:00:59.855830727Z","created_by":"ubuntu","updated_at":"2026-01-21T21:26:45.160439015Z","closed_at":"2026-01-21T21:26:45.160368743Z","close_reason":"Implemented --lines/-L flag for range processing with all unit tests passing","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3uw","depends_on_id":"bd-1ih","type":"blocks","created_at":"2026-01-21T02:01:36.945826389Z","created_by":"ubuntu"},{"issue_id":"bd-3uw","depends_on_id":"bd-apa","type":"blocks","created_at":"2026-01-21T05:07:46.127855670Z","created_by":"ubuntu"}]}
{"id":"bd-5jn","title":"Add multiple file support","description":"## Purpose\nAdd support for processing multiple files in a single invocation. Essential for batch processing and common use patterns.\n\n## CLI Interface\n\n```bash\n# Multiple explicit files\naadc file1.txt file2.txt file3.txt\n\n# With glob (shell expands)\naadc docs/*.md\n\n# With in-place editing\naadc -i file1.txt file2.txt\n\n# Mixed with other flags\naadc -i -v --min-score 0.3 docs/*.md\n\n# From find/xargs\nfind . -name \"*.md\" | xargs aadc -i\n```\n\n## Implementation\n\n### Argument Definition (clap)\n```rust\n#[derive(Parser, Debug)]\npub struct Config {\n    /// Input files. Reads from stdin if not provided.\n    #[arg(value_name = \"FILE\")]\n    pub files: Vec<PathBuf>,\n    \n    // ... other args ...\n}\n```\n\n### Processing Loop\n```rust\nfn run(config: &Config) -> anyhow::Result<RunResult> {\n    let console = Console::new();\n    \n    if config.files.is_empty() {\n        // Stdin mode\n        let content = read_stdin()?;\n        let result = process_content(&content, config)?;\n        print!(\"{}\", result.output);\n        return Ok(RunResult::single(result));\n    }\n    \n    // Multi-file mode\n    let mut results = Vec::new();\n    let mut errors = Vec::new();\n    \n    for path in &config.files {\n        match process_file(path, config, &console) {\n            Ok(result) => results.push((path.clone(), result)),\n            Err(e) => {\n                errors.push((path.clone(), e));\n                if config.verbose {\n                    eprintln!(\"[red]Error processing {}:[/] {}\", path.display(), e);\n                }\n            }\n        }\n    }\n    \n    // Summary in verbose mode\n    if config.verbose && config.files.len() > 1 {\n        let total_files = config.files.len();\n        let success = results.len();\n        let failed = errors.len();\n        let total_revisions: usize = results.iter().map(|(_, r)| r.revisions_applied).sum();\n        \n        console.print(&format!(\n            \"\\n[bold]Summary:[/] {} file(s) processed, {} revision(s), {} error(s)\",\n            success, total_revisions, failed\n        ));\n    }\n    \n    // Return error if any file failed\n    if !errors.is_empty() {\n        anyhow::bail!(\n            \"{} file(s) had errors: {}\",\n            errors.len(),\n            errors.iter()\n                .map(|(p, _)| p.display().to_string())\n                .collect::<Vec<_>>()\n                .join(\", \")\n        );\n    }\n    \n    Ok(RunResult::multi(results))\n}\n```\n\n### Output Modes\n\n#### Default (stdout)\n```rust\n// Each file's output concatenated to stdout\nfor (path, result) in &results {\n    if config.files.len() > 1 && !config.in_place {\n        // Add file separator for multi-file output\n        println!(\"==> {} <==\", path.display());\n    }\n    print!(\"{}\", result.output);\n}\n```\n\n#### In-place (-i)\n```rust\n// Each file modified independently\nfor path in &config.files {\n    let content = fs::read_to_string(path)?;\n    let result = process_content(&content, config)?;\n    fs::write(path, &result.output)?;\n}\n```\n\n#### With --diff\n```rust\n// Diff for each file\nfor (path, result) in &results {\n    if result.changed {\n        let original = fs::read_to_string(path)?;\n        print_diff(&original, &result.output, path);\n    }\n}\n```\n\n## Edge Cases\n\n### Mixed Success/Failure\n```rust\n// Continue processing even if some files fail\n// Report all errors at end\n// Exit with error code if ANY file failed\n```\n\n### File Not Found\n```\nError processing docs/missing.md: File not found\nProcessing remaining files...\n```\n\n### Permission Denied\n```\nError processing /etc/passwd: Permission denied\nProcessing remaining files...\n```\n\n### Some Files Unchanged\n```bash\n$ aadc -v docs/*.md\ndocs/aligned.md: No changes\ndocs/needs_fix.md: 2 block(s), 5 revision(s)\n\nSummary: 2 file(s) processed, 5 revision(s), 0 error(s)\n```\n\n## Test Cases\n\n### Unit Tests\n```rust\n#[test]\nfn test_multiple_files_all_success() {\n    let temp = tempfile::tempdir().unwrap();\n    let file1 = temp.path().join(\"a.txt\");\n    let file2 = temp.path().join(\"b.txt\");\n    fs::write(&file1, \"+---+\\n| a|\\n+---+\\n\").unwrap();\n    fs::write(&file2, \"+---+\\n| b|\\n+---+\\n\").unwrap();\n    \n    let config = Config {\n        files: vec![file1.clone(), file2.clone()],\n        in_place: true,\n        ..Default::default()\n    };\n    \n    let result = run(&config).unwrap();\n    \n    assert_eq!(result.files_processed, 2);\n    assert!(fs::read_to_string(&file1).unwrap().contains(\"| a |\"));\n    assert!(fs::read_to_string(&file2).unwrap().contains(\"| b |\"));\n}\n\n#[test]\nfn test_multiple_files_partial_failure() {\n    let temp = tempfile::tempdir().unwrap();\n    let file1 = temp.path().join(\"a.txt\");\n    let file2 = temp.path().join(\"nonexistent.txt\");\n    fs::write(&file1, \"+---+\\n| a|\\n+---+\\n\").unwrap();\n    \n    let config = Config {\n        files: vec![file1.clone(), file2],\n        ..Default::default()\n    };\n    \n    let result = run(&config);\n    \n    // Should error but still process valid files\n    assert!(result.is_err());\n}\n\n#[test]\nfn test_multiple_files_stdout_output() {\n    let temp = tempfile::tempdir().unwrap();\n    let file1 = temp.path().join(\"a.txt\");\n    let file2 = temp.path().join(\"b.txt\");\n    fs::write(&file1, \"content1\").unwrap();\n    fs::write(&file2, \"content2\").unwrap();\n    \n    let config = Config {\n        files: vec![file1, file2],\n        ..Default::default()\n    };\n    \n    let output = capture_stdout(|| run(&config).unwrap());\n    \n    assert!(output.contains(\"content1\"));\n    assert!(output.contains(\"content2\"));\n}\n```\n\n### E2E Tests\n```bash\ntest_multiple_files_inplace() {\n    echo \"+---+\n| a|\n+---+\" > \"$TEMP/a.txt\"\n    echo \"+---+\n| b|\n+---+\" > \"$TEMP/b.txt\"\n    \n    aadc -i \"$TEMP/a.txt\" \"$TEMP/b.txt\"\n    \n    [[ \"$(cat \"$TEMP/a.txt\")\" == *\"| a |\"* ]] || fail \"a.txt not fixed\"\n    [[ \"$(cat \"$TEMP/b.txt\")\" == *\"| b |\"* ]] || fail \"b.txt not fixed\"\n}\n\ntest_multiple_files_glob() {\n    mkdir -p \"$TEMP/docs\"\n    echo \"+---+\n| a|\n+---+\" > \"$TEMP/docs/a.md\"\n    echo \"+---+\n| b|\n+---+\" > \"$TEMP/docs/b.md\"\n    \n    aadc -i \"$TEMP\"/docs/*.md\n    \n    [[ \"$(cat \"$TEMP/docs/a.md\")\" == *\"| a |\"* ]] || fail \"a.md not fixed\"\n    [[ \"$(cat \"$TEMP/docs/b.md\")\" == *\"| b |\"* ]] || fail \"b.md not fixed\"\n}\n\ntest_multiple_files_partial_error() {\n    echo \"valid\" > \"$TEMP/valid.txt\"\n    \n    # Process mix of valid and invalid\n    aadc \"$TEMP/valid.txt\" \"$TEMP/nonexistent.txt\" 2>&1\n    \n    # Should error\n    [[ $? -ne 0 ]] || fail \"Should exit with error\"\n}\n\ntest_multiple_files_verbose_summary() {\n    echo \"+---+\n| a|\n+---+\" > \"$TEMP/a.txt\"\n    echo \"+---+\n| b|\n+---+\" > \"$TEMP/b.txt\"\n    \n    output=$(aadc -v -i \"$TEMP/a.txt\" \"$TEMP/b.txt\" 2>&1)\n    \n    echo \"$output\" | grep -q \"Summary\" || fail \"Missing summary\"\n    echo \"$output\" | grep -q \"2 file(s)\" || fail \"Missing file count\"\n}\n```\n\n## Documentation Updates\n\n### README\n```markdown\n## Processing Multiple Files\n\n\\`\\`\\`bash\n# Multiple files\naadc file1.txt file2.txt file3.txt\n\n# With glob\naadc docs/*.md\n\n# In-place editing\naadc -i docs/*.md\n\n# From find\nfind . -name \"*.md\" -exec aadc -i {} +\n\\`\\`\\`\n```\n\n### Help Text\n```\nARGUMENTS:\n    [FILE]...    Input files. Reads from stdin if not provided.\n                 Multiple files can be specified.\n```\n\n## Success Criteria\n- [ ] Multiple files can be specified\n- [ ] Shell globs work (shell expansion)\n- [ ] Works with -i (in-place)\n- [ ] Works with --diff (per-file diffs)\n- [ ] Continue on error, report all errors\n- [ ] Verbose shows per-file info and summary\n- [ ] Unit tests pass\n- [ ] E2E tests pass\n- [ ] README updated\n\n## Dependencies\n- Requires: CORE: Iterative Correction Loop (bd-apa)\n- Enables: Recursive directory mode (bd-2am)\n- Belongs to: Feature Improvements Epic (bd-1ih)","status":"closed","priority":2,"issue_type":"feature","assignee":"ubuntu","created_at":"2026-01-21T02:01:00.998540673Z","created_by":"ubuntu","updated_at":"2026-01-21T09:54:48.859841470Z","closed_at":"2026-01-21T09:54:48.859794221Z","close_reason":"done","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-5jn","depends_on_id":"bd-1ih","type":"blocks","created_at":"2026-01-21T02:01:37.086523800Z","created_by":"ubuntu"},{"issue_id":"bd-5jn","depends_on_id":"bd-apa","type":"blocks","created_at":"2026-01-21T05:07:43.918569645Z","created_by":"ubuntu"}]}
{"id":"bd-8qw","title":"TESTING: Implement E2E Integration Tests with Logging","description":"## Purpose\nImplement comprehensive End-to-End integration tests that exercise the full aadc pipeline from input to output, with detailed logging for debugging and verification.\n\n## Test Infrastructure\n\n### E2E Test Runner Script\nCreate `tests/e2e_runner.sh`:\n\n```bash\n#!/usr/bin/env bash\nset -euo pipefail\n\n# E2E Test Runner for aadc\n# Usage: ./tests/e2e_runner.sh [--verbose] [--filter PATTERN]\n\nSCRIPT_DIR=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\"\nPROJECT_ROOT=\"$(dirname \"$SCRIPT_DIR\")\"\nAADC_BIN=\"${PROJECT_ROOT}/target/release/aadc\"\nFIXTURES_DIR=\"${SCRIPT_DIR}/fixtures\"\nLOG_FILE=\"${SCRIPT_DIR}/e2e_results.log\"\n\n# Colors for output\nRED='\\033[0;31m'\nGREEN='\\033[0;32m'\nYELLOW='\\033[1;33m'\nBLUE='\\033[0;34m'\nNC='\\033[0m' # No Color\n\nVERBOSE=false\nFILTER=\"\"\nPASSED=0\nFAILED=0\nSKIPPED=0\n\n# Parse arguments\nwhile [[ $# -gt 0 ]]; do\n    case $1 in\n        --verbose|-v)\n            VERBOSE=true\n            shift\n            ;;\n        --filter|-f)\n            FILTER=\"$2\"\n            shift 2\n            ;;\n        *)\n            echo \"Unknown option: $1\"\n            exit 1\n            ;;\n    esac\ndone\n\nlog() {\n    local level=\"$1\"\n    shift\n    local msg=\"$*\"\n    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')\n    \n    echo \"[${timestamp}] [${level}] ${msg}\" >> \"$LOG_FILE\"\n    \n    if [[ \"$VERBOSE\" == \"true\" ]] || [[ \"$level\" == \"ERROR\" ]] || [[ \"$level\" == \"RESULT\" ]]; then\n        case \"$level\" in\n            ERROR)   echo -e \"${RED}[${level}]${NC} ${msg}\" ;;\n            PASS)    echo -e \"${GREEN}[${level}]${NC} ${msg}\" ;;\n            FAIL)    echo -e \"${RED}[${level}]${NC} ${msg}\" ;;\n            SKIP)    echo -e \"${YELLOW}[${level}]${NC} ${msg}\" ;;\n            INFO)    echo -e \"${BLUE}[${level}]${NC} ${msg}\" ;;\n            RESULT)  echo -e \"${BLUE}[${level}]${NC} ${msg}\" ;;\n            *)       echo \"[${level}] ${msg}\" ;;\n        esac\n    fi\n}\n\n# Ensure binary exists\nif [[ ! -f \"$AADC_BIN\" ]]; then\n    log \"INFO\" \"Building aadc in release mode...\"\n    cargo build --release --manifest-path \"${PROJECT_ROOT}/Cargo.toml\"\nfi\n\n# Initialize log\necho \"=== E2E Test Run: $(date) ===\" > \"$LOG_FILE\"\nlog \"INFO\" \"Using binary: $AADC_BIN\"\nlog \"INFO\" \"Fixtures directory: $FIXTURES_DIR\"\n\n# Run a single test case\nrun_test() {\n    local test_name=\"$1\"\n    local input_file=\"$2\"\n    local expected_file=\"$3\"\n    local extra_args=\"${4:-}\"\n    \n    # Apply filter if specified\n    if [[ -n \"$FILTER\" ]] && [[ ! \"$test_name\" =~ $FILTER ]]; then\n        ((SKIPPED++))\n        log \"SKIP\" \"$test_name (filtered out)\"\n        return 0\n    fi\n    \n    log \"INFO\" \"Running test: $test_name\"\n    log \"DEBUG\" \"  Input: $input_file\"\n    log \"DEBUG\" \"  Expected: $expected_file\"\n    log \"DEBUG\" \"  Extra args: $extra_args\"\n    \n    # Run aadc and capture output\n    local actual_output\n    local exit_code=0\n    \n    if [[ -n \"$extra_args\" ]]; then\n        actual_output=$(\"$AADC_BIN\" $extra_args \"$input_file\" 2>&1) || exit_code=$?\n    else\n        actual_output=$(\"$AADC_BIN\" \"$input_file\" 2>&1) || exit_code=$?\n    fi\n    \n    log \"DEBUG\" \"  Exit code: $exit_code\"\n    \n    if [[ $exit_code -ne 0 ]]; then\n        log \"FAIL\" \"$test_name - aadc exited with code $exit_code\"\n        log \"DEBUG\" \"  Output: $actual_output\"\n        ((FAILED++))\n        return 1\n    fi\n    \n    # Compare output with expected\n    local expected_output\n    expected_output=$(cat \"$expected_file\")\n    \n    if [[ \"$actual_output\" == \"$expected_output\" ]]; then\n        log \"PASS\" \"$test_name\"\n        ((PASSED++))\n        return 0\n    else\n        log \"FAIL\" \"$test_name - output mismatch\"\n        log \"DEBUG\" \"  === Expected ===\"\n        log \"DEBUG\" \"$expected_output\"\n        log \"DEBUG\" \"  === Actual ===\"\n        log \"DEBUG\" \"$actual_output\"\n        log \"DEBUG\" \"  === Diff ===\"\n        diff <(echo \"$expected_output\") <(echo \"$actual_output\") >> \"$LOG_FILE\" 2>&1 || true\n        ((FAILED++))\n        return 1\n    fi\n}\n\n# ============================================\n# TEST SUITE: Basic Functionality\n# ============================================\n\nlog \"INFO\" \"=== TEST SUITE: Basic Functionality ===\"\n\nrun_test \"basic_ascii_box\" \\\n    \"${FIXTURES_DIR}/basic/ascii_box.input.txt\" \\\n    \"${FIXTURES_DIR}/basic/ascii_box.expected.txt\"\n\nrun_test \"basic_unicode_box\" \\\n    \"${FIXTURES_DIR}/basic/unicode_box.input.txt\" \\\n    \"${FIXTURES_DIR}/basic/unicode_box.expected.txt\"\n\nrun_test \"basic_mixed_boxes\" \\\n    \"${FIXTURES_DIR}/basic/mixed_boxes.input.txt\" \\\n    \"${FIXTURES_DIR}/basic/mixed_boxes.expected.txt\"\n\n# ============================================\n# TEST SUITE: Edge Cases\n# ============================================\n\nlog \"INFO\" \"=== TEST SUITE: Edge Cases ===\"\n\nrun_test \"edge_empty_file\" \\\n    \"${FIXTURES_DIR}/edge_cases/empty.input.txt\" \\\n    \"${FIXTURES_DIR}/edge_cases/empty.expected.txt\"\n\nrun_test \"edge_no_diagrams\" \\\n    \"${FIXTURES_DIR}/edge_cases/no_diagrams.input.txt\" \\\n    \"${FIXTURES_DIR}/edge_cases/no_diagrams.expected.txt\"\n\nrun_test \"edge_already_aligned\" \\\n    \"${FIXTURES_DIR}/edge_cases/already_aligned.input.txt\" \\\n    \"${FIXTURES_DIR}/edge_cases/already_aligned.expected.txt\"\n\nrun_test \"edge_cjk_content\" \\\n    \"${FIXTURES_DIR}/edge_cases/cjk_content.input.txt\" \\\n    \"${FIXTURES_DIR}/edge_cases/cjk_content.expected.txt\"\n\nrun_test \"edge_nested_boxes\" \\\n    \"${FIXTURES_DIR}/edge_cases/nested_boxes.input.txt\" \\\n    \"${FIXTURES_DIR}/edge_cases/nested_boxes.expected.txt\"\n\n# ============================================\n# TEST SUITE: CLI Options\n# ============================================\n\nlog \"INFO\" \"=== TEST SUITE: CLI Options ===\"\n\nrun_test \"cli_verbose_mode\" \\\n    \"${FIXTURES_DIR}/cli/verbose.input.txt\" \\\n    \"${FIXTURES_DIR}/cli/verbose.expected.txt\" \\\n    \"-v\"\n\nrun_test \"cli_low_threshold\" \\\n    \"${FIXTURES_DIR}/cli/low_threshold.input.txt\" \\\n    \"${FIXTURES_DIR}/cli/low_threshold.expected.txt\" \\\n    \"--min-score 0.2\"\n\nrun_test \"cli_process_all\" \\\n    \"${FIXTURES_DIR}/cli/process_all.input.txt\" \\\n    \"${FIXTURES_DIR}/cli/process_all.expected.txt\" \\\n    \"--all\"\n\nrun_test \"cli_custom_tab_width\" \\\n    \"${FIXTURES_DIR}/cli/tab_width.input.txt\" \\\n    \"${FIXTURES_DIR}/cli/tab_width.expected.txt\" \\\n    \"--tab-width 2\"\n\nrun_test \"cli_max_iterations\" \\\n    \"${FIXTURES_DIR}/cli/max_iters.input.txt\" \\\n    \"${FIXTURES_DIR}/cli/max_iters.expected.txt\" \\\n    \"--max-iters 3\"\n\n# ============================================\n# TEST SUITE: Stdin Processing\n# ============================================\n\nlog \"INFO\" \"=== TEST SUITE: Stdin Processing ===\"\n\ntest_stdin_basic() {\n    local test_name=\"stdin_basic\"\n    log \"INFO\" \"Running test: $test_name\"\n    \n    local input=\"${FIXTURES_DIR}/basic/ascii_box.input.txt\"\n    local expected=\"${FIXTURES_DIR}/basic/ascii_box.expected.txt\"\n    \n    local actual_output\n    actual_output=$(cat \"$input\" | \"$AADC_BIN\")\n    local expected_output=$(cat \"$expected\")\n    \n    if [[ \"$actual_output\" == \"$expected_output\" ]]; then\n        log \"PASS\" \"$test_name\"\n        ((PASSED++))\n    else\n        log \"FAIL\" \"$test_name - stdin output mismatch\"\n        ((FAILED++))\n    fi\n}\ntest_stdin_basic\n\n# ============================================\n# RESULTS SUMMARY\n# ============================================\n\nlog \"RESULT\" \"=========================================\"\nlog \"RESULT\" \"E2E Test Results:\"\nlog \"RESULT\" \"  Passed:  $PASSED\"\nlog \"RESULT\" \"  Failed:  $FAILED\"\nlog \"RESULT\" \"  Skipped: $SKIPPED\"\nlog \"RESULT\" \"  Total:   $((PASSED + FAILED + SKIPPED))\"\nlog \"RESULT\" \"=========================================\"\n\nif [[ $FAILED -gt 0 ]]; then\n    log \"RESULT\" \"See $LOG_FILE for detailed results\"\n    exit 1\nelse\n    log \"RESULT\" \"All tests passed!\"\n    exit 0\nfi\n```\n\n---\n\n## Test Fixtures Directory Structure\n\n```\ntests/\nâ”œâ”€â”€ e2e_runner.sh\nâ”œâ”€â”€ e2e_results.log (generated)\nâ””â”€â”€ fixtures/\n    â”œâ”€â”€ basic/\n    â”‚   â”œâ”€â”€ ascii_box.input.txt\n    â”‚   â”œâ”€â”€ ascii_box.expected.txt\n    â”‚   â”œâ”€â”€ unicode_box.input.txt\n    â”‚   â”œâ”€â”€ unicode_box.expected.txt\n    â”‚   â”œâ”€â”€ mixed_boxes.input.txt\n    â”‚   â””â”€â”€ mixed_boxes.expected.txt\n    â”œâ”€â”€ edge_cases/\n    â”‚   â”œâ”€â”€ empty.input.txt\n    â”‚   â”œâ”€â”€ empty.expected.txt\n    â”‚   â”œâ”€â”€ no_diagrams.input.txt\n    â”‚   â”œâ”€â”€ no_diagrams.expected.txt\n    â”‚   â”œâ”€â”€ already_aligned.input.txt\n    â”‚   â”œâ”€â”€ already_aligned.expected.txt\n    â”‚   â”œâ”€â”€ cjk_content.input.txt\n    â”‚   â”œâ”€â”€ cjk_content.expected.txt\n    â”‚   â”œâ”€â”€ nested_boxes.input.txt\n    â”‚   â””â”€â”€ nested_boxes.expected.txt\n    â””â”€â”€ cli/\n        â”œâ”€â”€ verbose.input.txt\n        â”œâ”€â”€ verbose.expected.txt\n        â”œâ”€â”€ low_threshold.input.txt\n        â”œâ”€â”€ low_threshold.expected.txt\n        â”œâ”€â”€ process_all.input.txt\n        â”œâ”€â”€ process_all.expected.txt\n        â”œâ”€â”€ tab_width.input.txt\n        â”œâ”€â”€ tab_width.expected.txt\n        â”œâ”€â”€ max_iters.input.txt\n        â””â”€â”€ max_iters.expected.txt\n```\n\n---\n\n## Sample Fixtures\n\n### basic/ascii_box.input.txt\n```\n+------------------+\n| Short|\n| Much longer text |\n| Medium|\n+------------------+\n```\n\n### basic/ascii_box.expected.txt\n```\n+------------------+\n| Short            |\n| Much longer text |\n| Medium           |\n+------------------+\n```\n\n### basic/unicode_box.input.txt\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ API Gatewayâ”‚\nâ”‚ Authentication â”‚\nâ”‚ Rate Limitingâ”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n### basic/unicode_box.expected.txt\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ API Gateway    â”‚\nâ”‚ Authentication â”‚\nâ”‚ Rate Limiting  â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n### edge_cases/cjk_content.input.txt\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ Hello ä½ å¥½â”‚\nâ”‚ World ä¸–ç•Œâ”‚\nâ”‚ Test â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n### edge_cases/cjk_content.expected.txt\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ Hello ä½ å¥½       â”‚\nâ”‚ World ä¸–ç•Œ       â”‚\nâ”‚ Test             â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n### edge_cases/nested_boxes.input.txt\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ Outer boxâ”‚\nâ”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚\nâ”‚ â”‚ Inner boxâ”‚       â”‚\nâ”‚ â”‚ Content hereâ”‚    â”‚\nâ”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n---\n\n## Rust Integration Test Module\n\nAdd to `tests/integration.rs`:\n\n```rust\n//! E2E Integration tests for aadc\n//!\n//! Run with: cargo test --test integration\n//! Verbose:  TEST_VERBOSE=1 cargo test --test integration -- --nocapture\n\nuse std::process::Command;\nuse std::fs;\nuse std::path::PathBuf;\n\n/// Test logging macro\nmacro_rules! test_log {\n    ($level:expr, $($arg:tt)*) => {\n        if std::env::var(\"TEST_VERBOSE\").is_ok() {\n            eprintln!(\"[{}] [integration:{}] {}\", \n                $level, \n                line!(), \n                format!($($arg)*)\n            );\n        }\n    };\n}\n\nfn get_binary_path() -> PathBuf {\n    let manifest_dir = env!(\"CARGO_MANIFEST_DIR\");\n    PathBuf::from(manifest_dir)\n        .join(\"target\")\n        .join(\"release\")\n        .join(\"aadc\")\n}\n\nfn run_aadc(input: &str, args: &[&str]) -> (String, i32) {\n    test_log!(\"RUN\", \"aadc with args: {:?}\", args);\n    test_log!(\"INPUT\", \"Input length: {} bytes\", input.len());\n    \n    let output = Command::new(get_binary_path())\n        .args(args)\n        .stdin(std::process::Stdio::piped())\n        .stdout(std::process::Stdio::piped())\n        .stderr(std::process::Stdio::piped())\n        .spawn()\n        .expect(\"Failed to spawn aadc\")\n        .wait_with_output()\n        .expect(\"Failed to wait on aadc\");\n    \n    let stdout = String::from_utf8_lossy(&output.stdout).to_string();\n    let stderr = String::from_utf8_lossy(&output.stderr).to_string();\n    let code = output.status.code().unwrap_or(-1);\n    \n    test_log!(\"OUTPUT\", \"Exit code: {}\", code);\n    test_log!(\"OUTPUT\", \"Stdout length: {} bytes\", stdout.len());\n    if !stderr.is_empty() {\n        test_log!(\"STDERR\", \"{}\", stderr);\n    }\n    \n    (stdout, code)\n}\n\n#[test]\nfn test_e2e_basic_ascii_correction() {\n    test_log!(\"START\", \"Basic ASCII box correction\");\n    \n    let input = r#\"+------------------+\n| Short|\n| Much longer text |\n| Medium|\n+------------------+\"#;\n    \n    let expected = r#\"+------------------+\n| Short            |\n| Much longer text |\n| Medium           |\n+------------------+\"#;\n    \n    let (output, code) = run_aadc(input, &[]);\n    \n    assert_eq!(code, 0, \"Should exit successfully\");\n    assert_eq!(output.trim(), expected.trim(), \"Output should match expected\");\n    \n    test_log!(\"END\", \"Test PASSED\");\n}\n\n#[test]\nfn test_e2e_unicode_box_correction() {\n    test_log!(\"START\", \"Unicode box correction\");\n    \n    let input = \"â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\\nâ”‚ API Gatewayâ”‚\\nâ”‚ Authentication â”‚\\nâ”‚ Rate Limitingâ”‚\\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\";\n    \n    let (output, code) = run_aadc(input, &[]);\n    \n    assert_eq!(code, 0, \"Should exit successfully\");\n    assert!(output.contains(\"â”‚ API Gateway    â”‚\"), \"Should pad API Gateway line\");\n    assert!(output.contains(\"â”‚ Rate Limiting  â”‚\"), \"Should pad Rate Limiting line\");\n    \n    test_log!(\"END\", \"Test PASSED\");\n}\n\n#[test]\nfn test_e2e_empty_input() {\n    test_log!(\"START\", \"Empty input handling\");\n    \n    let (output, code) = run_aadc(\"\", &[]);\n    \n    assert_eq!(code, 0, \"Should exit successfully on empty input\");\n    assert!(output.is_empty() || output.trim().is_empty(), \"Should produce empty output\");\n    \n    test_log!(\"END\", \"Test PASSED\");\n}\n\n#[test]\nfn test_e2e_no_diagrams() {\n    test_log!(\"START\", \"Text without diagrams passthrough\");\n    \n    let input = \"This is just plain text.\\nNo diagrams here.\\n\";\n    \n    let (output, code) = run_aadc(input, &[]);\n    \n    assert_eq!(code, 0, \"Should exit successfully\");\n    assert_eq!(output, input, \"Should pass through unchanged\");\n    \n    test_log!(\"END\", \"Test PASSED\");\n}\n\n#[test]\nfn test_e2e_verbose_mode() {\n    test_log!(\"START\", \"Verbose mode output\");\n    \n    let input = \"+---+\\n| a |\\n+---+\";\n    \n    let (output, code) = run_aadc(input, &[\"-v\"]);\n    \n    assert_eq!(code, 0, \"Should exit successfully\");\n    // Verbose mode outputs to stderr, main content to stdout\n    \n    test_log!(\"END\", \"Test PASSED\");\n}\n\n#[test]\nfn test_e2e_min_score_threshold() {\n    test_log!(\"START\", \"Minimum score threshold option\");\n    \n    let input = \"+---+\\n| a|\\n+---+\";\n    \n    // Very low threshold should accept more revisions\n    let (output_low, code) = run_aadc(input, &[\"--min-score\", \"0.1\"]);\n    assert_eq!(code, 0);\n    \n    // Very high threshold should reject more revisions\n    let (output_high, code) = run_aadc(input, &[\"--min-score\", \"0.99\"]);\n    assert_eq!(code, 0);\n    \n    test_log!(\"COMPARE\", \"Low threshold output: '{}'\", output_low.trim());\n    test_log!(\"COMPARE\", \"High threshold output: '{}'\", output_high.trim());\n    \n    test_log!(\"END\", \"Test PASSED\");\n}\n\n#[test]\nfn test_e2e_process_all_flag() {\n    test_log!(\"START\", \"Process all blocks flag\");\n    \n    let input = \"+---+\\n| a |\\n+---+\";\n    \n    let (output, code) = run_aadc(input, &[\"--all\"]);\n    \n    assert_eq!(code, 0, \"Should exit successfully with --all flag\");\n    \n    test_log!(\"END\", \"Test PASSED\");\n}\n```\n\n---\n\n## Success Criteria\n- [ ] All fixture-based tests pass\n- [ ] Stdin processing works correctly\n- [ ] All CLI flags are tested\n- [ ] CJK and Unicode edge cases verified\n- [ ] Empty file and no-diagram cases handled\n- [ ] Test runner produces detailed log file\n- [ ] Tests can be run verbosely with --verbose flag\n- [ ] CI integration ready (exit codes)\n\n## Dependencies\n- Depends on bd-3h4 (Revision System Unit Tests must pass first)\n- Depends on bd-apa (Iterative Correction Loop must be implemented)\n- Depends on bd-32l (CLI parsing must work)\n\n## Implementation Notes\n- Create `tests/` directory structure first\n- Make `e2e_runner.sh` executable: `chmod +x tests/e2e_runner.sh`\n- Run cargo build --release before E2E tests\n- E2E tests should be run after all unit tests pass\n- Log file helps debug CI failures","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-21T05:54:30.763671465Z","created_by":"ubuntu","updated_at":"2026-01-21T10:53:05.068969600Z","closed_at":"2026-01-21T10:53:05.068915628Z","close_reason":"done","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-8qw","depends_on_id":"bd-32l","type":"blocks","created_at":"2026-01-21T05:56:31.318719207Z","created_by":"ubuntu"},{"issue_id":"bd-8qw","depends_on_id":"bd-3h4","type":"blocks","created_at":"2026-01-21T05:56:30.883935785Z","created_by":"ubuntu"},{"issue_id":"bd-8qw","depends_on_id":"bd-apa","type":"blocks","created_at":"2026-01-21T05:56:31.109619963Z","created_by":"ubuntu"}]}
{"id":"bd-apa","title":"CORE: Iterative Correction Loop","description":"# CORE: Iterative Correction Loop\n\n## Purpose\n\nOrchestrate multiple passes of analysis and correction until alignment converges or max iterations reached. This is the heart of the correction algorithm - where all the components come together.\n\n## Why Iterative?\n\nSingle-pass correction fails when changes affect subsequent analysis:\n\n```\nPass 1:\n+--------+     target=8\n| short|       pad to 8 â†’ \"| short |\"\n+--------+\n| longer  |    already at 9... wait, target should be 9!\n\nWe need to re-analyze after changes.\n```\n\n**Iteration solves this**:\n- Pass 1: Identify max border at col 9\n- Pass 2: All lines already aligned, converge\n\n## Algorithm\n\n```rust\nfn correct_block(\n    lines: &mut [String],\n    block: &DiagramBlock,\n    config: &Config,\n    console: &Console,\n) -> usize {\n    let mut total_revisions = 0;\n    \n    for iteration in 0..config.max_iters {\n        // 1. Analyze current state\n        let analyzed: Vec<AnalyzedLine> = lines[block.start..block.end]\n            .iter()\n            .map(|l| analyze_line(l))\n            .collect();\n        \n        // 2. Find target column (rightmost border)\n        let target_column = match find_target_column(&analyzed) {\n            Some(col) => col,\n            None => break,  // No borders found, nothing to do\n        };\n        \n        // 3. Generate revision candidates\n        let candidates = generate_revisions(&analyzed, target_column);\n        \n        // 4. Filter by score threshold\n        let valid: Vec<Revision> = candidates.into_iter()\n            .filter(|(_, score)| *score >= config.min_score)\n            .map(|(rev, _)| rev)\n            .collect();\n        \n        // 5. Check for convergence\n        if valid.is_empty() {\n            if config.verbose {\n                console.print(&format!(\n                    \"[dim]    Converged after {} iteration(s)[/]\",\n                    iteration + 1\n                ));\n            }\n            break;\n        }\n        \n        // 6. Apply revisions\n        for revision in &valid {\n            apply_revision(&mut lines[block.start..block.end], revision);\n        }\n        \n        total_revisions += valid.len();\n        \n        if config.verbose {\n            console.print(&format!(\n                \"[dim]    Iteration {}: applied {} revision(s)[/]\",\n                iteration + 1,\n                valid.len()\n            ));\n        }\n    }\n    \n    total_revisions\n}\n```\n\n**Location**: src/main.rs lines ~483-564\n\n## Convergence Conditions\n\nThe loop exits when ANY of these occur:\n\n1. **No Valid Revisions**: All lines aligned or below threshold\n2. **Max Iterations Reached**: Safety limit (default 10)\n3. **No Borders Found**: Block has no right borders to align\n\n### Typical Convergence\n\nMost diagrams converge in 1-2 iterations:\n\n```\nIteration 1: Find target, generate N revisions, apply all\nIteration 2: Re-analyze, all aligned, 0 revisions, converge\n```\n\n### Pathological Cases\n\nSome inputs may not converge naturally:\n\n```\n# Conflicting borders at different columns:\n| A |\n| B   |\n| C     |\n```\n\nWith max_iters=10, we apply 10 rounds of padding then stop.\n\n## Revision Application\n\n```rust\nfn apply_revision(lines: &mut [String], revision: &Revision) {\n    match revision {\n        Revision::PadBeforeSuffixBorder { line_idx, spaces_to_add, .. } => {\n            let line = &lines[*line_idx];\n            let trimmed = line.trim_end();\n            let prefix = &trimmed[..trimmed.len() - 1]; // All but last char\n            let last_char = trimmed.chars().last().unwrap();\n            lines[*line_idx] = format!(\n                \"{}{}{}\\n\",\n                prefix,\n                \" \".repeat(*spaces_to_add),\n                last_char\n            );\n        }\n        Revision::AddSuffixBorder { line_idx, border_char, target_column } => {\n            let line = &lines[*line_idx];\n            let trimmed = line.trim_end();\n            let current_width = visual_width(trimmed);\n            let padding = target_column.saturating_sub(current_width);\n            lines[*line_idx] = format!(\n                \"{}{}{}\\n\",\n                trimmed,\n                \" \".repeat(padding),\n                border_char\n            );\n        }\n    }\n}\n```\n\n**Location**: src/main.rs lines ~450-476\n\n## State Between Iterations\n\nEach iteration:\n1. Reads fresh line content (reflects previous changes)\n2. Re-analyzes completely (new SuffixBorder positions)\n3. Re-calculates target column (may change)\n4. Generates fresh revisions\n\n**No state carried over** - each iteration is independent analysis.\n\n## Performance Characteristics\n\n| Metric | Value |\n|--------|-------|\n| Time complexity | O(I Ã— L Ã— W) |\n| Space complexity | O(L) |\n| Typical iterations | 1-2 |\n| Worst case iterations | max_iters (10) |\n\nWhere:\n- I = iterations\n- L = lines in block\n- W = average line width\n\n## Verbose Output\n\nWhen --verbose is set, each iteration logs:\n\n```\n  Block 1: lines 3-7 (confidence: 100%)\n    Iteration 1: applied 2 revision(s)\n    Converged after 1 iteration(s)\n```\n\nColors via rich_rust:\n- Block header: [yellow]\n- Iteration info: [dim]\n- Convergence: [dim]\n\n## Edge Cases\n\n1. **Empty Block**: 0 iterations, 0 revisions\n2. **Single Line Block**: May converge immediately\n3. **All None/Blank Lines**: No target found, exits\n4. **Already Aligned**: 0 revisions, immediate convergence\n\n## Test Coverage\n\n```rust\n#[test] fn test_correct_block_simple() { ... }\n#[test] fn test_correct_block_already_aligned() { ... }\n#[test] fn test_correct_block_multi_iteration() { ... }\n#[test] fn test_correct_block_max_iters() { ... }\n#[test] fn test_correct_block_convergence() { ... }\n```\n\n## Dependencies\n\n- Requires: CORE: Line Analysis\n- Requires: CORE: Revision Generation\n- Requires: CORE: Revision Scoring\n- Requires: CORE: Revision Application\n- Used by: Main Pipeline (correct_lines)","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-21T05:00:41.611383393Z","created_by":"ubuntu","updated_at":"2026-01-21T08:16:58.406122388Z","closed_at":"2026-01-21T08:16:58.406049651Z","close_reason":"done","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-apa","depends_on_id":"bd-1oq","type":"blocks","created_at":"2026-01-21T05:07:20.638417828Z","created_by":"ubuntu"},{"issue_id":"bd-apa","depends_on_id":"bd-2kr","type":"blocks","created_at":"2026-01-21T05:07:20.300591567Z","created_by":"ubuntu"},{"issue_id":"bd-apa","depends_on_id":"bd-3j4","type":"blocks","created_at":"2026-01-21T05:07:21.331375210Z","created_by":"ubuntu"},{"issue_id":"bd-apa","depends_on_id":"bd-sy7","type":"blocks","created_at":"2026-01-21T05:07:21.007492287Z","created_by":"ubuntu"}]}
{"id":"bd-b9s","title":"ROBUSTNESS: Error Handling and Edge Case Implementation","description":"## Purpose\nImplement comprehensive error handling and edge case management across the aadc codebase to ensure robustness and graceful degradation.\n\n## Error Categories and Handling\n\n### 1. File I/O Errors\n\n#### 1.1 File Not Found\n```rust\n// When user specifies a file path that doesn't exist\nfn process_file(path: &Path) -> anyhow::Result<()> {\n    if !path.exists() {\n        anyhow::bail!(\"File not found: {}\", path.display());\n    }\n    // ...\n}\n```\n\n**User-facing message:**\n```\nError: File not found: /path/to/diagram.txt\n```\n\n#### 1.2 Permission Denied\n```rust\nfn read_file(path: &Path) -> anyhow::Result<String> {\n    fs::read_to_string(path)\n        .with_context(|| format!(\"Cannot read file '{}': permission denied or file locked\", path.display()))\n}\n```\n\n#### 1.3 In-Place Write to Stdin\n```rust\n// CLI validation: --in-place requires a file argument\nfn validate_cli_args(cfg: &Config) -> anyhow::Result<()> {\n    if cfg.in_place && cfg.file.is_none() {\n        anyhow::bail!(\"--in-place (-i) requires a file argument; cannot edit stdin in place\");\n    }\n    Ok(())\n}\n```\n\n#### 1.4 Atomic In-Place Writes\n```rust\nfn write_in_place(path: &Path, content: &str) -> anyhow::Result<()> {\n    // Write to temp file first, then rename (atomic on most filesystems)\n    let temp_path = path.with_extension(\"tmp\");\n    fs::write(&temp_path, content)\n        .with_context(|| format!(\"Failed to write temporary file: {}\", temp_path.display()))?;\n    \n    fs::rename(&temp_path, path)\n        .with_context(|| format!(\"Failed to replace original file: {}\", path.display()))?;\n    \n    Ok(())\n}\n```\n\n---\n\n### 2. CLI Argument Errors\n\n#### 2.1 Invalid Score Range\n```rust\nfn validate_min_score(score: f64) -> anyhow::Result<f64> {\n    if !(0.0..=1.0).contains(&score) {\n        anyhow::bail!(\n            \"--min-score must be between 0.0 and 1.0 (got {})\",\n            score\n        );\n    }\n    Ok(score)\n}\n```\n\n#### 2.2 Invalid Max Iterations\n```rust\nfn validate_max_iters(iters: usize) -> anyhow::Result<usize> {\n    if iters == 0 {\n        anyhow::bail!(\"--max-iters must be at least 1 (got 0)\");\n    }\n    if iters > 1000 {\n        eprintln!(\"Warning: --max-iters {} is very high; this may slow processing\", iters);\n    }\n    Ok(iters)\n}\n```\n\n#### 2.3 Invalid Tab Width\n```rust\nfn validate_tab_width(width: usize) -> anyhow::Result<usize> {\n    if width == 0 || width > 16 {\n        anyhow::bail!(\n            \"--tab-width must be between 1 and 16 (got {})\",\n            width\n        );\n    }\n    Ok(width)\n}\n```\n\n---\n\n### 3. Input Content Handling\n\n#### 3.1 Empty File\n```rust\nfn process_content(content: &str) -> String {\n    if content.is_empty() {\n        // Silently return empty output for empty input\n        return String::new();\n    }\n    // ... normal processing\n}\n```\n\n#### 3.2 Binary Content Detection\n```rust\nfn is_likely_binary(content: &[u8]) -> bool {\n    // Check first 8KB for null bytes (common binary indicator)\n    let check_len = content.len().min(8192);\n    content[..check_len].contains(&0)\n}\n\nfn process_input(path: &Path) -> anyhow::Result<String> {\n    let bytes = fs::read(path)?;\n    if is_likely_binary(&bytes) {\n        anyhow::bail!(\n            \"File appears to be binary: {}. aadc only processes text files.\",\n            path.display()\n        );\n    }\n    String::from_utf8(bytes)\n        .with_context(|| format!(\"File is not valid UTF-8: {}\", path.display()))\n}\n```\n\n#### 3.3 Very Large Files\n```rust\nconst MAX_FILE_SIZE: u64 = 100 * 1024 * 1024; // 100 MB\n\nfn check_file_size(path: &Path) -> anyhow::Result<()> {\n    let metadata = fs::metadata(path)?;\n    if metadata.len() > MAX_FILE_SIZE {\n        anyhow::bail!(\n            \"File too large ({} MB). Maximum supported size is {} MB.\",\n            metadata.len() / (1024 * 1024),\n            MAX_FILE_SIZE / (1024 * 1024)\n        );\n    }\n    Ok(())\n}\n```\n\n#### 3.4 Invalid UTF-8\n```rust\nfn read_as_utf8(path: &Path) -> anyhow::Result<String> {\n    let bytes = fs::read(path)?;\n    \n    // Try UTF-8 first\n    if let Ok(s) = String::from_utf8(bytes.clone()) {\n        return Ok(s);\n    }\n    \n    // Provide helpful error message\n    let (valid_up_to, byte_at_error) = {\n        match std::str::from_utf8(&bytes) {\n            Err(e) => (e.valid_up_to(), bytes.get(e.valid_up_to()).copied()),\n            Ok(_) => unreachable!(),\n        }\n    };\n    \n    anyhow::bail!(\n        \"Invalid UTF-8 at byte position {} (byte value: {:?}). \\\n         File must be valid UTF-8 text.\",\n        valid_up_to,\n        byte_at_error\n    )\n}\n```\n\n---\n\n### 4. Algorithm Edge Cases\n\n#### 4.1 Lines Longer Than Terminal Width\n```rust\n// Processing should still work; just won't \"fix\" lines that exceed target\nfn generate_revisions(line: &AnalyzedLine, target_col: usize) -> Vec<Revision> {\n    // Skip if line already at or beyond target (monotone edit guarantee)\n    if line.suffix_border.as_ref().map(|s| s.col).unwrap_or(0) >= target_col {\n        return vec![];  // No revision needed\n    }\n    // ... normal generation\n}\n```\n\n#### 4.2 No Diagram Blocks Found\n```rust\n// Not an error; file is passed through unchanged\nfn process_content(content: &str, cfg: &Config) -> ProcessResult {\n    let blocks = detect_blocks(content);\n    \n    if blocks.is_empty() {\n        if cfg.verbose {\n            eprintln!(\"No diagram blocks detected\");\n        }\n        return ProcessResult {\n            output: content.to_string(),\n            blocks_processed: 0,\n            revisions_applied: 0,\n        };\n    }\n    // ...\n}\n```\n\n#### 4.3 Infinite Loop Prevention\n```rust\nfn iterative_correction(block: &mut DiagramBlock, cfg: &Config) -> usize {\n    let mut iterations = 0;\n    let mut prev_state = String::new();\n    \n    loop {\n        iterations += 1;\n        \n        // Safety: max iterations limit\n        if iterations > cfg.max_iters {\n            if cfg.verbose {\n                eprintln!(\"Warning: Block did not converge after {} iterations\", cfg.max_iters);\n            }\n            break;\n        }\n        \n        // Safety: detect oscillation (same state as previous)\n        let current_state: String = block.lines.iter().map(|l| &l.original).collect();\n        if current_state == prev_state {\n            // Oscillating; bail out\n            break;\n        }\n        prev_state = current_state;\n        \n        // ... apply revisions\n    }\n    \n    iterations\n}\n```\n\n---\n\n### 5. Exit Codes\n\n| Code | Meaning |\n|------|---------|\n| 0 | Success (including no changes made) |\n| 1 | General error (file not found, permission denied, etc.) |\n| 2 | Invalid CLI arguments |\n\n```rust\nfn main() {\n    let result = run();\n    match result {\n        Ok(_) => std::process::exit(0),\n        Err(e) => {\n            eprintln!(\"Error: {:#}\", e);\n            \n            // Determine exit code based on error type\n            let code = if e.to_string().contains(\"not found\") \n                       || e.to_string().contains(\"permission\") {\n                1\n            } else if e.to_string().contains(\"--\") {\n                2  // CLI argument error\n            } else {\n                1\n            };\n            \n            std::process::exit(code);\n        }\n    }\n}\n```\n\n---\n\n## Testing Error Handling\n\n### Unit Tests\n```rust\n#[test]\nfn test_validate_min_score_bounds() {\n    assert!(validate_min_score(-0.1).is_err());\n    assert!(validate_min_score(1.1).is_err());\n    assert!(validate_min_score(0.0).is_ok());\n    assert!(validate_min_score(1.0).is_ok());\n    assert!(validate_min_score(0.5).is_ok());\n}\n\n#[test]\nfn test_binary_detection() {\n    assert!(is_likely_binary(&[0x00, 0x01, 0x02]));\n    assert!(!is_likely_binary(b\"Hello, world!\"));\n    assert!(!is_likely_binary(b\"| Box |\\n+---+\"));\n}\n```\n\n### E2E Error Tests\n```bash\n# tests/e2e_runner.sh additions\n\n# File not found\nrun_error_test \"error_file_not_found\" \\\n    \"/nonexistent/file.txt\" \\\n    1 \\\n    \"File not found\"\n\n# Invalid UTF-8\nrun_error_test \"error_invalid_utf8\" \\\n    \"${FIXTURES_DIR}/error_cases/binary.dat\" \\\n    1 \\\n    \"not valid UTF-8\"\n\n# In-place without file\ntest_inplace_stdin_error() {\n    echo \"test\" | \"$AADC_BIN\" -i 2>&1 | grep -q \"requires a file\"\n    if [[ $? -eq 0 ]]; then\n        log \"PASS\" \"error_inplace_stdin\"\n        ((PASSED++))\n    else\n        log \"FAIL\" \"error_inplace_stdin\"\n        ((FAILED++))\n    fi\n}\ntest_inplace_stdin_error\n```\n\n---\n\n## Success Criteria\n- [ ] All file I/O errors produce helpful messages\n- [ ] CLI argument validation catches all invalid inputs\n- [ ] Binary files are rejected with clear message\n- [ ] Empty files produce empty output (no crash)\n- [ ] Very large files are handled or rejected gracefully\n- [ ] Exit codes follow conventions\n- [ ] Error messages include actionable information\n\n## Dependencies\n- Depends on bd-32l (CLI Argument Parsing)\n- Depends on bd-apa (Iterative Correction Loop)\n\n## Implementation Notes\n- Use anyhow for ergonomic error handling\n- Always include context in error messages\n- Prefer `.with_context()` over plain `?`\n- Test both happy path and error paths","notes":"Implementing error handling and edge cases: added tab_width validation (1-16), MAX_FILE_SIZE check (100MB), warning for high max_iters (>100), plus tests","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-21T05:56:44.840249637Z","created_by":"ubuntu","updated_at":"2026-01-21T11:00:29.748990603Z","closed_at":"2026-01-21T11:00:29.748943725Z","close_reason":"done","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-b9s","depends_on_id":"bd-32l","type":"blocks","created_at":"2026-01-21T05:58:11.736504582Z","created_by":"ubuntu"},{"issue_id":"bd-b9s","depends_on_id":"bd-apa","type":"blocks","created_at":"2026-01-21T05:58:12.918022070Z","created_by":"ubuntu"}]}
{"id":"bd-fdi","title":"CORE: Suffix Border Detection","description":"# CORE: Suffix Border Detection\n\n## Purpose\n\nIdentify and locate the right-hand border character on each line. This tells us WHERE the border is (column position) and WHAT it is (character type), which is essential for calculating how much padding to add.\n\n## SuffixBorder Structure\n\n```rust\nstruct SuffixBorder {\n    column: usize,      // Visual column position (0-indexed)\n    char: char,         // The border character (|, â”‚, â•‘, +, â”˜, etc.)\n    is_closing: bool,   // True if corner or closing character\n}\n```\n\n**Location**: src/main.rs lines ~195-203\n\n## Detection Algorithm\n\n```rust\nfn detect_suffix_border(line: &str) -> Option<SuffixBorder> {\n    let trimmed = line.trim_end();\n    if trimmed.is_empty() {\n        return None;\n    }\n    \n    // Get last character\n    let last_char = trimmed.chars().last()?;\n    \n    // Check if it's a border character\n    if \\!is_border_char(last_char) {\n        return None;\n    }\n    \n    // Calculate column position\n    let prefix = &trimmed[..trimmed.len() - last_char.len_utf8()];\n    let column = visual_width(prefix);\n    \n    // Determine if closing\n    let is_closing = is_corner(last_char) || is_junction(last_char);\n    \n    Some(SuffixBorder {\n        column,\n        char: last_char,\n        is_closing,\n    })\n}\n```\n\n**Location**: src/main.rs lines ~260-285\n\n## Border vs Closing\n\n### Border Characters (is_border_char)\nCharacters that can terminate a line: vertical borders, corners, junctions\n\n```\nâ”‚ â”ƒ â•‘ | + â”Œ â” â”” â”˜ â•” â•— â•š â• â”¬ â”´ â”œ â”¤ â”¼ etc.\n```\n\n### Closing Characters (is_closing=true)\nCharacters that indicate the line is a structural boundary (not content):\n- All corners: + â”Œ â” â”” â”˜ â•” â•— â•š â• â•­ â•® â•¯ â•°\n- All junctions: â”¬ â”´ â”œ â”¤ â”¼ â•¦ â•© â•  â•£ â•¬ etc.\n\n### Content Characters (is_closing=false)\nVertical borders that contain content:\n- â”‚ â”ƒ â•‘ | â•Ž â• etc.\n\n## Column Calculation\n\nThe column is the visual position where the border appears:\n\n```\nLine: \"| hello |\"\n       0123456789\n       â†‘       â†‘\n       col=0   col=7 (returned)\n\nLine: \"| ä½ å¥½ |\"\n       0 12 34 5\n       â†‘ â†‘â†‘ â†‘â†‘ â†‘\n       col=0   col=6 (CJK chars = 2 columns each)\n```\n\n## Why is_closing Matters\n\nThe `is_closing` flag helps revision scoring:\n\n1. **Closing lines** (corners/junctions): Structural, high confidence\n2. **Content lines** (vertical bars): May be mid-content, slightly lower confidence\n\nExample:\n```\n+--------+    â† is_closing=true (corner)\n| text   |    â† is_closing=false (content border)\n| more   |    â† is_closing=false (content border)\n+--------+    â† is_closing=true (corner)\n```\n\n## Edge Cases\n\n1. **No Border**: Returns None if last char isn't a border\n   - `\"just text\"` â†’ None\n   - `\"text | more\"` â†’ None (pipe not at end)\n\n2. **Only Whitespace**: Returns None after trim\n   - `\"    \"` â†’ None\n\n3. **Border with Trailing Space**: Still detected (trim_end handles)\n   - `\"| text |  \"` â†’ SuffixBorder { column: 7, char: '|', is_closing: false }\n\n4. **Unicode Borders**: Correctly handles multi-byte chars\n   - `\"â”‚ text â”‚\"` â†’ SuffixBorder { column: 7, char: 'â”‚', is_closing: false }\n\n## Performance\n\n- O(n) where n = line length\n- Single pass for width calculation\n- No allocations\n- Called for every line in every iteration\n\n## Test Coverage\n\n```rust\n#[test] fn test_detect_suffix_border_simple() { ... }\n#[test] fn test_detect_suffix_border_none() { ... }\n#[test] fn test_detect_suffix_border_unicode() { ... }\n#[test] fn test_detect_suffix_border_closing() { ... }\n#[test] fn test_detect_suffix_border_cjk() { ... }\n```\n\n## Dependencies\n\n- Requires: CORE: Box Character Recognition\n- Requires: CORE: Visual Width Calculation\n- Used by: CORE: Line Analysis (AnalyzedLine)\n- Used by: CORE: Revision Generation","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-21T04:57:37.258321585Z","created_by":"ubuntu","updated_at":"2026-01-21T07:49:03.374788727Z","closed_at":"2026-01-21T07:49:03.373937003Z","close_reason":"Added is_border_char + suffix border semantics; tests updated; QA passed","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-fdi","depends_on_id":"bd-1am","type":"blocks","created_at":"2026-01-21T05:07:17.848832732Z","created_by":"ubuntu"},{"issue_id":"bd-fdi","depends_on_id":"bd-1q9","type":"blocks","created_at":"2026-01-21T05:07:18.092912188Z","created_by":"ubuntu"}]}
{"id":"bd-flx","title":"GitHub Actions: CI workflow (lint, test, coverage >80%, security audit, build)","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-21T01:46:15.965239520Z","created_by":"ubuntu","updated_at":"2026-01-21T03:23:27.757647495Z","closed_at":"2026-01-21T03:23:27.757561713Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-flx","depends_on_id":"bd-13s","type":"blocks","created_at":"2026-01-21T01:46:36.853780007Z","created_by":"ubuntu"},{"issue_id":"bd-flx","depends_on_id":"bd-155","type":"blocks","created_at":"2026-01-21T01:46:37.341201086Z","created_by":"ubuntu"},{"issue_id":"bd-flx","depends_on_id":"bd-1g0","type":"blocks","created_at":"2026-01-21T01:46:37.632167886Z","created_by":"ubuntu"},{"issue_id":"bd-flx","depends_on_id":"bd-21x","type":"blocks","created_at":"2026-01-21T01:46:36.965003358Z","created_by":"ubuntu"},{"issue_id":"bd-flx","depends_on_id":"bd-25l","type":"blocks","created_at":"2026-01-21T01:46:37.152821113Z","created_by":"ubuntu"},{"issue_id":"bd-flx","depends_on_id":"bd-2ig","type":"blocks","created_at":"2026-01-21T01:46:37.056461856Z","created_by":"ubuntu"},{"issue_id":"bd-flx","depends_on_id":"bd-387","type":"blocks","created_at":"2026-01-21T01:46:37.441764451Z","created_by":"ubuntu"},{"issue_id":"bd-flx","depends_on_id":"bd-3e8","type":"blocks","created_at":"2026-01-21T01:46:37.245326582Z","created_by":"ubuntu"},{"issue_id":"bd-flx","depends_on_id":"bd-mpr","type":"blocks","created_at":"2026-01-21T01:46:37.541456175Z","created_by":"ubuntu"}]}
{"id":"bd-i8f","title":"DOCS: Code Documentation and Rustdoc Standards","description":"## Purpose\nEstablish documentation standards for the aadc codebase, including rustdoc conventions, inline comments, and module documentation.\n\n## Rustdoc Standards\n\n### Module-Level Documentation\nEvery module should have a top-level doc comment explaining its purpose:\n\n```rust\n//! # Block Detection Module\n//!\n//! This module implements the ASCII diagram block detection algorithm.\n//!\n//! ## Overview\n//!\n//! Blocks are detected by scanning for consecutive lines containing box-drawing\n//! characters. A state machine with lookahead heuristics groups lines into\n//! coherent diagram blocks.\n//!\n//! ## Key Components\n//!\n//! - [`detect_blocks`]: Main entry point for block detection\n//! - [`LineKind`]: Classification of individual lines\n//! - [`DiagramBlock`]: A detected diagram block with confidence score\n//!\n//! ## Algorithm\n//!\n//! 1. Classify each line as Strong, Weak, Blank, or None\n//! 2. Use state machine to group consecutive diagram-like lines\n//! 3. Apply lookahead to merge blocks separated by blank lines\n//! 4. Calculate confidence scores based on box character density\n```\n\n### Function Documentation\nAll public functions must have comprehensive doc comments:\n\n```rust\n/// Analyzes a single line to determine its role in a diagram.\n///\n/// # Arguments\n///\n/// * `line` - The raw text line to analyze\n///\n/// # Returns\n///\n/// An [`AnalyzedLine`] containing:\n/// - The original text\n/// - Line classification ([`LineKind`])\n/// - Suffix border position if detected\n/// - Left border position if detected\n///\n/// # Examples\n///\n/// ```\n/// let line = analyze_line(\"| Hello World |\");\n/// assert_eq!(line.kind, LineKind::Weak);\n/// assert!(line.suffix_border.is_some());\n/// ```\n///\n/// # Algorithm Details\n///\n/// The function scans the line for box-drawing characters:\n/// 1. Check first non-whitespace character for left border\n/// 2. Scan from right for suffix border characters\n/// 3. Classify based on horizontal/vertical character balance\npub fn analyze_line(line: &str) -> AnalyzedLine {\n    // ...\n}\n```\n\n### Struct Documentation\nDocument all fields and provide usage examples:\n\n```rust\n/// Configuration for the aadc correction algorithm.\n///\n/// This struct is typically constructed via CLI argument parsing\n/// using the `clap` derive macro.\n///\n/// # Examples\n///\n/// ```\n/// let config = Config {\n///     file: Some(PathBuf::from(\"diagram.txt\")),\n///     in_place: false,\n///     max_iters: 10,\n///     min_score: 0.5,\n///     tab_width: 4,\n///     process_all: false,\n///     verbose: false,\n/// };\n/// ```\n#[derive(Parser, Debug)]\npub struct Config {\n    /// Input file path. If not provided, reads from stdin.\n    #[arg(value_name = \"FILE\")]\n    pub file: Option<PathBuf>,\n\n    /// Edit the file in place rather than writing to stdout.\n    ///\n    /// Requires a file argument; incompatible with stdin input.\n    #[arg(short, long)]\n    pub in_place: bool,\n\n    /// Maximum number of correction iterations per block.\n    ///\n    /// Higher values allow more complex corrections but increase\n    /// processing time. Most diagrams converge within 3-5 iterations.\n    #[arg(short = 'm', long, default_value = \"10\")]\n    pub max_iters: usize,\n\n    // ... etc\n}\n```\n\n### Enum Documentation\nDocument each variant with its semantics:\n\n```rust\n/// Classification of a line's role in a diagram.\n///\n/// Lines are classified based on the presence and type of box-drawing\n/// characters. This classification drives revision generation.\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum LineKind {\n    /// A line with strong horizontal structure.\n    ///\n    /// Strong lines typically form the top/bottom borders of boxes:\n    /// ```text\n    /// +----------+   â† Strong (corners + horizontal runs)\n    /// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â† Strong (Unicode corners + horizontal)\n    /// ```\n    Strong,\n\n    /// A line with vertical borders but no horizontal structure.\n    ///\n    /// Weak lines form the content rows of boxes:\n    /// ```text\n    /// | Content  |   â† Weak (vertical borders only)\n    /// â”‚ ãƒ‡ãƒ¼ã‚¿   â”‚   â† Weak (Unicode vertical)\n    /// ```\n    Weak,\n\n    /// A blank or whitespace-only line within a potential block.\n    ///\n    /// Blank lines may separate logical sections within a diagram.\n    Blank,\n\n    /// A line with no detected diagram structure.\n    ///\n    /// These lines are passed through unchanged.\n    None,\n}\n```\n\n---\n\n## Inline Comment Standards\n\n### When to Comment\n1. Non-obvious algorithms (explain the \"why\")\n2. Magic numbers (explain their derivation)\n3. Workarounds (link to issues or explain the constraint)\n4. Performance-critical sections (explain optimizations)\n\n### When NOT to Comment\n1. Self-explanatory code\n2. Obvious getter/setter logic\n3. Comments that restate the code\n\n### Good Examples\n```rust\n// Score formula: Strong lines get higher base confidence.\n// The 20 in the denominator prevents extremely high padding\n// from completely zeroing out the score.\nlet score = base * (1.0 - (spaces_to_add as f64 / 20.0).min(1.0));\n```\n\n```rust\n// HACK: Some terminals render CJK characters at 1.5 columns,\n// but Unicode standard says 2. We assume 2 for consistency.\n// See: https://github.com/example/issue/123\nlet width = if is_cjk_char(c) { 2 } else { 1 };\n```\n\n### Bad Examples (Don't Do This)\n```rust\n// Increment i\ni += 1;\n\n// Check if score is greater than threshold\nif score > threshold {\n```\n\n---\n\n## Documentation Testing\n\n### Run Doc Tests\n```bash\ncargo test --doc\n```\n\n### Ensure All Public Items Documented\n```bash\n# Add to CI or pre-commit\ncargo doc --no-deps 2>&1 | grep -i \"warning.*missing documentation\"\n```\n\n### Check for Broken Links\n```bash\ncargo doc --no-deps --document-private-items\n# Open target/doc/aadc/index.html to verify\n```\n\n---\n\n## README.md Maintenance\n\n### Required Sections\n- [ ] Quick start example\n- [ ] Installation instructions\n- [ ] Feature table\n- [ ] Architecture overview\n- [ ] Command reference with examples\n- [ ] Troubleshooting guide\n- [ ] FAQ\n\n### Keep In Sync\nWhen changing CLI options or behavior:\n1. Update `--help` text (clap derive annotations)\n2. Update README.md command reference\n3. Update any affected examples\n\n---\n\n## Success Criteria\n- [ ] All public functions have rustdoc\n- [ ] All public structs/enums have field/variant docs\n- [ ] Module-level documentation exists\n- [ ] Doc tests pass (`cargo test --doc`)\n- [ ] No missing documentation warnings\n- [ ] README matches implementation\n\n## Dependencies\n- Depends on bd-30v (Architecture documentation provides context)\n- Depends on bd-32l (CLI parsing defines the public interface)\n\n## Implementation Notes\n- Use `#![warn(missing_docs)]` to catch undocumented items\n- Run `cargo doc --open` to preview documentation\n- Inline code examples should be runnable doc tests where possible","notes":"Starting documentation improvements: rustdoc standards","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-21T05:59:11.524837576Z","created_by":"ubuntu","updated_at":"2026-01-21T11:06:14.414013811Z","closed_at":"2026-01-21T11:06:14.413969979Z","close_reason":"done","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-i8f","depends_on_id":"bd-30v","type":"blocks","created_at":"2026-01-21T06:00:26.101550015Z","created_by":"ubuntu"},{"issue_id":"bd-i8f","depends_on_id":"bd-32l","type":"blocks","created_at":"2026-01-21T06:00:27.131971195Z","created_by":"ubuntu"}]}
{"id":"bd-mpr","title":"E2E tests: Fixture-based tests (ASCII, Unicode, mixed, nested, large files, CJK, emoji)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-21T01:46:05.950891932Z","created_by":"ubuntu","updated_at":"2026-01-21T02:58:37.131615662Z","closed_at":"2026-01-21T02:58:37.131527135Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-mpr","depends_on_id":"bd-p73","type":"blocks","created_at":"2026-01-21T01:46:31.598686701Z","created_by":"ubuntu"}]}
{"id":"bd-nci","title":"Add semantic exit codes","description":"## Purpose\nImplement semantic exit codes that allow scripts and CI systems to understand what happened during execution. Essential for reliable automation.\n\n## Exit Code Definitions\n\n| Code | Name | Meaning |\n|------|------|---------|\n| 0 | SUCCESS | Completed successfully (may or may not have made changes) |\n| 1 | ERROR | General error (file not found, permission denied, etc.) |\n| 2 | INVALID_ARGS | Invalid command-line arguments |\n| 3 | WOULD_CHANGE | Dry-run mode: changes would be made |\n| 4 | PARSE_ERROR | Input parsing error (invalid UTF-8, binary file) |\n\n## Implementation\n\n### Exit Code Constants\n```rust\nmod exit_codes {\n    pub const SUCCESS: i32 = 0;\n    pub const ERROR: i32 = 1;\n    pub const INVALID_ARGS: i32 = 2;\n    pub const WOULD_CHANGE: i32 = 3;\n    pub const PARSE_ERROR: i32 = 4;\n}\n```\n\n### Main Function Integration\n```rust\nfn main() {\n    let result = run();\n    \n    let code = match result {\n        Ok(outcome) => {\n            if outcome.dry_run && outcome.would_change {\n                exit_codes::WOULD_CHANGE\n            } else {\n                exit_codes::SUCCESS\n            }\n        }\n        Err(e) => {\n            eprintln!(\"Error: {:#}\", e);\n            \n            // Determine specific error type\n            if e.is::<clap::Error>() {\n                exit_codes::INVALID_ARGS\n            } else if e.to_string().contains(\"UTF-8\") \n                   || e.to_string().contains(\"binary\") {\n                exit_codes::PARSE_ERROR\n            } else {\n                exit_codes::ERROR\n            }\n        }\n    };\n    \n    std::process::exit(code);\n}\n```\n\n### Error Type Classification\n```rust\n#[derive(Debug)]\npub enum AadcError {\n    Io(std::io::Error),\n    InvalidArgs(String),\n    Parse(String),\n    Internal(String),\n}\n\nimpl AadcError {\n    pub fn exit_code(&self) -> i32 {\n        match self {\n            AadcError::InvalidArgs(_) => exit_codes::INVALID_ARGS,\n            AadcError::Parse(_) => exit_codes::PARSE_ERROR,\n            _ => exit_codes::ERROR,\n        }\n    }\n}\n```\n\n## Use Cases\n\n### CI Pipeline Check\n```bash\n#!/bin/bash\naadc --dry-run \"$file\"\ncase $? in\n    0) echo \"No changes needed\" ;;\n    3) echo \"Diagrams need alignment\"; exit 1 ;;\n    *) echo \"Error occurred\"; exit 1 ;;\nesac\n```\n\n### Git Pre-commit Hook\n```bash\n#!/bin/bash\nfor file in $(git diff --cached --name-only --diff-filter=ACM | grep -E '\\.(md|txt)$'); do\n    aadc --dry-run \"$file\"\n    if [[ $? -eq 3 ]]; then\n        echo \"Please align diagrams in $file\"\n        exit 1\n    fi\ndone\n```\n\n### Batch Processing Script\n```bash\n#!/bin/bash\nerrors=0\nfor file in docs/*.md; do\n    aadc -i \"$file\"\n    code=$?\n    if [[ $code -ne 0 && $code -ne 3 ]]; then\n        echo \"Error processing $file (exit $code)\"\n        ((errors++))\n    fi\ndone\nexit $errors\n```\n\n### Make Target\n```makefile\n.PHONY: check-diagrams\ncheck-diagrams:\n\t@for f in $$(find docs -name '*.md'); do \\\n\t\taadc --dry-run \"$$f\" || exit 1; \\\n\tdone\n```\n\n## Test Cases\n\n### Unit Tests\n```rust\n#[test]\nfn test_exit_code_success_no_changes() {\n    let temp = tempfile::tempdir().unwrap();\n    let file = temp.path().join(\"aligned.txt\");\n    fs::write(&file, \"+---+\\n| a |\\n+---+\\n\").unwrap();\n    \n    let result = run_with_args(&[\"aadc\", file.to_str().unwrap()]);\n    assert_eq!(result.exit_code, exit_codes::SUCCESS);\n}\n\n#[test]\nfn test_exit_code_success_with_changes() {\n    let temp = tempfile::tempdir().unwrap();\n    let file = temp.path().join(\"unaligned.txt\");\n    fs::write(&file, \"+---+\\n| a|\\n+---+\\n\").unwrap();\n    \n    let result = run_with_args(&[\"aadc\", \"-i\", file.to_str().unwrap()]);\n    assert_eq!(result.exit_code, exit_codes::SUCCESS);\n}\n\n#[test]\nfn test_exit_code_would_change() {\n    let temp = tempfile::tempdir().unwrap();\n    let file = temp.path().join(\"unaligned.txt\");\n    fs::write(&file, \"+---+\\n| a|\\n+---+\\n\").unwrap();\n    \n    let result = run_with_args(&[\"aadc\", \"--dry-run\", file.to_str().unwrap()]);\n    assert_eq!(result.exit_code, exit_codes::WOULD_CHANGE);\n}\n\n#[test]\nfn test_exit_code_file_not_found() {\n    let result = run_with_args(&[\"aadc\", \"nonexistent.txt\"]);\n    assert_eq!(result.exit_code, exit_codes::ERROR);\n}\n\n#[test]\nfn test_exit_code_invalid_args() {\n    let result = run_with_args(&[\"aadc\", \"--invalid-flag\"]);\n    assert_eq!(result.exit_code, exit_codes::INVALID_ARGS);\n}\n\n#[test]\nfn test_exit_code_binary_file() {\n    let temp = tempfile::tempdir().unwrap();\n    let file = temp.path().join(\"binary.dat\");\n    fs::write(&file, &[0x00, 0x01, 0x02, 0x03]).unwrap();\n    \n    let result = run_with_args(&[\"aadc\", file.to_str().unwrap()]);\n    assert_eq!(result.exit_code, exit_codes::PARSE_ERROR);\n}\n```\n\n### E2E Tests\n```bash\ntest_exit_code_success() {\n    echo \"+---+\n| a |\n+---+\" > \"$TEMP/aligned.txt\"\n    \n    aadc \"$TEMP/aligned.txt\" > /dev/null\n    [[ $? -eq 0 ]] || fail \"Expected exit code 0, got $?\"\n}\n\ntest_exit_code_would_change() {\n    echo \"+---+\n| a|\n+---+\" > \"$TEMP/unaligned.txt\"\n    \n    aadc --dry-run \"$TEMP/unaligned.txt\" > /dev/null\n    [[ $? -eq 3 ]] || fail \"Expected exit code 3, got $?\"\n}\n\ntest_exit_code_file_not_found() {\n    aadc /nonexistent/file.txt 2>/dev/null\n    [[ $? -eq 1 ]] || fail \"Expected exit code 1, got $?\"\n}\n\ntest_exit_code_invalid_args() {\n    aadc --invalid-flag 2>/dev/null\n    [[ $? -eq 2 ]] || fail \"Expected exit code 2, got $?\"\n}\n```\n\n## Documentation Updates\n\n### README Section\n```markdown\n## Exit Codes\n\n| Code | Meaning |\n|------|---------|\n| 0 | Success |\n| 1 | General error |\n| 2 | Invalid arguments |\n| 3 | Dry-run: changes would be made |\n| 4 | Parse error (invalid UTF-8/binary) |\n```\n\n### Help Text\n```\nEXIT CODES:\n    0    Success (no errors)\n    1    General error (file not found, permission denied)\n    2    Invalid command-line arguments\n    3    Dry-run mode: changes would be made\n    4    Parse error (invalid UTF-8 or binary file)\n```\n\n## Success Criteria\n- [ ] All exit codes correctly implemented\n- [ ] Error messages written to stderr\n- [ ] Dry-run uses code 3 for \"would change\"\n- [ ] Invalid args uses code 2\n- [ ] Parse errors use code 4\n- [ ] Unit tests cover all codes\n- [ ] E2E tests verify behavior\n- [ ] README documents codes\n- [ ] --help shows exit code info\n\n## Dependencies\n- Requires: CORE: Iterative Correction Loop (bd-apa)\n- Requires: ROBUSTNESS: Error Handling (bd-b9s)\n- Belongs to: Feature Improvements Epic (bd-1ih)","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-21T02:01:15.250671334Z","created_by":"ubuntu","updated_at":"2026-01-21T09:52:09.969388737Z","closed_at":"2026-01-21T09:52:09.969138376Z","close_reason":"Implemented semantic exit code handling, parse error classification, and docs/tests updates.","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-nci","depends_on_id":"bd-1ih","type":"blocks","created_at":"2026-01-21T02:01:37.364141399Z","created_by":"ubuntu"},{"issue_id":"bd-nci","depends_on_id":"bd-apa","type":"blocks","created_at":"2026-01-21T05:07:44.289780507Z","created_by":"ubuntu"}]}
{"id":"bd-p73","title":"Create E2E test fixtures (input/expected output pairs for all diagram types)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-21T01:46:14.167889089Z","created_by":"ubuntu","updated_at":"2026-01-21T02:23:24.889807626Z","closed_at":"2026-01-21T02:23:24.889749917Z","close_reason":"Created 16 E2E test fixtures covering ASCII, Unicode, mixed, edge cases, and large files. All fixtures validated against aadc binary output.","compaction_level":0,"original_size":0}
{"id":"bd-raz","title":"Add --diff flag for unified diff output","description":"## Purpose\nAdd a `--diff` flag that outputs changes as a unified diff instead of the full corrected content. Essential for code review, CI pipelines, and understanding exactly what changed.\n\n## CLI Interface\n\n```bash\n# Show unified diff of changes\naadc --diff file.txt\n# Output: unified diff format (like `diff -u`)\n\n# Combine with dry-run for non-destructive preview\naadc --dry-run --diff file.txt\n\n# Pipe to common tools\naadc --diff file.txt | patch -p0  # Apply changes\naadc --diff file.txt | delta      # Pretty diff viewer\naadc --diff file.txt | colordiff  # Colored output\n```\n\n## Implementation\n\n### Dependency\nUses the `similar` crate (already in dependencies) for diff generation.\n\n### Argument Definition (clap)\n```rust\n#[derive(Parser, Debug)]\npub struct Config {\n    // ... existing args ...\n    \n    /// Output unified diff instead of full content\n    /// \n    /// Shows changes in unified diff format, compatible with\n    /// patch, delta, and other diff tools.\n    #[arg(long, short = 'd')]\n    pub diff: bool,\n}\n```\n\n### Diff Generation\n```rust\nuse similar::{ChangeTag, TextDiff};\n\nfn print_diff(original: &str, modified: &str, path: &Path) {\n    let diff = TextDiff::from_lines(original, modified);\n    \n    // Header\n    println!(\"--- {}\", path.display());\n    println!(\"+++ {} (corrected)\", path.display());\n    \n    for (idx, group) in diff.grouped_ops(3).iter().enumerate() {\n        // Hunk header\n        if let Some(first) = group.first() {\n            let old_start = first.old_range().start + 1;\n            let new_start = first.new_range().start + 1;\n            let old_len = group.iter().map(|op| op.old_range().len()).sum::<usize>();\n            let new_len = group.iter().map(|op| op.new_range().len()).sum::<usize>();\n            println!(\"@@ -{},{} +{},{} @@\", old_start, old_len, new_start, new_len);\n        }\n        \n        for op in group {\n            for change in diff.iter_inline_changes(op) {\n                let (sign, style) = match change.tag() {\n                    ChangeTag::Delete => (\"-\", \"red\"),\n                    ChangeTag::Insert => (\"+\", \"green\"),\n                    ChangeTag::Equal => (\" \", \"\"),\n                };\n                print!(\"{}\", sign);\n                for (emphasized, value) in change.iter_strings_lossy() {\n                    if emphasized {\n                        // Could add emphasis styling if using rich_rust\n                        print!(\"{}\", value);\n                    } else {\n                        print!(\"{}\", value);\n                    }\n                }\n                if change.missing_newline() {\n                    println!(\"\\n\\\\ No newline at end of file\");\n                }\n            }\n        }\n    }\n}\n```\n\n### Integration with Output Flow\n```rust\nfn output_result(original: &str, result: &str, config: &Config) {\n    if config.diff {\n        if original != result {\n            print_diff(original, result, config.file.as_ref().unwrap_or(&PathBuf::from(\"-\")));\n        } else if config.verbose {\n            eprintln!(\"No changes\");\n        }\n    } else if config.in_place {\n        // Write to file\n        if let Some(path) = &config.file {\n            fs::write(path, result)?;\n        }\n    } else {\n        // Write to stdout\n        print!(\"{}\", result);\n    }\n}\n```\n\n## Output Format\n\n### Standard Unified Diff\n```diff\n--- diagram.txt\n+++ diagram.txt (corrected)\n@@ -1,5 +1,5 @@\n +------------------+\n-| Short|\n+| Short            |\n | Much longer text |\n-| Medium|\n+| Medium           |\n +------------------+\n```\n\n### With Context\n```diff\n--- README.md\n+++ README.md (corrected)\n@@ -45,7 +45,7 @@\n Here's my architecture:\n \n â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n-â”‚ API Gatewayâ”‚\n+â”‚ API Gateway    â”‚\n â”‚ Authentication â”‚\n-â”‚ Rate Limitingâ”‚\n+â”‚ Rate Limiting  â”‚\n â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n## Color Support (Future Enhancement)\n\n```rust\n// With rich_rust terminal output:\nfn print_colored_diff(original: &str, modified: &str, path: &Path, console: &Console) {\n    let diff = TextDiff::from_lines(original, modified);\n    \n    console.print(&format!(\"[bold]--- {}[/]\", path.display()));\n    console.print(&format!(\"[bold]+++ {} (corrected)[/]\", path.display()));\n    \n    for change in diff.iter_all_changes() {\n        match change.tag() {\n            ChangeTag::Delete => console.print(&format!(\"[red]-{}[/]\", change)),\n            ChangeTag::Insert => console.print(&format!(\"[green]+{}[/]\", change)),\n            ChangeTag::Equal => print!(\" {}\", change),\n        }\n    }\n}\n```\n\n## Test Cases\n\n### Unit Tests\n```rust\n#[test]\nfn test_diff_output_format() {\n    let original = \"+---+\\n| a|\\n+---+\\n\";\n    let modified = \"+---+\\n| a |\\n+---+\\n\";\n    \n    let mut output = Vec::new();\n    print_diff_to(&original, &modified, Path::new(\"test.txt\"), &mut output);\n    let diff_str = String::from_utf8(output).unwrap();\n    \n    assert!(diff_str.contains(\"--- test.txt\"));\n    assert!(diff_str.contains(\"+++ test.txt (corrected)\"));\n    assert!(diff_str.contains(\"-| a|\"));\n    assert!(diff_str.contains(\"+| a |\"));\n}\n\n#[test]\nfn test_diff_no_changes() {\n    let content = \"+---+\\n| a |\\n+---+\\n\";\n    \n    let mut output = Vec::new();\n    print_diff_to(&content, &content, Path::new(\"test.txt\"), &mut output);\n    \n    // No output when content is identical\n    assert!(output.is_empty());\n}\n\n#[test]\nfn test_diff_hunk_headers() {\n    let original = \"line1\\nline2\\n+---+\\n| a|\\n+---+\\nline6\\n\";\n    let modified = \"line1\\nline2\\n+---+\\n| a |\\n+---+\\nline6\\n\";\n    \n    let mut output = Vec::new();\n    print_diff_to(&original, &modified, Path::new(\"test.txt\"), &mut output);\n    let diff_str = String::from_utf8(output).unwrap();\n    \n    // Should have hunk header with line numbers\n    assert!(diff_str.contains(\"@@\"));\n    assert!(diff_str.contains(\"4\")); // Line 4 changed\n}\n```\n\n### E2E Tests\n```bash\ntest_diff_output() {\n    echo \"+---+\n| a|\n+---+\" > \"$TEMP/test.txt\"\n    \n    diff_output=$(aadc --diff \"$TEMP/test.txt\")\n    \n    # Check unified diff format\n    echo \"$diff_output\" | grep -q \"^--- \" || fail \"Missing diff header\"\n    echo \"$diff_output\" | grep -q \"^+++ \" || fail \"Missing diff header\"\n    echo \"$diff_output\" | grep -q \"^-| a|\" || fail \"Missing deletion\"\n    echo \"$diff_output\" | grep -q \"^+| a |\" || fail \"Missing addition\"\n}\n\ntest_diff_pipeable() {\n    echo \"+---+\n| a|\n+---+\" > \"$TEMP/test.txt\"\n    \n    # Should be valid patch format\n    aadc --diff \"$TEMP/test.txt\" > \"$TEMP/changes.patch\"\n    \n    # Apply and verify\n    cp \"$TEMP/test.txt\" \"$TEMP/test2.txt\"\n    patch \"$TEMP/test2.txt\" < \"$TEMP/changes.patch\"\n    \n    [[ \"$(cat \"$TEMP/test2.txt\")\" == *\"| a |\"* ]] || fail \"Patch didn't apply\"\n}\n\ntest_diff_no_changes() {\n    echo \"+---+\n| a |\n+---+\" > \"$TEMP/test.txt\"\n    \n    diff_output=$(aadc --diff \"$TEMP/test.txt\")\n    \n    # No output for no changes\n    [[ -z \"$diff_output\" ]] || fail \"Should be empty when no changes\"\n}\n```\n\n## Integration with Other Flags\n\n### --diff + --dry-run\nPerfect for CI: show changes without modifying\n```bash\naadc --dry-run --diff file.txt\n```\n\n### --diff + -v\nShow verbose info + diff\n```bash\naadc --diff -v file.txt\n```\n\n### --diff + -i\nApply changes in-place AND show diff\n```bash\naadc --diff -i file.txt\n# Modifies file AND prints diff of what changed\n```\n\n## Documentation Updates\n\n### README\nAdd to Command Reference:\n\n| Option | Short | Default | Description |\n|--------|-------|---------|-------------|\n| `--diff` | `-d` | false | Output unified diff instead of full content |\n\n### Example Section\n```bash\n# Show diff of changes\naadc --diff diagram.txt\n\n# Preview changes without modifying\naadc --dry-run --diff diagram.txt\n\n# Apply and see what changed\naadc --diff -i diagram.txt\n```\n\n## Success Criteria\n- [ ] Outputs valid unified diff format\n- [ ] Compatible with patch command\n- [ ] Works with --dry-run\n- [ ] Works with -v\n- [ ] Works with -i (show + apply)\n- [ ] No output when no changes\n- [ ] Correct line numbers in hunk headers\n- [ ] Unit tests pass\n- [ ] E2E tests pass\n- [ ] README updated\n\n## Dependencies\n- Requires: CORE: Iterative Correction Loop (bd-apa)\n- Uses: similar crate (diff generation)\n- Belongs to: Feature Improvements Epic (bd-1ih)","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-21T02:00:50.079362998Z","created_by":"ubuntu","updated_at":"2026-01-21T08:16:58.857842229Z","closed_at":"2026-01-21T08:16:58.857756448Z","close_reason":"done","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-raz","depends_on_id":"bd-1ih","type":"blocks","created_at":"2026-01-21T02:01:35.821896632Z","created_by":"ubuntu"},{"issue_id":"bd-raz","depends_on_id":"bd-apa","type":"blocks","created_at":"2026-01-21T05:07:42.453836749Z","created_by":"ubuntu"}]}
{"id":"bd-sy7","title":"CORE: Revision Scoring System","description":"# CORE: Revision Scoring System\n\n## Purpose\n\nAssign confidence scores (0.0-1.0) to proposed revisions. This is the gatekeeper that prevents aggressive modifications on ambiguous content. Only revisions meeting the min_score threshold (default 0.5) are applied.\n\n## Scoring Philosophy\n\n**Conservative by Default**: We'd rather miss some corrections than make wrong ones.\n\n**User Control**: The --min-score flag lets users adjust aggressiveness:\n- 0.7-1.0: Very conservative, only obvious fixes\n- 0.5 (default): Balanced, most clear cases\n- 0.3-0.5: More aggressive, catches edge cases\n- 0.0-0.3: Very aggressive, use with caution\n\n## PadBeforeSuffixBorder Scoring\n\n```rust\nfn score_pad_revision(spaces_to_add: usize, kind: &LineKind) -> f64 {\n    // Base score: 0.8 (adding spaces is relatively safe)\n    let base = 0.8;\n    \n    // Penalty for large adjustments (prefer small changes)\n    // 1 space = 0.1, 5 spaces = 0.5, 10+ spaces = 0.5 (capped)\n    let adjustment_penalty = (spaces_to_add as f64 / 10.0).min(0.5);\n    \n    // Bonus for strong lines (more confident about structural lines)\n    let strength_bonus = match kind {\n        LineKind::Strong => 0.2,\n        _ => 0.0,\n    };\n    \n    base - adjustment_penalty + strength_bonus\n}\n```\n\n**Location**: src/main.rs lines ~425-440\n\n### Score Examples\n\n| Spaces | Line Kind | Calculation | Score |\n|--------|-----------|-------------|-------|\n| 1 | Strong | 0.8 - 0.1 + 0.2 | 0.90 |\n| 2 | Strong | 0.8 - 0.2 + 0.2 | 0.80 |\n| 5 | Strong | 0.8 - 0.5 + 0.2 | 0.50 |\n| 1 | Weak | 0.8 - 0.1 + 0.0 | 0.70 |\n| 5 | Weak | 0.8 - 0.5 + 0.0 | 0.30 |\n| 10 | Weak | 0.8 - 0.5 + 0.0 | 0.30 |\n| 10 | Strong | 0.8 - 0.5 + 0.2 | 0.50 |\n\n### Rationale\n\n**Adjustment Penalty**: Large padding amounts suggest the line might not belong to this diagram, or the detection was wrong. Small adjustments are more likely correct.\n\n**Strength Bonus**: Lines with clear box structure (corners, both borders) deserve more confidence. Weak lines might just happen to have a pipe character.\n\n## AddSuffixBorder Scoring\n\n```rust\nfn score_add_revision(kind: &LineKind) -> f64 {\n    // Lower base score: adding content is riskier than adjusting\n    let base = 0.5;\n    \n    // Bonus for line strength\n    let strength_bonus = match kind {\n        LineKind::Strong => 0.2,\n        LineKind::Weak => 0.1,\n        _ => 0.0,\n    };\n    \n    base + strength_bonus\n}\n```\n\n**Location**: src/main.rs lines ~442-447\n\n### Score Examples\n\n| Line Kind | Calculation | Score |\n|-----------|-------------|-------|\n| Strong | 0.5 + 0.2 | 0.70 |\n| Weak | 0.5 + 0.1 | 0.60 |\n| None | 0.5 + 0.0 | 0.50 |\n\n### Rationale\n\n**Lower Base (0.5)**: Adding a border character is more invasive than padding. We're putting characters where the user didn't put any.\n\n**Still Applied at Default**: Score of 0.6-0.7 passes the default 0.5 threshold, but users can raise it to 0.7+ to disable border insertion.\n\n## Threshold Application\n\n```rust\nfn filter_revisions(\n    revisions: Vec<(Revision, f64)>,\n    min_score: f64,\n) -> Vec<Revision> {\n    revisions.into_iter()\n        .filter(|(_, score)| *score >= min_score)\n        .map(|(rev, _)| rev)\n        .collect()\n}\n```\n\n## Score Distribution by Use Case\n\n### CI/CD Integration (--min-score 0.7)\nOnly high-confidence fixes, conservative:\n- âœ“ Small padding on Strong lines\n- âœ— Large padding\n- âœ— Border insertion\n\n### Default Usage (--min-score 0.5)\nBalanced for most users:\n- âœ“ Small-medium padding on any boxy line\n- âœ“ Border insertion on Strong lines\n- âœ— Large padding on Weak lines\n\n### Aggressive Mode (--min-score 0.3)\nFor users who want maximum correction:\n- âœ“ Almost all padding\n- âœ“ Border insertion on Weak lines\n- âœ— Only very large padding on non-boxy lines\n\n### Maximum (--all --min-score 0.1)\nProcess everything, user reviewed output:\n- âœ“ Essentially all proposed revisions\n\n## Design Decisions\n\n### Why Not Use Block Confidence?\n\nWe could weight revision scores by block confidence, but:\n1. Block confidence already gates which blocks we process\n2. Line-level scoring is more precise\n3. Keeps concerns separate\n\n### Why Not Learn Optimal Scores?\n\nMachine learning could tune scores, but:\n1. Training data is limited\n2. User expectations vary widely\n3. Simple heuristics are explainable\n4. Users can tune with --min-score\n\n### Why Linear Penalty?\n\nWe use linear penalty (spaces/10) vs exponential:\n- Predictable behavior\n- Easy to reason about\n- Good enough for real-world cases\n\n## Future Enhancements\n\n1. **Context-Aware Scoring**: Consider neighboring lines\n2. **Pattern Matching**: Recognize specific diagram styles\n3. **User Feedback**: Learn from --accept/--reject interactions\n\n## Test Coverage\n\n```rust\n#[test] fn test_score_pad_revision_small() { ... }\n#[test] fn test_score_pad_revision_large() { ... }\n#[test] fn test_score_pad_revision_strong() { ... }\n#[test] fn test_score_add_revision() { ... }\n#[test] fn test_filter_revisions_threshold() { ... }\n```\n\n## Dependencies\n\n- Used by: CORE: Revision Generation System\n- Affects: All revision application\n- Configured by: CLI --min-score flag","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-21T05:00:06.292063075Z","created_by":"ubuntu","updated_at":"2026-01-21T07:45:26.021946163Z","closed_at":"2026-01-21T07:45:26.021895969Z","close_reason":"Validated revision scoring logic + tests; no code changes needed","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-sy7","depends_on_id":"bd-2r3","type":"blocks","created_at":"2026-01-21T05:07:20.016513835Z","created_by":"ubuntu"}]}
